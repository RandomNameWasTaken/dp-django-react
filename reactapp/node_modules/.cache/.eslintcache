[{"/home/xkruzel/Desktop/todo/reactapp/src/index.js":"1","/home/xkruzel/Desktop/todo/reactapp/src/App.js":"2","/home/xkruzel/Desktop/todo/reactapp/src/reportWebVitals.js":"3","/home/xkruzel/Desktop/todo/reactapp/src/StateApp.ts":"4","/home/xkruzel/Desktop/todo/reactapp/src/LoadJson.jsx":"5","/home/xkruzel/Desktop/todo/reactapp/src/Visualise.jsx":"6","/home/xkruzel/Desktop/todo/reactapp/src/Create.jsx":"7","/home/xkruzel/Desktop/todo/reactapp/src/LoadAeon.jsx":"8","/home/xkruzel/Desktop/todo/reactapp/src/rendering.js":"9","/home/xkruzel/Desktop/todo/reactapp/src/Point.js":"10"},{"size":535,"mtime":1662399185904,"results":"11","hashOfConfig":"12"},{"size":1907,"mtime":1664612970253,"results":"13","hashOfConfig":"12"},{"size":362,"mtime":1662399185904,"results":"14","hashOfConfig":"12"},{"size":127,"mtime":1662402289635,"results":"15","hashOfConfig":"12"},{"size":2220,"mtime":1664623874816,"results":"16","hashOfConfig":"12"},{"size":4949,"mtime":1664704048915,"results":"17","hashOfConfig":"12"},{"size":568,"mtime":1662402288407,"results":"18","hashOfConfig":"12"},{"size":14167,"mtime":1664704028079,"results":"19","hashOfConfig":"12"},{"size":11742,"mtime":1664659100182,"results":"20","hashOfConfig":"12"},{"size":111,"mtime":1661080761641,"results":"21","hashOfConfig":"12"},{"filePath":"22","messages":"23","suppressedMessages":"24","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"13dspl9",{"filePath":"25","messages":"26","suppressedMessages":"27","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"28","messages":"29","suppressedMessages":"30","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"31","messages":"32","suppressedMessages":"33","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"34","messages":"35","suppressedMessages":"36","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"37","messages":"38","suppressedMessages":"39","errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"40"},{"filePath":"41","messages":"42","suppressedMessages":"43","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"44","messages":"45","suppressedMessages":"46","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"47"},{"filePath":"48","messages":"49","suppressedMessages":"50","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"51"},{"filePath":"52","messages":"53","suppressedMessages":"54","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/home/xkruzel/Desktop/todo/reactapp/src/index.js",[],[],"/home/xkruzel/Desktop/todo/reactapp/src/App.js",[],[],"/home/xkruzel/Desktop/todo/reactapp/src/reportWebVitals.js",[],[],"/home/xkruzel/Desktop/todo/reactapp/src/StateApp.ts",[],[],"/home/xkruzel/Desktop/todo/reactapp/src/LoadJson.jsx",[],[],"/home/xkruzel/Desktop/todo/reactapp/src/Visualise.jsx",["55","56","57","58","59","60","61"],[],"import React from 'react';\nimport ReactDOM from 'react-dom'\nimport { init3Dgraphics } from './rendering.js';\nimport { StateApp } from './StateApp.ts'\n\nfunction getWindowSize() {\n    const {innerWidth, innerHeight} = window;\n    \n    return {innerWidth, innerHeight};\n}\n\n\nexport default class Visualise extends React.Component {\n    state = {\n        value : this.props.value || StateApp.Visualise,\n\n    };\n\n    handleBackButton = event => {\n        window.location.reload(false);\n    };\n\n\n    render() {\n        const fileData = this.props.fileData;\n\n        if (fileData === undefined || fileData.length === 0) {\n            return (\n                <div>\n                    <h3>There are no data available</h3>\n                    <p>Please got back to menu and try again</p>\n                    <input type=\"submit\" value=\"Back\" onClick={this.handleBackButton} />\n                </div>\n            );\n        }\n\n        if (!this.state.canvases_rendered) {\n\n            const window_sizes = getWindowSize();\n\n            const canvas_number = Object.keys(fileData).length;\n\n            var canvases = [];\n\n            var index = 0;\n            console.log(\"filedata \", fileData);\n\n            var both_semantics = false;\n            if (fileData[0]['sync'] !== undefined && fileData[0]['async'] !== undefined) {\n                both_semantics = true;\n            }\n\n            console.log(\"both \", both_semantics);\n\n            if (both_semantics) {\n                for (var key in fileData) {\n\n                    for (var sem in fileData[key]) {\n                        if (sem === 'Lines') {\n                            continue\n                        }\n\n                        var width = window_sizes.innerWidth;\n                        var height =  window_sizes.innerHeight;\n                        if (canvas_number > 1) {\n\n                            const division = Math.floor(canvas_number/2);\n                            if (division <= 1) {\n                                height = window_sizes.innerHeight;\n                            } else {\n                                height =  Math.floor(window_sizes.innerHeight/2);\n                            }\n                            width = Math.floor(window_sizes.innerWidth / (division + 1));\n                        }\n\n                        canvases.push(React.createElement('canvas', { id : \"canvas\" + index, width: width, height: height, class: \"col\" }));\n\n                        index += 1;\n                    }\n                };\n\n            } else {\n                for (var key in fileData) {\n\n                    for (var sem in fileData[key]) {\n                        if (sem === 'Lines') {\n                            continue\n                        }\n\n\n                        var width = window_sizes.innerWidth;\n                        var height =  window_sizes.innerHeight;\n                        if (canvas_number > 1) {\n\n                            const division = Math.floor(canvas_number/2);\n                            if (division <= 1) {\n                                height = window_sizes.innerHeight;\n                            } else {\n                                height =  Math.floor(window_sizes.innerHeight/2);\n                            }\n                            width = Math.floor(window_sizes.innerWidth / (division + 1));\n                        }\n\n                        canvases.push(React.createElement('canvas', { id : \"canvas\" + index, width: width, height: height, class: \"col\" }));\n                        index += 1;\n                    }\n                };\n            }\n\n            const div = React.createElement('div', { id : \"canvases_react\", class: \"row\" }, canvases);\n            ReactDOM.render(\n                div,\n                document.getElementById('canvases')\n            );\n            this.setState({ canvases_rendered : true });\n\n\n            return (<div>DDD</div>);\n        }\n\n        try {\n            var index = 0;\n            for (var key in fileData) {\n                for (var sem in fileData[key]) {\n                    if (sem === 'Lines') {\n                        continue\n                    }\n                    const data = fileData[key][sem];\n                    console.log(data);\n\n                    const canvas = document.getElementById(\"canvas\" + index);\n                    init3Dgraphics(canvas, data);\n\n                    index += 1;\n                }\n            };\n            \n        } catch (error) {\n            console.log(error)\n            return (\n                <div>\n                    <h3>Cannot visualize</h3>\n                    <input type=\"submit\" value=\"Back\" onClick={this.handleBackButton} />\n                </div>\n            );\n        }\n          \n\n        return (\n            <div>\n                <input type=\"submit\" value=\"Back\" onClick={this.handleBackButton} />\n            </div>\n        );\n    }\n}\n \n//export default Visualise;","/home/xkruzel/Desktop/todo/reactapp/src/Create.jsx",[],[],"/home/xkruzel/Desktop/todo/reactapp/src/LoadAeon.jsx",["62","63"],[],"import React from 'react';\nimport App from './App';\nimport { StateApp } from './StateApp.ts';\nimport Visualise from './Visualise';\nimport axios from \"axios\";\n\nlet param_arguments = {};\nlet param_lines = {};\n\nfunction get_select_fun(fun, name) {\n  return (\n    <select name={name} id={name} onClick={fun}>\n      <option value=\"&\"> & </option>\n      <option value=\"|\"> | </option>\n      <option value=\"->\"> -&gt; </option>\n      <option value=\"<=>\"> &lt;=&gt; </option>\n    </select>\n  );\n}\n\nfunction choose_parametrization(fun, args, regulations, nodes, name) {\n  var result = [];\n  args.forEach(function (arg, index) {\n    if (result.length > 0) {\n      result.push(get_select_fun(fun, name + \"_\" + index))\n    }\n\n    if (regulations[nodes[name]][nodes[arg]] === '-') {\n      result.push('!')\n    }\n\n    result.push(arg)\n  });\n\n  return result.map(arg => { return arg; });\n}\n\nexport default class LoadAeon extends React.Component {\n    state = {\n        value : this.props.value || StateApp.LoadAeon,\n        selectedFile: null,\n\n        option: null,\n\n        json_data:null,\n        checked_nodes : [],\n\n        parsed_nodes_keys: null,\n        nodes: null,\n\n        compute: false,\n        clusters: null,\n        asked : false,\n\n        param_arguments: {},\n\n        param_count : 1,\n    };\n  //  const [param_arguments, set_param_arguments] = useState();\n\n    onFileChange = event => {\n        // Update the state\n        this.setState({ selectedFile: event.target.files[0] });\n    };\n\n    handleParams = (event) => {\n      const id_arr = event.currentTarget.id.split('_');\n      const name = id_arr[0];\n      const index = id_arr[1];\n\n      const element = event.target;\n      const parent_id = element.closest(\"ul\").getAttribute(\"id\").split('_');\n\n      param_arguments[parent_id[1]][name][index - 1] = \"|\"; // TODO spravny operator\n    };\n\n    // On file upload (click the upload button)\n    onFileUpload = () => {\n          const file = this.state.selectedFile;\n  \n          var reader = new FileReader();\n          reader.readAsText(file,'UTF-8');\n       \n          reader.addEventListener(\"load\", () => {\n              var r = reader.result;\n\n              var r_lines = r.split(\"\\n\");\n              const regex_comment = /^\\s*#/;\n              var result_data = [];\n              for (let i = 0; i < r_lines.length; i++) {\n                if (r_lines[i].match(regex_comment)) {\n                  continue;\n                }\n                result_data.push(r_lines[i]);\n              }\n\n              this.setState({ file_read : result_data });\n              const result_data_joined = result_data.join(\" %% \");\n              document.cookie=\"resultData=\" + result_data_joined + \"; SameSite=None; Secure\";\n          });\n\n        this.setState({ value : StateApp.Config });\n      };\n  \n\n    fileData = () => {    \n        if (this.state.selectedFile) {\n           \n          return (\n            <div>\n              <h2>File Details:</h2>\n               \n                <p>File Name: {this.state.selectedFile.name}</p>\n                <p>File Type: {this.state.selectedFile.type}</p>\n   \n            </div>\n          );\n        } else {\n          return (\n            <div>\n              <br />\n              <h4>Choose before Pressing the Upload button</h4>\n            </div>\n          );\n        }\n    };\n\n    handleBackButton = event => {\n      this.setState({ value : StateApp.MainApp });\n    };\n\n    handleSemanticsButton = event => {\n      event.preventDefault();\n      if (!this.state.sync && !this.state.async) {\n        // TODO chyba aspon jedno musi byt\n        return;\n      }\n      this.setState({ option : this.state.node ? 1 : 2 });\n    };\n\n    handleNodesButton = event => {\n      event.preventDefault();\n      this.render();\n\n      this.setState({ compute : true });\n\n      if (this.state.params !== undefined) {\n        for (var c = 0; c < this.state.param_count; ++c) {\n          this.state.params.forEach((value, key) => {\n            \n            var args_concat = '';\n            var args = value[\"args\"].split(',');\n            for (var i = 0; i < args.length; ++i) {\n              if (args_concat.length > 0) {\n                args_concat += \" \" + param_arguments[c][key][ i - 1 ] + \" \";\n              }\n              args_concat += args[i];\n            }\n\n            const expresion_arr = value[\"expr\"].split(\"___parametrization___\");\n            var expr_snd = '';\n            if (expresion_arr.length > 1) {\n              expr_snd = expresion_arr[1];\n            }\n\n            if (param_lines[c] === undefined) {\n              param_lines[c] = []\n            }\n\n            param_lines[c].push( \"$\" + key + \" : \" + expresion_arr[0] + \" \" + args_concat + \" \" + expr_snd);\n          });\n\n        }\n      }\n    };\n\n    handleOnChange = (event, name) => {\n      var checked = this.state.checked_nodes;\n\n      if (event.target.checked) {\n        checked.push(name);\n      } else {\n        checked = checked.filter(function(value) {\n          return value === name;\n        });\n      }\n      this.setState({ checked_nodes: checked });\n    };\n\n    handleNoSave = () => {\n      this.setState({ asked : true });\n    }\n\n    handleSave = () => {\n      const element = document.createElement(\"a\");\n\n      const file = new Blob([this.state.clusters],\n        {\n          type:\"text/plain;charset=utf-8\"\n        });\n\n      element.href = URL.createObjectURL(file);\n      element.download = \"data.json\";\n      document.body.appendChild(element);\n      element.click();\n\n      this.setState({ asked : true });\n    }\n\n    addParam = (event) => {\n      event.preventDefault();\n      this.setState({ param_count : this.state.param_count + 1 });\n    }\n\n\n    render() {\n        if (this.state.value === StateApp.MainApp) {\n          return <App />;\n        }\n\n        if (this.state.value === StateApp.Visualise) {\n\n          // Ask to save data\n          const clusters_parsed = JSON.parse(this.state.clusters);\n\n          if (this.state.asked === true) {\n            console.log(\"to visualise \", clusters_parsed);\n            return <Visualise fileData={clusters_parsed} />;\n          }\n          return (\n            <div>\n              <h3>Do you want to save json file before visualisation?</h3>\n              <br/>\n              <button onClick={this.handleSave}>Yes</button>\n              <button onClick={this.handleNoSave}>No, only visualise</button>\n\n            </div>\n          );\n        }  \n        \n        if (this.state.value === StateApp.Config) {\n\n          if (this.state.option === null) {\n            return (\n            <form>\n              <input type=\"checkbox\" id=\"async\" name=\"semantics\" value=\"1\" onChange={event => this.setState({async : true})}/>\n              <label for=\"async\">Async</label>\n              <input type=\"checkbox\" id=\"sync\" name=\"semantics\" value=\"2\" onChange={event => this.setState({sync : true})}/>\n              <label for=\"sync\">Sync</label>\n              <br/>\n              <input type=\"radio\" id=\"node\" name=\"option\" value=\"1\" onChange={event => this.setState({node : true, whole: false})}/>\n              <label for=\"node\">from one node</label>\n              <input type=\"radio\" id=\"whole\" name=\"option\" value=\"2\" onChange={event => this.setState({whole : true, node: false})}/>\n              <label for=\"whole\">whole state space</label>\n              <input type=\"submit\" value=\"Send\" onClick={this.handleSemanticsButton} />\n            </form>);\n          }\n\n          if (this.state.option === 1 && !this.state.nodes) {\n              axios\n              .get(\"http://127.0.0.1:8000/get_nodes\")\n              .then(response => {\n                const result = JSON.parse(response.data);\n                this.setState({ nodes : result[\"nodes\"] });\n\n                if (result[\"parametrization\"] !== undefined) {\n                  this.setState({ params : new Map(Object.entries(result[\"parametrization\"])), reguls : result[\"regulations\"] });\n                }\n\n              });\n            return (\n                <h3>Getting nodes</h3>\n            );\n          }\n\n          if (this.state.option === 1 && this.state.nodes && this.state.compute === false) {\n            var parametrization_selection;\n            const counts = Array.from(Array(this.state.param_count).keys());\n\n            if (this.state.params !== undefined) {\n  \n              var lis = [];\n              this.state.params.forEach((value, name) => {\n                const args = value[\"args\"].split(',');\n                const choose_param = choose_parametrization(this.handleParams, args, this.state.reguls, this.state.nodes, name);\n  \n                const expresion_arr = value[\"expr\"].split(\"___parametrization___\");\n                var expr_snd = '';\n                if (expresion_arr.length > 1) {\n                  expr_snd = expresion_arr[1];\n                }\n\n                for (var c = 0; c < this.state.param_count; ++c) {\n                  if (param_arguments[c] === undefined) {\n                    param_arguments[c] = {}\n                  }\n                  if (param_arguments[c][name] === undefined) {\n                    param_arguments[c][name] = args.map( arg => \"&\" );\n                    param_arguments[c][name].pop();\n                  }\n                }\n  \n                lis.push(<li key={name}> {name}: {expresion_arr[0]}&nbsp;{choose_param}&nbsp;{expr_snd}</li>);\n              });\n\n\n\n  \n              parametrization_selection = <div className=\"App\">\n                                            <h3>Select parametrizations</h3>\n                                            <div class=\"row\">\n                                            {\n                                              counts.map(c => {\n                                                return (\n                                                <div class=\"col\">\n                                                  <ul id={'param_' + c}>\n                                                    {\n                                                      lis.map(li => {\n                                                        return li;\n                                                      }, this)\n                                                    }\n                                                  </ul>\n                                                </div>);\n                                              }, this)\n                                            }\n                                            \n                                            <button class=\"col\" onClick={this.addParam}> + </button>\n                                            </div>\n                                          </div>\n            }\n\n            if (!this.state.parsed_nodes_keys) {\n              const nodes_keys = Object.keys(this.state.nodes);\n              this.setState({parsed_nodes_keys : nodes_keys});\n            }\n\n            const nodes_selection = <div className=\"App\">\n                                      <h3>Select nodes</h3>\n                                        {this.state.parsed_nodes_keys.map(name => {\n                                          return (\n                                            <div>\n                                              <input\n                                                type=\"checkbox\"\n                                                id={`custom-checkbox-${name}`}\n                                                name={name}\n                                                value={name}\n                                                onChange={ (event) => { this.handleOnChange(event, name) }}\n                                              />\n                                              <label htmlFor={`custom-checkbox-${name}`}>{name}</label>\n                                            </div>\n                                          );\n                                        })}\n                                    </div>;\n\n            return (\n              <div>\n                <form>\n                  {nodes_selection}\n                  {parametrization_selection}\n                  <input type=\"submit\" value=\"Send\" onClick={this.handleNodesButton} />\n                </form>\n              </div>\n            );\n          }\n\n          if (this.state.compute) {\n            const result_data_joined = this.state.file_read.join(\" %% \");\n\n            document.cookie = \"resultData=\" + result_data_joined + \"; SameSite=None; Secure\";\n\n\n            const nodes = this.state.checked_nodes.join(',');\n            const params = \"semantics=\" \n                          + \"&option=\" + this.state.option\n                          + (nodes !== \"\" ? \"&nodes=\" + nodes : \"\")\n\n            var data_params = {\n              semantics: (this.state.async ? (this.state.sync ? \"async,sync\" : \"async\") : \"sync\"),\n              options: this.state.option,\n              nodes: nodes\n            }\n            \n            if (param_lines !== {}) {\n              const param_lines_json = JSON.stringify(param_lines);\n              data_params['params'] = param_lines_json;              \n            }\n\n            axios\n              .get(\"http://127.0.0.1:8000/get_data/\", { params: data_params })\n              .then(response => {\n                this.setState({ clusters : response.data });\n                this.setState({ value : StateApp.Visualise });\n                });\n            \n            return (\n            <div>\n              <h3>Sending request</h3>\n            </div>\n            );\n          }        \n          \n          return (\n            <div>\n              <h3>Waiting for computation</h3>\n            </div>\n          );\n          \n        }\n\n        return (\n            <div>\n                <h3>\n                  File Upload\n                </h3>\n                <div>\n                    <input type=\"file\" onChange={this.onFileChange} accept=\".aeon\"/>\n                    <button onClick={this.onFileUpload}>\n                      Process\n                    </button>\n                </div>\n              {this.fileData()}\n\n              <input type=\"submit\" value=\"Back\" onClick={this.handleBackButton} />\n            </div>\n          );\n    }\n}\n","/home/xkruzel/Desktop/todo/reactapp/src/rendering.js",["64","65","66","67","68"],[],"import * as THREE from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\nimport * as dat from 'dat.gui';\nimport { Point } from './Point';\n\n\nexport function init3Dgraphics(element, data) {\n\n  if (data === undefined) {\n    return false;\n  }\n\n  const CYLINDER_HEIGHT = 5;\n\n  const scene = new THREE.Scene();\n  //scene.background = new THREE.Color( 0xd3d3d3 );\n  scene.background = new THREE.Color( 0xffffff);\n  const camera = new THREE.PerspectiveCamera(75, element.width / element.height, 0.1, 1000)\n  const renderer = new THREE.WebGLRenderer({\n    canvas: element,\n  });\n\n  renderer.setPixelRatio( window.devicePixelRatio );\n  renderer.setSize(element.width, element.height); // full size\n  camera.position.setZ(30); // for better perspective\n  renderer.sortObjects = false;\n  renderer.render(scene, camera);\n\n  const axesHelper = new THREE.AxesHelper(100);\n  scene.add(axesHelper);\n\n  const gui = new dat.GUI();\n  const options = {\n    sphereColor : 0xffea00,\n    wireframe: false,\n  };\n    \n  const pointLight = new THREE.PointLight(0xffffff)\n  pointLight.position.set(20, 20, 20);\n\n  const ambientLight = new THREE.AmbientLight(0xffffff)\n  ambientLight.position.set(20, 20, 20);\n\n  scene.add(pointLight, ambientLight);\n\n  const lightHelper = new THREE.PointLightHelper(pointLight);  // shows position of lighsource\n  const gridHelper = new THREE.GridHelper(30, 20);\n\n  scene.add(lightHelper, gridHelper);\n\n  window.addEventListener('resize', function() {\n    camera.aspect = element.width / element.height;\n    camera.updateProjectionMatrix();\n    renderer.setSize(element.width);\n  });\n\n  const controls = new OrbitControls(camera, renderer.domElement);\n\n  // Returns a random integer from 0 to 9:\n  //const randomNum = Math.floor(Math.random() * 8); \n\n  processClusters(scene, data);\n  data = null;\n\n  function animate() {\n    setTimeout( function() {\n      requestAnimationFrame( animate );\n    }, 1000 / 5 );\n\n    controls.update();\n    renderer.render(scene, camera);\n  }\n\n  renderer.setAnimationLoop(animate);\n\n  window.addEventListener('resize', function() {\n    camera.aspect = element.width / element.width\n    camera.updateProjectionMatrix();\n    renderer.setSize(element.width, element.width);\n  });\n\n  function calcColor(max, val) {\n    return \"hsla(147, 0%, 50%, 1)\";\n    const min = 0\n    var minHue = 240, maxHue=0;\n    var curPercent = (val - min) / (max-min);\n    var colString = \"hsl(\" + ((curPercent * (maxHue-minHue) ) + minHue) + \",65%,50%)\";\n    return colString;\n  }\n\n  function createCylinder( data, id, startPoint, endPoint, currRadius, nextRadius, rank, rank_max, offset) {\n    const color = new THREE.Color( data[id]['color'] === undefined ? calcColor(rank_max, rank) : data[id]['color'] );\n    //color.setHex(rank/10 * 0xffffff );\n   // color.setHex(rank/10 * 0xffffff );\n\n\n    var cylinderMesh = function( startPoint, endPoint, midPoint, currRadius, nextRadius, color ) {\n      /* edge from X to Y */\n      const direction = new THREE.Vector3().subVectors( endPoint, startPoint );\n\n      const orientation = new THREE.Matrix4();\n      /* THREE.Object3D().up (=Y) default orientation for all objects */\n      orientation.lookAt(startPoint, endPoint, new THREE.Object3D().up);\n\n      /* rotation around axis X by -90 degrees \n      * matches the default orientation Y \n      * with the orientation of looking Z */\n      const mat =  new THREE.Matrix4();\n      mat.set(\n        1,0,0,0,\n        0,0,1,0, \n        0,-1,0,0,\n        0,0,0,1\n      );\n      orientation.multiply(mat);\n\n      /* cylinder: radiusAtTop, radiusAtBottom, \n          height, radiusSegments, heightSegments */\n      const edgeGeometry = new THREE.CylinderGeometry( nextRadius, currRadius, direction.length(), 8, 1);\n      const cylinder = new THREE.Mesh( edgeGeometry, \n              new THREE.MeshPhongMaterial( { color: color, flatShading : true } ) );\n\n      cylinder.applyMatrix4(orientation)\n      cylinder.position.set(midPoint.x, midPoint.y, midPoint.z);\n      return cylinder;\n    }\n\n    const midPoint = new Point((startPoint.x + endPoint.x) / 2, (startPoint.y + endPoint.y) / 2, (startPoint.z + endPoint.z) / 2);\n    return cylinderMesh(startPoint, endPoint, midPoint, currRadius, nextRadius, color); //new THREE.Mesh(geometryCyl, material);\n\n  }\n\n  // prevPoint, point - upper and downer middle points of cylinder\n  // dirPoint - point to which direction of cylinder (dir vector) should go \n  function clustering(scene, data, id, max_branching, branch_count, prevPointFirst, pointFirst, biggestRank) {\n\n    if (id === undefined) {\n      console.log(\"Id is undefined in clustering\");\n      return;\n    }\n\n    var tuple = Object.freeze({ id: id, prevPoint: prevPointFirst, point: pointFirst });\n    var stack = [ tuple ];\n \n    var count = 0\n\n    while (stack.length > 0) {\n      ++count;\n      const stackElement = stack.pop();\n      const current = stackElement.id;\n      const prevPoint = stackElement.prevPoint;\n      const point = stackElement.point;\n\n      console.log(current);\n\n      var cluster = data[current];\n      const childCount = cluster[\"Desc\"].length;\n\n      var childsChildCount = 0;\n      for (var i = 0; i < cluster[\"Desc\"].length; ++i) {\n        childsChildCount += data[cluster[\"Desc\"][i]][\"NodeCount\"];\n      }\n\n      var cylinder = createCylinder(data, current, prevPoint, point, cluster.NodeCount, childsChildCount, data[current][\"Rank\"], biggestRank);\n\n      const prevPointPointDist = Math.sqrt((point.x - prevPoint.x) * (point.x - prevPoint.x) + (point.y - prevPoint.y)\n                              * (point.y - prevPoint.y) + (point.z - prevPoint.z) * (point.z - prevPoint.z));\n\n      for (i = 0; i < childCount; ++i) {\n\n        if (childCount === 1) {\n\n            var newStartPoint = new Point(point.x, point.y, point.z); // to make copy\n\n            var offset = 0;\n            if (childsChildCount === cluster[\"Desc\"].length && childsChildCount !== 0 && data[cluster[\"Desc\"][0]][\"Desc\"].length !== 0) {\n              cylinder = undefined; // join same-like cluster to one - draw one cluster with bigger height\n              newStartPoint = new Point(prevPoint.x, prevPoint.y, prevPoint.z); // to make copy\n            }\n\n            const dirVector = new THREE.Vector3(point.x - prevPoint.x, point.y - prevPoint.y, point.z - prevPoint.z);\n            const newPoint = new Point(dirVector.x + point.x, dirVector.y + point.y, dirVector.z + point.z);\n\n            tuple = Object.freeze({ id: cluster[\"Desc\"][0], prevPoint: newStartPoint, point: newPoint });\n            stack.push(tuple);\n          \n          continue;\n        }\n\n        // COMPUTE NEW COORDINATES around circle\n        const theta = 2 * Math.PI / childCount * i;\n\n        var xPos = Math.cos(theta) * childsChildCount;\n        var zPos = Math.sin(theta) * childsChildCount;\n        // this point is not exactly matching with rotation line\n        // it is used to compute vector and later in correct newStartPoint\n        const newStartPointHelper = new Point(point.x + xPos, point.y, point.z + zPos);\n\n        const vector = new THREE.Vector3(newStartPointHelper.x - prevPoint.x, newStartPointHelper.y - prevPoint.y, newStartPointHelper.z - prevPoint.z).normalize();\n        const distance = Math.sqrt(cluster.NodeCount * cluster.NodeCount + prevPointPointDist * prevPointPointDist);\n        newStartPoint = new Point(\n          prevPoint.x + distance * vector.x,\n          prevPoint.y + distance * vector.y,\n          prevPoint.z + distance * vector.z,\n        );\n      \n        const branch_factor = 2 - (1/max_branching * branch_count);\n        xPos = Math.cos(theta) * childsChildCount * branch_factor; // TODO pronasobit constantov pro urceni mensiho/vetsiho uhlu - v ramci hlbky stromu? \n        zPos = Math.sin(theta) * childsChildCount * branch_factor; // TODO\n        const newEndPoint = new Point(newStartPoint.x + xPos, newStartPoint.y - CYLINDER_HEIGHT, newStartPoint.z + zPos);\n      \n        tuple = Object.freeze({ id: cluster[\"Desc\"][i], prevPoint: newStartPoint, point: newEndPoint });\n        stack.push(tuple);\n      }\n\n      if (cylinder !== undefined) {\n        scene.add(cylinder);\n      }\n\n    }\n  }\n\n  function getIntersection(setA, setB) {\n    const intersection = new Set(\n      [...setA].filter(element => setB.has(element))\n    );\n  \n    return intersection;\n  }\n\n  function _getSCCset(node, data, childs) {\n    var result = new Set();\n\n    var queue = [node]\n    while (queue.length > 0) {\n      var curr_node = queue.shift();\n      result.add(curr_node);\n\n      for (var i = 0; i < data[curr_node][childs].length; ++i) {\n        queue.push(data[curr_node][childs][i]);\n      }\n    }\n    return result;\n  }\n\n  function isStability(scc) {\n    return scc.length === 1;\n  }\n\n  function isOscillation(scc, data) {\n    scc.forEach((item) => {\n      if (data[item][\"NodeCount\"] !== 1 || data[item][\"Desc\"].length !== 1) {  // TODO overit\n        return false;\n      }\n    });\n    return true;\n  }\n\n  function compSCCcolor(node, data) {\n\n    const normal = _getSCCset(node, data, 'Desc');\n    const reverted = _getSCCset(node, data, 'Backs');\n\n    const scc = Array.from(getIntersection(normal, reverted));\n\n    var color = \"hsla(187, 90%, 50%, 0.53)\";\n    if (isOscillation(scc, data)) {\n      color = \"hsla(100, 90%, 50%, 0.53)\";\n    }\n    if (isStability(scc)) {\n      color = \"hsla(295, 90%, 50%, 0.37)\";\n    }\n\n    scc.forEach((item) => {\n      data[item]['color'] = color;\n    });\n  }\n\n  function compMaxBranching(data, key) {\n\n    let stack = [ key ];\n    var maximums = {}\n    var colors = {}\n\n    while (stack.length > 0) {\n      const current = stack.pop();\n      colors[current] = 'G';\n      stack.push(current);\n      \n      if (maximums[current] === undefined) {\n        maximums[current] = 0\n      }\n\n      var count_black = 0;\n      const desc_count = data[current][\"Desc\"].length;\n      for (var i = 0; i < desc_count; ++i) {\n        if (colors[data[current][\"Desc\"][i]] === undefined) {\n          stack.push(data[current][\"Desc\"][i]);\n        } \n\n        if (colors[data[current][\"Desc\"][i]] === 'B') {\n          count_black += 1;\n          maximums[current] = Math.max(maximums[ data[current][\"Desc\"][i] ], maximums[current]);\n        }\n      }\n\n      if (count_black === desc_count) {\n        colors[current] = 'B';\n        stack.pop();\n\n        if (desc_count > 1) {\n          maximums[current] += 1;\n        }\n      }\n\n      // Predpocitat obratenu siet, pustit BFS na check SCC\n      if (desc_count === 0) {\n        compSCCcolor(current, data)\n      }\n    }\n\n    return maximums[key];\n  }\n\n  function processClusters(scene, data) {\n\n    var root_cluster_key = undefined;\n    var maxCluster = 1;\n    var biggestRank = 0;\n    Object.entries(data).forEach(([k,v]) => {\n      if (v[\"Rank\"] === 0) {\n        root_cluster_key = k;\n      }\n      biggestRank = Math.max(v[\"Rank\"], biggestRank);\n      maxCluster = Math.max(maxCluster, v.NodeCount);\n    });\n\n    const max_branching = compMaxBranching(data, root_cluster_key);\n\n    //var cylinders = {};\n\n    const firstHeight = biggestRank * CYLINDER_HEIGHT / 2 + CYLINDER_HEIGHT;\n    const firstStartPoint = new Point(0, firstHeight, 0);\n    const firstEndPoint = new Point(0, firstHeight - CYLINDER_HEIGHT, 0);\n\n    clustering(scene, data, root_cluster_key, max_branching, 1, firstStartPoint, firstEndPoint, biggestRank);\n\n    /*\n    gui.addColor(options, 'sphereColor').onChange(function(e) {\n\n      for (const [key, cylinder] of Object.entries(cylinders)) {\n        cylinder.material.color.set(e);\n      }\n    });\n    \n      gui.add(options, 'wireframe').onChange(function(e) {\n        cylinders.forEach(function(cylinder) {\n          cylinder.material.wireframe = e;\n        });\n      });\n    */\n  }\n}\n\n\n\n","/home/xkruzel/Desktop/todo/reactapp/src/Point.js",[],[],{"ruleId":"69","severity":1,"message":"70","line":83,"column":26,"nodeType":"71","messageId":"72","endLine":83,"endColumn":29},{"ruleId":"69","severity":1,"message":"73","line":85,"column":30,"nodeType":"71","messageId":"72","endLine":85,"endColumn":33},{"ruleId":"69","severity":1,"message":"74","line":91,"column":29,"nodeType":"71","messageId":"72","endLine":91,"endColumn":34},{"ruleId":"69","severity":1,"message":"75","line":92,"column":29,"nodeType":"71","messageId":"72","endLine":92,"endColumn":35},{"ruleId":"69","severity":1,"message":"76","line":122,"column":17,"nodeType":"71","messageId":"72","endLine":122,"endColumn":22},{"ruleId":"69","severity":1,"message":"70","line":123,"column":22,"nodeType":"71","messageId":"72","endLine":123,"endColumn":25},{"ruleId":"69","severity":1,"message":"73","line":124,"column":26,"nodeType":"71","messageId":"72","endLine":124,"endColumn":29},{"ruleId":"77","severity":1,"message":"78","line":149,"column":37,"nodeType":"79","messageId":"80","endLine":171,"endColumn":12},{"ruleId":"81","severity":1,"message":"82","line":373,"column":19,"nodeType":"71","messageId":"83","endLine":373,"endColumn":25},{"ruleId":"81","severity":1,"message":"84","line":32,"column":9,"nodeType":"71","messageId":"83","endLine":32,"endColumn":12},{"ruleId":"81","severity":1,"message":"85","line":33,"column":9,"nodeType":"71","messageId":"83","endLine":33,"endColumn":16},{"ruleId":"86","severity":1,"message":"87","line":84,"column":5,"nodeType":"88","messageId":"89","endLine":88,"endColumn":22},{"ruleId":"81","severity":1,"message":"90","line":148,"column":9,"nodeType":"71","messageId":"83","endLine":148,"endColumn":14},{"ruleId":"81","severity":1,"message":"91","line":175,"column":17,"nodeType":"71","messageId":"83","endLine":175,"endColumn":23},"no-redeclare","'key' is already defined.","Identifier","redeclared","'sem' is already defined.","'width' is already defined.","'height' is already defined.","'index' is already defined.","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'c', 'c', 'c', 'c'.","ArrowFunctionExpression","unsafeRefs","no-unused-vars","'params' is assigned a value but never used.","unusedVar","'gui' is assigned a value but never used.","'options' is assigned a value but never used.","no-unreachable","Unreachable code.","VariableDeclaration","unreachableCode","'count' is assigned a value but never used.","'offset' is assigned a value but never used."]