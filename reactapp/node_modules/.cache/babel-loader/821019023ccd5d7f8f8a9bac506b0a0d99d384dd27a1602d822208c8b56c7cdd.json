{"ast":null,"code":"import _classCallCheck from \"/home/xkruzel/Desktop/todo/reactapp/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/xkruzel/Desktop/todo/reactapp/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Color, DoubleSide, Matrix4, MeshBasicMaterial } from 'three';\n\n/**\n * https://github.com/gkjohnson/collada-exporter-js\n *\n * Usage:\n *  const exporter = new ColladaExporter();\n *\n *  const data = exporter.parse(mesh);\n *\n * Format Definition:\n *  https://www.khronos.org/collada/\n */\nvar ColladaExporter = /*#__PURE__*/function () {\n  function ColladaExporter() {\n    _classCallCheck(this, ColladaExporter);\n  }\n  _createClass(ColladaExporter, [{\n    key: \"parse\",\n    value: function parse(object, onDone) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      options = Object.assign({\n        version: '1.4.1',\n        author: null,\n        textureDirectory: '',\n        upAxis: 'Y_UP',\n        unitName: null,\n        unitMeter: null\n      }, options);\n      if (options.upAxis.match(/^[XYZ]_UP$/) === null) {\n        console.error('ColladaExporter: Invalid upAxis: valid values are X_UP, Y_UP or Z_UP.');\n        return null;\n      }\n      if (options.unitName !== null && options.unitMeter === null) {\n        console.error('ColladaExporter: unitMeter needs to be specified if unitName is specified.');\n        return null;\n      }\n      if (options.unitMeter !== null && options.unitName === null) {\n        console.error('ColladaExporter: unitName needs to be specified if unitMeter is specified.');\n        return null;\n      }\n      if (options.textureDirectory !== '') {\n        options.textureDirectory = \"\".concat(options.textureDirectory, \"/\").replace(/\\\\/g, '/').replace(/\\/+/g, '/');\n      }\n      var version = options.version;\n      if (version !== '1.4.1' && version !== '1.5.0') {\n        console.warn(\"ColladaExporter : Version \".concat(version, \" not supported for export. Only 1.4.1 and 1.5.0.\"));\n        return null;\n      }\n\n      // Convert the urdf xml into a well-formatted, indented format\n      function format(urdf) {\n        var IS_END_TAG = /^<\\//;\n        var IS_SELF_CLOSING = /(\\?>$)|(\\/>$)/;\n        var HAS_TEXT = /<[^>]+>[^<]*<\\/[^<]+>/;\n        var pad = function pad(ch, num) {\n          return num > 0 ? ch + pad(ch, num - 1) : '';\n        };\n        var tagnum = 0;\n        return urdf.match(/(<[^>]+>[^<]+<\\/[^<]+>)|(<[^>]+>)/g).map(function (tag) {\n          if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && IS_END_TAG.test(tag)) {\n            tagnum--;\n          }\n          var res = \"\".concat(pad('  ', tagnum)).concat(tag);\n          if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && !IS_END_TAG.test(tag)) {\n            tagnum++;\n          }\n          return res;\n        }).join('\\n');\n      }\n\n      // Convert an image into a png format for saving\n      function base64ToBuffer(str) {\n        var b = atob(str);\n        var buf = new Uint8Array(b.length);\n        for (var i = 0, l = buf.length; i < l; i++) {\n          buf[i] = b.charCodeAt(i);\n        }\n        return buf;\n      }\n      var canvas, ctx;\n      function imageToData(image, ext) {\n        canvas = canvas || document.createElement('canvas');\n        ctx = ctx || canvas.getContext('2d');\n        canvas.width = image.width;\n        canvas.height = image.height;\n        ctx.drawImage(image, 0, 0);\n\n        // Get the base64 encoded data\n        var base64data = canvas.toDataURL(\"image/\".concat(ext), 1).replace(/^data:image\\/(png|jpg);base64,/, '');\n\n        // Convert to a uint8 array\n        return base64ToBuffer(base64data);\n      }\n\n      // gets the attribute array. Generate a new array if the attribute is interleaved\n      var getFuncs = ['getX', 'getY', 'getZ', 'getW'];\n      var tempColor = new Color();\n      function attrBufferToArray(attr) {\n        var isColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        if (isColor) {\n          // convert the colors to srgb before export\n          // colors are always written as floats\n          var arr = new Float32Array(attr.count * 3);\n          for (var i = 0, l = attr.count; i < l; i++) {\n            tempColor.fromBufferAttribute(attr, i).convertLinearToSRGB();\n            arr[3 * i + 0] = tempColor.r;\n            arr[3 * i + 1] = tempColor.g;\n            arr[3 * i + 2] = tempColor.b;\n          }\n          return arr;\n        } else if (attr.isInterleavedBufferAttribute) {\n          // use the typed array constructor to save on memory\n          var _arr = new attr.array.constructor(attr.count * attr.itemSize);\n          var size = attr.itemSize;\n          for (var _i = 0, _l = attr.count; _i < _l; _i++) {\n            for (var j = 0; j < size; j++) {\n              _arr[_i * size + j] = attr[getFuncs[j]](_i);\n            }\n          }\n          return _arr;\n        } else {\n          return attr.array;\n        }\n      }\n\n      // Returns an array of the same type starting at the `st` index,\n      // and `ct` length\n      function subArray(arr, st, ct) {\n        if (Array.isArray(arr)) return arr.slice(st, st + ct);else return new arr.constructor(arr.buffer, st * arr.BYTES_PER_ELEMENT, ct);\n      }\n\n      // Returns the string for a geometry's attribute\n      function getAttribute(attr, name, params, type) {\n        var isColor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n        var array = attrBufferToArray(attr, isColor);\n        var res = \"<source id=\\\"\".concat(name, \"\\\">\") + \"<float_array id=\\\"\".concat(name, \"-array\\\" count=\\\"\").concat(array.length, \"\\\">\") + array.join(' ') + '</float_array>' + '<technique_common>' + \"<accessor source=\\\"#\".concat(name, \"-array\\\" count=\\\"\").concat(Math.floor(array.length / attr.itemSize), \"\\\" stride=\\\"\").concat(attr.itemSize, \"\\\">\") + params.map(function (n) {\n          return \"<param name=\\\"\".concat(n, \"\\\" type=\\\"\").concat(type, \"\\\" />\");\n        }).join('') + '</accessor>' + '</technique_common>' + '</source>';\n        return res;\n      }\n\n      // Returns the string for a node's transform information\n      var transMat;\n      function getTransform(o) {\n        // ensure the object's matrix is up to date\n        // before saving the transform\n        o.updateMatrix();\n        transMat = transMat || new Matrix4();\n        transMat.copy(o.matrix);\n        transMat.transpose();\n        return \"<matrix>\".concat(transMat.toArray().join(' '), \"</matrix>\");\n      }\n\n      // Process the given piece of geometry into the geometry library\n      // Returns the mesh id\n      function processGeometry(g) {\n        var info = geometryInfo.get(g);\n        if (!info) {\n          // convert the geometry to bufferGeometry if it isn't already\n          var bufferGeometry = g;\n          if (bufferGeometry.isBufferGeometry !== true) {\n            throw new Error('THREE.ColladaExporter: Geometry is not of type THREE.BufferGeometry.');\n          }\n          var meshid = \"Mesh\".concat(libraryGeometries.length + 1);\n          var indexCount = bufferGeometry.index ? bufferGeometry.index.count * bufferGeometry.index.itemSize : bufferGeometry.attributes.position.count;\n          var groups = bufferGeometry.groups != null && bufferGeometry.groups.length !== 0 ? bufferGeometry.groups : [{\n            start: 0,\n            count: indexCount,\n            materialIndex: 0\n          }];\n          var gname = g.name ? \" name=\\\"\".concat(g.name, \"\\\"\") : '';\n          var gnode = \"<geometry id=\\\"\".concat(meshid, \"\\\"\").concat(gname, \"><mesh>\");\n\n          // define the geometry node and the vertices for the geometry\n          var posName = \"\".concat(meshid, \"-position\");\n          var vertName = \"\".concat(meshid, \"-vertices\");\n          gnode += getAttribute(bufferGeometry.attributes.position, posName, ['X', 'Y', 'Z'], 'float');\n          gnode += \"<vertices id=\\\"\".concat(vertName, \"\\\"><input semantic=\\\"POSITION\\\" source=\\\"#\").concat(posName, \"\\\" /></vertices>\");\n\n          // NOTE: We're not optimizing the attribute arrays here, so they're all the same length and\n          // can therefore share the same triangle indices. However, MeshLab seems to have trouble opening\n          // models with attributes that share an offset.\n          // MeshLab Bug#424: https://sourceforge.net/p/meshlab/bugs/424/\n\n          // serialize normals\n          var triangleInputs = \"<input semantic=\\\"VERTEX\\\" source=\\\"#\".concat(vertName, \"\\\" offset=\\\"0\\\" />\");\n          if ('normal' in bufferGeometry.attributes) {\n            var normName = \"\".concat(meshid, \"-normal\");\n            gnode += getAttribute(bufferGeometry.attributes.normal, normName, ['X', 'Y', 'Z'], 'float');\n            triangleInputs += \"<input semantic=\\\"NORMAL\\\" source=\\\"#\".concat(normName, \"\\\" offset=\\\"0\\\" />\");\n          }\n\n          // serialize uvs\n          if ('uv' in bufferGeometry.attributes) {\n            var uvName = \"\".concat(meshid, \"-texcoord\");\n            gnode += getAttribute(bufferGeometry.attributes.uv, uvName, ['S', 'T'], 'float');\n            triangleInputs += \"<input semantic=\\\"TEXCOORD\\\" source=\\\"#\".concat(uvName, \"\\\" offset=\\\"0\\\" set=\\\"0\\\" />\");\n          }\n\n          // serialize lightmap uvs\n          if ('uv2' in bufferGeometry.attributes) {\n            var _uvName = \"\".concat(meshid, \"-texcoord2\");\n            gnode += getAttribute(bufferGeometry.attributes.uv2, _uvName, ['S', 'T'], 'float');\n            triangleInputs += \"<input semantic=\\\"TEXCOORD\\\" source=\\\"#\".concat(_uvName, \"\\\" offset=\\\"0\\\" set=\\\"1\\\" />\");\n          }\n\n          // serialize colors\n          if ('color' in bufferGeometry.attributes) {\n            // colors are always written as floats\n            var colName = \"\".concat(meshid, \"-color\");\n            gnode += getAttribute(bufferGeometry.attributes.color, colName, ['R', 'G', 'B'], 'float', true);\n            triangleInputs += \"<input semantic=\\\"COLOR\\\" source=\\\"#\".concat(colName, \"\\\" offset=\\\"0\\\" />\");\n          }\n          var indexArray = null;\n          if (bufferGeometry.index) {\n            indexArray = attrBufferToArray(bufferGeometry.index);\n          } else {\n            indexArray = new Array(indexCount);\n            for (var i = 0, l = indexArray.length; i < l; i++) {\n              indexArray[i] = i;\n            }\n          }\n          for (var _i2 = 0, _l2 = groups.length; _i2 < _l2; _i2++) {\n            var group = groups[_i2];\n            var subarr = subArray(indexArray, group.start, group.count);\n            var polycount = subarr.length / 3;\n            gnode += \"<triangles material=\\\"MESH_MATERIAL_\".concat(group.materialIndex, \"\\\" count=\\\"\").concat(polycount, \"\\\">\");\n            gnode += triangleInputs;\n            gnode += \"<p>\".concat(subarr.join(' '), \"</p>\");\n            gnode += '</triangles>';\n          }\n          gnode += '</mesh></geometry>';\n          libraryGeometries.push(gnode);\n          info = {\n            meshid: meshid,\n            bufferGeometry: bufferGeometry\n          };\n          geometryInfo.set(g, info);\n        }\n        return info;\n      }\n\n      // Process the given texture into the image library\n      // Returns the image library\n      function processTexture(tex) {\n        var texid = imageMap.get(tex);\n        if (texid == null) {\n          texid = \"image-\".concat(libraryImages.length + 1);\n          var ext = 'png';\n          var name = tex.name || texid;\n          var imageNode = \"<image id=\\\"\".concat(texid, \"\\\" name=\\\"\").concat(name, \"\\\">\");\n          if (version === '1.5.0') {\n            imageNode += \"<init_from><ref>\".concat(options.textureDirectory).concat(name, \".\").concat(ext, \"</ref></init_from>\");\n          } else {\n            // version image node 1.4.1\n            imageNode += \"<init_from>\".concat(options.textureDirectory).concat(name, \".\").concat(ext, \"</init_from>\");\n          }\n          imageNode += '</image>';\n          libraryImages.push(imageNode);\n          imageMap.set(tex, texid);\n          textures.push({\n            directory: options.textureDirectory,\n            name: name,\n            ext: ext,\n            data: imageToData(tex.image, ext),\n            original: tex\n          });\n        }\n        return texid;\n      }\n\n      // Process the given material into the material and effect libraries\n      // Returns the material id\n      function processMaterial(m) {\n        var matid = materialMap.get(m);\n        if (matid == null) {\n          matid = \"Mat\".concat(libraryEffects.length + 1);\n          var type = 'phong';\n          if (m.isMeshLambertMaterial === true) {\n            type = 'lambert';\n          } else if (m.isMeshBasicMaterial === true) {\n            type = 'constant';\n            if (m.map !== null) {\n              // The Collada spec does not support diffuse texture maps with the\n              // constant shader type.\n              // mrdoob/three.js#15469\n              console.warn('ColladaExporter: Texture maps not supported with MeshBasicMaterial.');\n            }\n          }\n          var emissive = m.emissive ? m.emissive : new Color(0, 0, 0);\n          var diffuse = m.color ? m.color : new Color(0, 0, 0);\n          var specular = m.specular ? m.specular : new Color(1, 1, 1);\n          var shininess = m.shininess || 0;\n          var reflectivity = m.reflectivity || 0;\n          emissive.convertLinearToSRGB();\n          specular.convertLinearToSRGB();\n          diffuse.convertLinearToSRGB();\n\n          // Do not export and alpha map for the reasons mentioned in issue (#13792)\n          // in three.js alpha maps are black and white, but collada expects the alpha\n          // channel to specify the transparency\n          var transparencyNode = '';\n          if (m.transparent === true) {\n            transparencyNode += '<transparent>' + (m.map ? '<texture texture=\"diffuse-sampler\"></texture>' : '<float>1</float>') + '</transparent>';\n            if (m.opacity < 1) {\n              transparencyNode += \"<transparency><float>\".concat(m.opacity, \"</float></transparency>\");\n            }\n          }\n          var techniqueNode = \"<technique sid=\\\"common\\\"><\".concat(type, \">\") + '<emission>' + (m.emissiveMap ? '<texture texture=\"emissive-sampler\" texcoord=\"TEXCOORD\" />' : \"<color sid=\\\"emission\\\">\".concat(emissive.r, \" \").concat(emissive.g, \" \").concat(emissive.b, \" 1</color>\")) + '</emission>' + (type !== 'constant' ? '<diffuse>' + (m.map ? '<texture texture=\"diffuse-sampler\" texcoord=\"TEXCOORD\" />' : \"<color sid=\\\"diffuse\\\">\".concat(diffuse.r, \" \").concat(diffuse.g, \" \").concat(diffuse.b, \" 1</color>\")) + '</diffuse>' : '') + (type !== 'constant' ? '<bump>' + (m.normalMap ? '<texture texture=\"bump-sampler\" texcoord=\"TEXCOORD\" />' : '') + '</bump>' : '') + (type === 'phong' ? \"<specular><color sid=\\\"specular\\\">\".concat(specular.r, \" \").concat(specular.g, \" \").concat(specular.b, \" 1</color></specular>\") + '<shininess>' + (m.specularMap ? '<texture texture=\"specular-sampler\" texcoord=\"TEXCOORD\" />' : \"<float sid=\\\"shininess\\\">\".concat(shininess, \"</float>\")) + '</shininess>' : '') + \"<reflective><color>\".concat(diffuse.r, \" \").concat(diffuse.g, \" \").concat(diffuse.b, \" 1</color></reflective>\") + \"<reflectivity><float>\".concat(reflectivity, \"</float></reflectivity>\") + transparencyNode + \"</\".concat(type, \"></technique>\");\n          var effectnode = \"<effect id=\\\"\".concat(matid, \"-effect\\\">\") + '<profile_COMMON>' + (m.map ? '<newparam sid=\"diffuse-surface\"><surface type=\"2D\">' + \"<init_from>\".concat(processTexture(m.map), \"</init_from>\") + '</surface></newparam>' + '<newparam sid=\"diffuse-sampler\"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>' : '') + (m.specularMap ? '<newparam sid=\"specular-surface\"><surface type=\"2D\">' + \"<init_from>\".concat(processTexture(m.specularMap), \"</init_from>\") + '</surface></newparam>' + '<newparam sid=\"specular-sampler\"><sampler2D><source>specular-surface</source></sampler2D></newparam>' : '') + (m.emissiveMap ? '<newparam sid=\"emissive-surface\"><surface type=\"2D\">' + \"<init_from>\".concat(processTexture(m.emissiveMap), \"</init_from>\") + '</surface></newparam>' + '<newparam sid=\"emissive-sampler\"><sampler2D><source>emissive-surface</source></sampler2D></newparam>' : '') + (m.normalMap ? '<newparam sid=\"bump-surface\"><surface type=\"2D\">' + \"<init_from>\".concat(processTexture(m.normalMap), \"</init_from>\") + '</surface></newparam>' + '<newparam sid=\"bump-sampler\"><sampler2D><source>bump-surface</source></sampler2D></newparam>' : '') + techniqueNode + (m.side === DoubleSide ? '<extra><technique profile=\"THREEJS\"><double_sided sid=\"double_sided\" type=\"int\">1</double_sided></technique></extra>' : '') + '</profile_COMMON>' + '</effect>';\n          var materialName = m.name ? \" name=\\\"\".concat(m.name, \"\\\"\") : '';\n          var materialNode = \"<material id=\\\"\".concat(matid, \"\\\"\").concat(materialName, \"><instance_effect url=\\\"#\").concat(matid, \"-effect\\\" /></material>\");\n          libraryMaterials.push(materialNode);\n          libraryEffects.push(effectnode);\n          materialMap.set(m, matid);\n        }\n        return matid;\n      }\n\n      // Recursively process the object into a scene\n      function processObject(o) {\n        var node = \"<node name=\\\"\".concat(o.name, \"\\\">\");\n        node += getTransform(o);\n        if (o.isMesh === true && o.geometry !== null) {\n          // function returns the id associated with the mesh and a \"BufferGeometry\" version\n          // of the geometry in case it's not a geometry.\n          var geomInfo = processGeometry(o.geometry);\n          var meshid = geomInfo.meshid;\n          var geometry = geomInfo.bufferGeometry;\n\n          // ids of the materials to bind to the geometry\n          var matids = null;\n          var matidsArray;\n\n          // get a list of materials to bind to the sub groups of the geometry.\n          // If the amount of subgroups is greater than the materials, than reuse\n          // the materials.\n          var mat = o.material || new MeshBasicMaterial();\n          var materials = Array.isArray(mat) ? mat : [mat];\n          if (geometry.groups.length > materials.length) {\n            matidsArray = new Array(geometry.groups.length);\n          } else {\n            matidsArray = new Array(materials.length);\n          }\n          matids = matidsArray.fill().map(function (v, i) {\n            return processMaterial(materials[i % materials.length]);\n          });\n          node += \"<instance_geometry url=\\\"#\".concat(meshid, \"\\\">\") + (matids.length > 0 ? '<bind_material><technique_common>' + matids.map(function (id, i) {\n            return \"<instance_material symbol=\\\"MESH_MATERIAL_\".concat(i, \"\\\" target=\\\"#\").concat(id, \"\\\" >\") + '<bind_vertex_input semantic=\"TEXCOORD\" input_semantic=\"TEXCOORD\" input_set=\"0\" />' + '</instance_material>';\n          }).join('') + '</technique_common></bind_material>' : '') + '</instance_geometry>';\n        }\n        o.children.forEach(function (c) {\n          return node += processObject(c);\n        });\n        node += '</node>';\n        return node;\n      }\n      var geometryInfo = new WeakMap();\n      var materialMap = new WeakMap();\n      var imageMap = new WeakMap();\n      var textures = [];\n      var libraryImages = [];\n      var libraryGeometries = [];\n      var libraryEffects = [];\n      var libraryMaterials = [];\n      var libraryVisualScenes = processObject(object);\n      var specLink = version === '1.4.1' ? 'http://www.collada.org/2005/11/COLLADASchema' : 'https://www.khronos.org/collada/';\n      var dae = '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>' + \"<COLLADA xmlns=\\\"\".concat(specLink, \"\\\" version=\\\"\").concat(version, \"\\\">\") + '<asset>' + ('<contributor>' + '<authoring_tool>three.js Collada Exporter</authoring_tool>' + (options.author !== null ? \"<author>\".concat(options.author, \"</author>\") : '') + '</contributor>' + \"<created>\".concat(new Date().toISOString(), \"</created>\") + \"<modified>\".concat(new Date().toISOString(), \"</modified>\") + (options.unitName !== null ? \"<unit name=\\\"\".concat(options.unitName, \"\\\" meter=\\\"\").concat(options.unitMeter, \"\\\" />\") : '') + \"<up_axis>\".concat(options.upAxis, \"</up_axis>\")) + '</asset>';\n      dae += \"<library_images>\".concat(libraryImages.join(''), \"</library_images>\");\n      dae += \"<library_effects>\".concat(libraryEffects.join(''), \"</library_effects>\");\n      dae += \"<library_materials>\".concat(libraryMaterials.join(''), \"</library_materials>\");\n      dae += \"<library_geometries>\".concat(libraryGeometries.join(''), \"</library_geometries>\");\n      dae += \"<library_visual_scenes><visual_scene id=\\\"Scene\\\" name=\\\"scene\\\">\".concat(libraryVisualScenes, \"</visual_scene></library_visual_scenes>\");\n      dae += '<scene><instance_visual_scene url=\"#Scene\"/></scene>';\n      dae += '</COLLADA>';\n      var res = {\n        data: format(dae),\n        textures: textures\n      };\n      if (typeof onDone === 'function') {\n        requestAnimationFrame(function () {\n          return onDone(res);\n        });\n      }\n      return res;\n    }\n  }]);\n  return ColladaExporter;\n}();\nexport { ColladaExporter };","map":{"version":3,"names":["Color","DoubleSide","Matrix4","MeshBasicMaterial","ColladaExporter","object","onDone","options","Object","assign","version","author","textureDirectory","upAxis","unitName","unitMeter","match","console","error","replace","warn","format","urdf","IS_END_TAG","IS_SELF_CLOSING","HAS_TEXT","pad","ch","num","tagnum","map","tag","test","res","join","base64ToBuffer","str","b","atob","buf","Uint8Array","length","i","l","charCodeAt","canvas","ctx","imageToData","image","ext","document","createElement","getContext","width","height","drawImage","base64data","toDataURL","getFuncs","tempColor","attrBufferToArray","attr","isColor","arr","Float32Array","count","fromBufferAttribute","convertLinearToSRGB","r","g","isInterleavedBufferAttribute","array","constructor","itemSize","size","j","subArray","st","ct","Array","isArray","slice","buffer","BYTES_PER_ELEMENT","getAttribute","name","params","type","Math","floor","n","transMat","getTransform","o","updateMatrix","copy","matrix","transpose","toArray","processGeometry","info","geometryInfo","get","bufferGeometry","isBufferGeometry","Error","meshid","libraryGeometries","indexCount","index","attributes","position","groups","start","materialIndex","gname","gnode","posName","vertName","triangleInputs","normName","normal","uvName","uv","uv2","colName","color","indexArray","group","subarr","polycount","push","set","processTexture","tex","texid","imageMap","libraryImages","imageNode","textures","directory","data","original","processMaterial","m","matid","materialMap","libraryEffects","isMeshLambertMaterial","isMeshBasicMaterial","emissive","diffuse","specular","shininess","reflectivity","transparencyNode","transparent","opacity","techniqueNode","emissiveMap","normalMap","specularMap","effectnode","side","materialName","materialNode","libraryMaterials","processObject","node","isMesh","geometry","geomInfo","matids","matidsArray","mat","material","materials","fill","v","id","children","forEach","c","WeakMap","libraryVisualScenes","specLink","dae","Date","toISOString","requestAnimationFrame"],"sources":["/home/xkruzel/node_modules/three/examples/jsm/exporters/ColladaExporter.js"],"sourcesContent":["import {\n\tColor,\n\tDoubleSide,\n\tMatrix4,\n\tMeshBasicMaterial\n} from 'three';\n\n/**\n * https://github.com/gkjohnson/collada-exporter-js\n *\n * Usage:\n *  const exporter = new ColladaExporter();\n *\n *  const data = exporter.parse(mesh);\n *\n * Format Definition:\n *  https://www.khronos.org/collada/\n */\n\nclass ColladaExporter {\n\n\tparse( object, onDone, options = {} ) {\n\n\t\toptions = Object.assign( {\n\t\t\tversion: '1.4.1',\n\t\t\tauthor: null,\n\t\t\ttextureDirectory: '',\n\t\t\tupAxis: 'Y_UP',\n\t\t\tunitName: null,\n\t\t\tunitMeter: null,\n\t\t}, options );\n\n\t\tif ( options.upAxis.match( /^[XYZ]_UP$/ ) === null ) {\n\n\t\t\tconsole.error( 'ColladaExporter: Invalid upAxis: valid values are X_UP, Y_UP or Z_UP.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( options.unitName !== null && options.unitMeter === null ) {\n\n\t\t\tconsole.error( 'ColladaExporter: unitMeter needs to be specified if unitName is specified.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( options.unitMeter !== null && options.unitName === null ) {\n\n\t\t\tconsole.error( 'ColladaExporter: unitName needs to be specified if unitMeter is specified.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( options.textureDirectory !== '' ) {\n\n\t\t\toptions.textureDirectory = `${ options.textureDirectory }/`\n\t\t\t\t.replace( /\\\\/g, '/' )\n\t\t\t\t.replace( /\\/+/g, '/' );\n\n\t\t}\n\n\t\tconst version = options.version;\n\n\t\tif ( version !== '1.4.1' && version !== '1.5.0' ) {\n\n\t\t\tconsole.warn( `ColladaExporter : Version ${ version } not supported for export. Only 1.4.1 and 1.5.0.` );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// Convert the urdf xml into a well-formatted, indented format\n\t\tfunction format( urdf ) {\n\n\t\t\tconst IS_END_TAG = /^<\\//;\n\t\t\tconst IS_SELF_CLOSING = /(\\?>$)|(\\/>$)/;\n\t\t\tconst HAS_TEXT = /<[^>]+>[^<]*<\\/[^<]+>/;\n\n\t\t\tconst pad = ( ch, num ) => ( num > 0 ? ch + pad( ch, num - 1 ) : '' );\n\n\t\t\tlet tagnum = 0;\n\n\t\t\treturn urdf\n\t\t\t\t.match( /(<[^>]+>[^<]+<\\/[^<]+>)|(<[^>]+>)/g )\n\t\t\t\t.map( tag => {\n\n\t\t\t\t\tif ( ! HAS_TEXT.test( tag ) && ! IS_SELF_CLOSING.test( tag ) && IS_END_TAG.test( tag ) ) {\n\n\t\t\t\t\t\ttagnum --;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst res = `${ pad( '  ', tagnum ) }${ tag }`;\n\n\t\t\t\t\tif ( ! HAS_TEXT.test( tag ) && ! IS_SELF_CLOSING.test( tag ) && ! IS_END_TAG.test( tag ) ) {\n\n\t\t\t\t\t\ttagnum ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn res;\n\n\t\t\t\t} )\n\t\t\t\t.join( '\\n' );\n\n\t\t}\n\n\t\t// Convert an image into a png format for saving\n\t\tfunction base64ToBuffer( str ) {\n\n\t\t\tconst b = atob( str );\n\t\t\tconst buf = new Uint8Array( b.length );\n\n\t\t\tfor ( let i = 0, l = buf.length; i < l; i ++ ) {\n\n\t\t\t\tbuf[ i ] = b.charCodeAt( i );\n\n\t\t\t}\n\n\t\t\treturn buf;\n\n\t\t}\n\n\t\tlet canvas, ctx;\n\n\t\tfunction imageToData( image, ext ) {\n\n\t\t\tcanvas = canvas || document.createElement( 'canvas' );\n\t\t\tctx = ctx || canvas.getContext( '2d' );\n\n\t\t\tcanvas.width = image.width;\n\t\t\tcanvas.height = image.height;\n\n\t\t\tctx.drawImage( image, 0, 0 );\n\n\t\t\t// Get the base64 encoded data\n\t\t\tconst base64data = canvas\n\t\t\t\t.toDataURL( `image/${ ext }`, 1 )\n\t\t\t\t.replace( /^data:image\\/(png|jpg);base64,/, '' );\n\n\t\t\t// Convert to a uint8 array\n\t\t\treturn base64ToBuffer( base64data );\n\n\t\t}\n\n\t\t// gets the attribute array. Generate a new array if the attribute is interleaved\n\t\tconst getFuncs = [ 'getX', 'getY', 'getZ', 'getW' ];\n\t\tconst tempColor = new Color();\n\n\t\tfunction attrBufferToArray( attr, isColor = false ) {\n\n\t\t\tif ( isColor ) {\n\n\t\t\t\t// convert the colors to srgb before export\n\t\t\t\t// colors are always written as floats\n\t\t\t\tconst arr = new Float32Array( attr.count * 3 );\n\t\t\t\tfor ( let i = 0, l = attr.count; i < l; i ++ ) {\n\n\t\t\t\t\ttempColor\n\t\t\t\t\t\t.fromBufferAttribute( attr, i )\n\t\t\t\t\t\t.convertLinearToSRGB();\n\n\t\t\t\t\tarr[ 3 * i + 0 ] = tempColor.r;\n\t\t\t\t\tarr[ 3 * i + 1 ] = tempColor.g;\n\t\t\t\t\tarr[ 3 * i + 2 ] = tempColor.b;\n\n\t\t\t\t}\n\n\t\t\t\treturn arr;\n\n\t\t\t} else if ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\t\t// use the typed array constructor to save on memory\n\t\t\t\tconst arr = new attr.array.constructor( attr.count * attr.itemSize );\n\t\t\t\tconst size = attr.itemSize;\n\n\t\t\t\tfor ( let i = 0, l = attr.count; i < l; i ++ ) {\n\n\t\t\t\t\tfor ( let j = 0; j < size; j ++ ) {\n\n\t\t\t\t\t\tarr[ i * size + j ] = attr[ getFuncs[ j ] ]( i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn arr;\n\n\t\t\t} else {\n\n\t\t\t\treturn attr.array;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Returns an array of the same type starting at the `st` index,\n\t\t// and `ct` length\n\t\tfunction subArray( arr, st, ct ) {\n\n\t\t\tif ( Array.isArray( arr ) ) return arr.slice( st, st + ct );\n\t\t\telse return new arr.constructor( arr.buffer, st * arr.BYTES_PER_ELEMENT, ct );\n\n\t\t}\n\n\t\t// Returns the string for a geometry's attribute\n\t\tfunction getAttribute( attr, name, params, type, isColor = false ) {\n\n\t\t\tconst array = attrBufferToArray( attr, isColor );\n\t\t\tconst res =\n\t\t\t\t\t`<source id=\"${ name }\">` +\n\n\t\t\t\t\t`<float_array id=\"${ name }-array\" count=\"${ array.length }\">` +\n\t\t\t\t\tarray.join( ' ' ) +\n\t\t\t\t\t'</float_array>' +\n\n\t\t\t\t\t'<technique_common>' +\n\t\t\t\t\t`<accessor source=\"#${ name }-array\" count=\"${ Math.floor( array.length / attr.itemSize ) }\" stride=\"${ attr.itemSize }\">` +\n\n\t\t\t\t\tparams.map( n => `<param name=\"${ n }\" type=\"${ type }\" />` ).join( '' ) +\n\n\t\t\t\t\t'</accessor>' +\n\t\t\t\t\t'</technique_common>' +\n\t\t\t\t\t'</source>';\n\n\t\t\treturn res;\n\n\t\t}\n\n\t\t// Returns the string for a node's transform information\n\t\tlet transMat;\n\t\tfunction getTransform( o ) {\n\n\t\t\t// ensure the object's matrix is up to date\n\t\t\t// before saving the transform\n\t\t\to.updateMatrix();\n\n\t\t\ttransMat = transMat || new Matrix4();\n\t\t\ttransMat.copy( o.matrix );\n\t\t\ttransMat.transpose();\n\t\t\treturn `<matrix>${ transMat.toArray().join( ' ' ) }</matrix>`;\n\n\t\t}\n\n\t\t// Process the given piece of geometry into the geometry library\n\t\t// Returns the mesh id\n\t\tfunction processGeometry( g ) {\n\n\t\t\tlet info = geometryInfo.get( g );\n\n\t\t\tif ( ! info ) {\n\n\t\t\t\t// convert the geometry to bufferGeometry if it isn't already\n\t\t\t\tconst bufferGeometry = g;\n\n\t\t\t\tif ( bufferGeometry.isBufferGeometry !== true ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.ColladaExporter: Geometry is not of type THREE.BufferGeometry.' );\n\n\t\t\t\t}\n\n\t\t\t\tconst meshid = `Mesh${ libraryGeometries.length + 1 }`;\n\n\t\t\t\tconst indexCount =\n\t\t\t\t\tbufferGeometry.index ?\n\t\t\t\t\t\tbufferGeometry.index.count * bufferGeometry.index.itemSize :\n\t\t\t\t\t\tbufferGeometry.attributes.position.count;\n\n\t\t\t\tconst groups =\n\t\t\t\t\tbufferGeometry.groups != null && bufferGeometry.groups.length !== 0 ?\n\t\t\t\t\t\tbufferGeometry.groups :\n\t\t\t\t\t\t[ { start: 0, count: indexCount, materialIndex: 0 } ];\n\n\n\t\t\t\tconst gname = g.name ? ` name=\"${ g.name }\"` : '';\n\t\t\t\tlet gnode = `<geometry id=\"${ meshid }\"${ gname }><mesh>`;\n\n\t\t\t\t// define the geometry node and the vertices for the geometry\n\t\t\t\tconst posName = `${ meshid }-position`;\n\t\t\t\tconst vertName = `${ meshid }-vertices`;\n\t\t\t\tgnode += getAttribute( bufferGeometry.attributes.position, posName, [ 'X', 'Y', 'Z' ], 'float' );\n\t\t\t\tgnode += `<vertices id=\"${ vertName }\"><input semantic=\"POSITION\" source=\"#${ posName }\" /></vertices>`;\n\n\t\t\t\t// NOTE: We're not optimizing the attribute arrays here, so they're all the same length and\n\t\t\t\t// can therefore share the same triangle indices. However, MeshLab seems to have trouble opening\n\t\t\t\t// models with attributes that share an offset.\n\t\t\t\t// MeshLab Bug#424: https://sourceforge.net/p/meshlab/bugs/424/\n\n\t\t\t\t// serialize normals\n\t\t\t\tlet triangleInputs = `<input semantic=\"VERTEX\" source=\"#${ vertName }\" offset=\"0\" />`;\n\t\t\t\tif ( 'normal' in bufferGeometry.attributes ) {\n\n\t\t\t\t\tconst normName = `${ meshid }-normal`;\n\t\t\t\t\tgnode += getAttribute( bufferGeometry.attributes.normal, normName, [ 'X', 'Y', 'Z' ], 'float' );\n\t\t\t\t\ttriangleInputs += `<input semantic=\"NORMAL\" source=\"#${ normName }\" offset=\"0\" />`;\n\n\t\t\t\t}\n\n\t\t\t\t// serialize uvs\n\t\t\t\tif ( 'uv' in bufferGeometry.attributes ) {\n\n\t\t\t\t\tconst uvName = `${ meshid }-texcoord`;\n\t\t\t\t\tgnode += getAttribute( bufferGeometry.attributes.uv, uvName, [ 'S', 'T' ], 'float' );\n\t\t\t\t\ttriangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${ uvName }\" offset=\"0\" set=\"0\" />`;\n\n\t\t\t\t}\n\n\t\t\t\t// serialize lightmap uvs\n\t\t\t\tif ( 'uv2' in bufferGeometry.attributes ) {\n\n\t\t\t\t\tconst uvName = `${ meshid }-texcoord2`;\n\t\t\t\t\tgnode += getAttribute( bufferGeometry.attributes.uv2, uvName, [ 'S', 'T' ], 'float' );\n\t\t\t\t\ttriangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${ uvName }\" offset=\"0\" set=\"1\" />`;\n\n\t\t\t\t}\n\n\t\t\t\t// serialize colors\n\t\t\t\tif ( 'color' in bufferGeometry.attributes ) {\n\n\t\t\t\t\t// colors are always written as floats\n\t\t\t\t\tconst colName = `${ meshid }-color`;\n\t\t\t\t\tgnode += getAttribute( bufferGeometry.attributes.color, colName, [ 'R', 'G', 'B' ], 'float', true );\n\t\t\t\t\ttriangleInputs += `<input semantic=\"COLOR\" source=\"#${ colName }\" offset=\"0\" />`;\n\n\t\t\t\t}\n\n\t\t\t\tlet indexArray = null;\n\t\t\t\tif ( bufferGeometry.index ) {\n\n\t\t\t\t\tindexArray = attrBufferToArray( bufferGeometry.index );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindexArray = new Array( indexCount );\n\t\t\t\t\tfor ( let i = 0, l = indexArray.length; i < l; i ++ ) indexArray[ i ] = i;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\tconst subarr = subArray( indexArray, group.start, group.count );\n\t\t\t\t\tconst polycount = subarr.length / 3;\n\t\t\t\t\tgnode += `<triangles material=\"MESH_MATERIAL_${ group.materialIndex }\" count=\"${ polycount }\">`;\n\t\t\t\t\tgnode += triangleInputs;\n\n\t\t\t\t\tgnode += `<p>${ subarr.join( ' ' ) }</p>`;\n\t\t\t\t\tgnode += '</triangles>';\n\n\t\t\t\t}\n\n\t\t\t\tgnode += '</mesh></geometry>';\n\n\t\t\t\tlibraryGeometries.push( gnode );\n\n\t\t\t\tinfo = { meshid: meshid, bufferGeometry: bufferGeometry };\n\t\t\t\tgeometryInfo.set( g, info );\n\n\t\t\t}\n\n\t\t\treturn info;\n\n\t\t}\n\n\t\t// Process the given texture into the image library\n\t\t// Returns the image library\n\t\tfunction processTexture( tex ) {\n\n\t\t\tlet texid = imageMap.get( tex );\n\t\t\tif ( texid == null ) {\n\n\t\t\t\ttexid = `image-${ libraryImages.length + 1 }`;\n\n\t\t\t\tconst ext = 'png';\n\t\t\t\tconst name = tex.name || texid;\n\t\t\t\tlet imageNode = `<image id=\"${ texid }\" name=\"${ name }\">`;\n\n\t\t\t\tif ( version === '1.5.0' ) {\n\n\t\t\t\t\timageNode += `<init_from><ref>${ options.textureDirectory }${ name }.${ ext }</ref></init_from>`;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// version image node 1.4.1\n\t\t\t\t\timageNode += `<init_from>${ options.textureDirectory }${ name }.${ ext }</init_from>`;\n\n\t\t\t\t}\n\n\t\t\t\timageNode += '</image>';\n\n\t\t\t\tlibraryImages.push( imageNode );\n\t\t\t\timageMap.set( tex, texid );\n\t\t\t\ttextures.push( {\n\t\t\t\t\tdirectory: options.textureDirectory,\n\t\t\t\t\tname,\n\t\t\t\t\text,\n\t\t\t\t\tdata: imageToData( tex.image, ext ),\n\t\t\t\t\toriginal: tex\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn texid;\n\n\t\t}\n\n\t\t// Process the given material into the material and effect libraries\n\t\t// Returns the material id\n\t\tfunction processMaterial( m ) {\n\n\t\t\tlet matid = materialMap.get( m );\n\n\t\t\tif ( matid == null ) {\n\n\t\t\t\tmatid = `Mat${ libraryEffects.length + 1 }`;\n\n\t\t\t\tlet type = 'phong';\n\n\t\t\t\tif ( m.isMeshLambertMaterial === true ) {\n\n\t\t\t\t\ttype = 'lambert';\n\n\t\t\t\t} else if ( m.isMeshBasicMaterial === true ) {\n\n\t\t\t\t\ttype = 'constant';\n\n\t\t\t\t\tif ( m.map !== null ) {\n\n\t\t\t\t\t\t// The Collada spec does not support diffuse texture maps with the\n\t\t\t\t\t\t// constant shader type.\n\t\t\t\t\t\t// mrdoob/three.js#15469\n\t\t\t\t\t\tconsole.warn( 'ColladaExporter: Texture maps not supported with MeshBasicMaterial.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst emissive = m.emissive ? m.emissive : new Color( 0, 0, 0 );\n\t\t\t\tconst diffuse = m.color ? m.color : new Color( 0, 0, 0 );\n\t\t\t\tconst specular = m.specular ? m.specular : new Color( 1, 1, 1 );\n\t\t\t\tconst shininess = m.shininess || 0;\n\t\t\t\tconst reflectivity = m.reflectivity || 0;\n\n\t\t\t\temissive.convertLinearToSRGB();\n\t\t\t\tspecular.convertLinearToSRGB();\n\t\t\t\tdiffuse.convertLinearToSRGB();\n\n\t\t\t\t// Do not export and alpha map for the reasons mentioned in issue (#13792)\n\t\t\t\t// in three.js alpha maps are black and white, but collada expects the alpha\n\t\t\t\t// channel to specify the transparency\n\t\t\t\tlet transparencyNode = '';\n\t\t\t\tif ( m.transparent === true ) {\n\n\t\t\t\t\ttransparencyNode +=\n\t\t\t\t\t\t'<transparent>' +\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tm.map ?\n\t\t\t\t\t\t\t\t'<texture texture=\"diffuse-sampler\"></texture>' :\n\t\t\t\t\t\t\t\t'<float>1</float>'\n\t\t\t\t\t\t) +\n\t\t\t\t\t\t'</transparent>';\n\n\t\t\t\t\tif ( m.opacity < 1 ) {\n\n\t\t\t\t\t\ttransparencyNode += `<transparency><float>${ m.opacity }</float></transparency>`;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst techniqueNode = `<technique sid=\"common\"><${ type }>` +\n\n\t\t\t\t\t'<emission>' +\n\n\t\t\t\t\t(\n\t\t\t\t\t\tm.emissiveMap ?\n\t\t\t\t\t\t\t'<texture texture=\"emissive-sampler\" texcoord=\"TEXCOORD\" />' :\n\t\t\t\t\t\t\t`<color sid=\"emission\">${ emissive.r } ${ emissive.g } ${ emissive.b } 1</color>`\n\t\t\t\t\t) +\n\n\t\t\t\t\t'</emission>' +\n\n\t\t\t\t\t(\n\t\t\t\t\t\ttype !== 'constant' ?\n\t\t\t\t\t\t\t'<diffuse>' +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tm.map ?\n\t\t\t\t\t\t\t\t'<texture texture=\"diffuse-sampler\" texcoord=\"TEXCOORD\" />' :\n\t\t\t\t\t\t\t\t`<color sid=\"diffuse\">${ diffuse.r } ${ diffuse.g } ${ diffuse.b } 1</color>`\n\t\t\t\t\t\t) +\n\t\t\t\t\t\t'</diffuse>'\n\t\t\t\t\t\t\t: ''\n\t\t\t\t\t) +\n\n\t\t\t\t\t(\n\t\t\t\t\t\ttype !== 'constant' ?\n\t\t\t\t\t\t\t'<bump>' +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tm.normalMap ? '<texture texture=\"bump-sampler\" texcoord=\"TEXCOORD\" />' : ''\n\t\t\t\t\t\t) +\n\t\t\t\t\t\t'</bump>'\n\t\t\t\t\t\t\t: ''\n\t\t\t\t\t) +\n\n\t\t\t\t\t(\n\t\t\t\t\t\ttype === 'phong' ?\n\t\t\t\t\t\t\t`<specular><color sid=\"specular\">${ specular.r } ${ specular.g } ${ specular.b } 1</color></specular>` +\n\n\t\t\t\t\t\t'<shininess>' +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tm.specularMap ?\n\t\t\t\t\t\t\t\t'<texture texture=\"specular-sampler\" texcoord=\"TEXCOORD\" />' :\n\t\t\t\t\t\t\t\t`<float sid=\"shininess\">${ shininess }</float>`\n\t\t\t\t\t\t) +\n\n\t\t\t\t\t\t'</shininess>'\n\t\t\t\t\t\t\t: ''\n\t\t\t\t\t) +\n\n\t\t\t\t\t`<reflective><color>${ diffuse.r } ${ diffuse.g } ${ diffuse.b } 1</color></reflective>` +\n\n\t\t\t\t\t`<reflectivity><float>${ reflectivity }</float></reflectivity>` +\n\n\t\t\t\t\ttransparencyNode +\n\n\t\t\t\t\t`</${ type }></technique>`;\n\n\t\t\t\tconst effectnode =\n\t\t\t\t\t`<effect id=\"${ matid }-effect\">` +\n\t\t\t\t\t'<profile_COMMON>' +\n\n\t\t\t\t\t(\n\t\t\t\t\t\tm.map ?\n\t\t\t\t\t\t\t'<newparam sid=\"diffuse-surface\"><surface type=\"2D\">' +\n\t\t\t\t\t\t\t`<init_from>${ processTexture( m.map ) }</init_from>` +\n\t\t\t\t\t\t\t'</surface></newparam>' +\n\t\t\t\t\t\t\t'<newparam sid=\"diffuse-sampler\"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>' :\n\t\t\t\t\t\t\t''\n\t\t\t\t\t) +\n\n\t\t\t\t\t(\n\t\t\t\t\t\tm.specularMap ?\n\t\t\t\t\t\t\t'<newparam sid=\"specular-surface\"><surface type=\"2D\">' +\n\t\t\t\t\t\t\t`<init_from>${ processTexture( m.specularMap ) }</init_from>` +\n\t\t\t\t\t\t\t'</surface></newparam>' +\n\t\t\t\t\t\t\t'<newparam sid=\"specular-sampler\"><sampler2D><source>specular-surface</source></sampler2D></newparam>' :\n\t\t\t\t\t\t\t''\n\t\t\t\t\t) +\n\n\t\t\t\t\t(\n\t\t\t\t\t\tm.emissiveMap ?\n\t\t\t\t\t\t\t'<newparam sid=\"emissive-surface\"><surface type=\"2D\">' +\n\t\t\t\t\t\t\t`<init_from>${ processTexture( m.emissiveMap ) }</init_from>` +\n\t\t\t\t\t\t\t'</surface></newparam>' +\n\t\t\t\t\t\t\t'<newparam sid=\"emissive-sampler\"><sampler2D><source>emissive-surface</source></sampler2D></newparam>' :\n\t\t\t\t\t\t\t''\n\t\t\t\t\t) +\n\n\t\t\t\t\t(\n\t\t\t\t\t\tm.normalMap ?\n\t\t\t\t\t\t\t'<newparam sid=\"bump-surface\"><surface type=\"2D\">' +\n\t\t\t\t\t\t\t`<init_from>${ processTexture( m.normalMap ) }</init_from>` +\n\t\t\t\t\t\t\t'</surface></newparam>' +\n\t\t\t\t\t\t\t'<newparam sid=\"bump-sampler\"><sampler2D><source>bump-surface</source></sampler2D></newparam>' :\n\t\t\t\t\t\t\t''\n\t\t\t\t\t) +\n\n\t\t\t\t\ttechniqueNode +\n\n\t\t\t\t\t(\n\t\t\t\t\t\tm.side === DoubleSide ?\n\t\t\t\t\t\t\t'<extra><technique profile=\"THREEJS\"><double_sided sid=\"double_sided\" type=\"int\">1</double_sided></technique></extra>' :\n\t\t\t\t\t\t\t''\n\t\t\t\t\t) +\n\n\t\t\t\t\t'</profile_COMMON>' +\n\n\t\t\t\t\t'</effect>';\n\n\t\t\t\tconst materialName = m.name ? ` name=\"${ m.name }\"` : '';\n\t\t\t\tconst materialNode = `<material id=\"${ matid }\"${ materialName }><instance_effect url=\"#${ matid }-effect\" /></material>`;\n\n\t\t\t\tlibraryMaterials.push( materialNode );\n\t\t\t\tlibraryEffects.push( effectnode );\n\t\t\t\tmaterialMap.set( m, matid );\n\n\t\t\t}\n\n\t\t\treturn matid;\n\n\t\t}\n\n\t\t// Recursively process the object into a scene\n\t\tfunction processObject( o ) {\n\n\t\t\tlet node = `<node name=\"${ o.name }\">`;\n\n\t\t\tnode += getTransform( o );\n\n\t\t\tif ( o.isMesh === true && o.geometry !== null ) {\n\n\t\t\t\t// function returns the id associated with the mesh and a \"BufferGeometry\" version\n\t\t\t\t// of the geometry in case it's not a geometry.\n\t\t\t\tconst geomInfo = processGeometry( o.geometry );\n\t\t\t\tconst meshid = geomInfo.meshid;\n\t\t\t\tconst geometry = geomInfo.bufferGeometry;\n\n\t\t\t\t// ids of the materials to bind to the geometry\n\t\t\t\tlet matids = null;\n\t\t\t\tlet matidsArray;\n\n\t\t\t\t// get a list of materials to bind to the sub groups of the geometry.\n\t\t\t\t// If the amount of subgroups is greater than the materials, than reuse\n\t\t\t\t// the materials.\n\t\t\t\tconst mat = o.material || new MeshBasicMaterial();\n\t\t\t\tconst materials = Array.isArray( mat ) ? mat : [ mat ];\n\n\t\t\t\tif ( geometry.groups.length > materials.length ) {\n\n\t\t\t\t\tmatidsArray = new Array( geometry.groups.length );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmatidsArray = new Array( materials.length );\n\n\t\t\t\t}\n\n\t\t\t\tmatids = matidsArray.fill().map( ( v, i ) => processMaterial( materials[ i % materials.length ] ) );\n\n\t\t\t\tnode +=\n\t\t\t\t\t`<instance_geometry url=\"#${ meshid }\">` +\n\n\t\t\t\t\t(\n\t\t\t\t\t\tmatids.length > 0 ?\n\t\t\t\t\t\t\t'<bind_material><technique_common>' +\n\t\t\t\t\t\t\tmatids.map( ( id, i ) =>\n\n\t\t\t\t\t\t\t\t`<instance_material symbol=\"MESH_MATERIAL_${ i }\" target=\"#${ id }\" >` +\n\n\t\t\t\t\t\t\t\t'<bind_vertex_input semantic=\"TEXCOORD\" input_semantic=\"TEXCOORD\" input_set=\"0\" />' +\n\n\t\t\t\t\t\t\t\t'</instance_material>'\n\t\t\t\t\t\t\t).join( '' ) +\n\t\t\t\t\t\t\t'</technique_common></bind_material>' :\n\t\t\t\t\t\t\t''\n\t\t\t\t\t) +\n\n\t\t\t\t\t'</instance_geometry>';\n\n\t\t\t}\n\n\t\t\to.children.forEach( c => node += processObject( c ) );\n\n\t\t\tnode += '</node>';\n\n\t\t\treturn node;\n\n\t\t}\n\n\t\tconst geometryInfo = new WeakMap();\n\t\tconst materialMap = new WeakMap();\n\t\tconst imageMap = new WeakMap();\n\t\tconst textures = [];\n\n\t\tconst libraryImages = [];\n\t\tconst libraryGeometries = [];\n\t\tconst libraryEffects = [];\n\t\tconst libraryMaterials = [];\n\t\tconst libraryVisualScenes = processObject( object );\n\n\t\tconst specLink = version === '1.4.1' ? 'http://www.collada.org/2005/11/COLLADASchema' : 'https://www.khronos.org/collada/';\n\t\tlet dae =\n\t\t\t'<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>' +\n\t\t\t`<COLLADA xmlns=\"${ specLink }\" version=\"${ version }\">` +\n\t\t\t'<asset>' +\n\t\t\t(\n\t\t\t\t'<contributor>' +\n\t\t\t\t'<authoring_tool>three.js Collada Exporter</authoring_tool>' +\n\t\t\t\t( options.author !== null ? `<author>${ options.author }</author>` : '' ) +\n\t\t\t\t'</contributor>' +\n\t\t\t\t`<created>${ ( new Date() ).toISOString() }</created>` +\n\t\t\t\t`<modified>${ ( new Date() ).toISOString() }</modified>` +\n\t\t\t\t( options.unitName !== null ? `<unit name=\"${ options.unitName }\" meter=\"${ options.unitMeter }\" />` : '' ) +\n\t\t\t\t`<up_axis>${ options.upAxis }</up_axis>`\n\t\t\t) +\n\t\t\t'</asset>';\n\n\t\tdae += `<library_images>${ libraryImages.join( '' ) }</library_images>`;\n\n\t\tdae += `<library_effects>${ libraryEffects.join( '' ) }</library_effects>`;\n\n\t\tdae += `<library_materials>${ libraryMaterials.join( '' ) }</library_materials>`;\n\n\t\tdae += `<library_geometries>${ libraryGeometries.join( '' ) }</library_geometries>`;\n\n\t\tdae += `<library_visual_scenes><visual_scene id=\"Scene\" name=\"scene\">${ libraryVisualScenes }</visual_scene></library_visual_scenes>`;\n\n\t\tdae += '<scene><instance_visual_scene url=\"#Scene\"/></scene>';\n\n\t\tdae += '</COLLADA>';\n\n\t\tconst res = {\n\t\t\tdata: format( dae ),\n\t\t\ttextures\n\t\t};\n\n\t\tif ( typeof onDone === 'function' ) {\n\n\t\t\trequestAnimationFrame( () => onDone( res ) );\n\n\t\t}\n\n\t\treturn res;\n\n\t}\n\n}\n\n\nexport { ColladaExporter };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}