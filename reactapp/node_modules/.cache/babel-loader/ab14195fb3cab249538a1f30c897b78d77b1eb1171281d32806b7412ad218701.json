{"ast":null,"code":"import _classCallCheck from \"/home/xkruzel/Desktop/todo/reactapp/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/xkruzel/Desktop/todo/reactapp/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Color, Matrix3, Vector2, Vector3 } from 'three';\nvar OBJExporter = /*#__PURE__*/function () {\n  function OBJExporter() {\n    _classCallCheck(this, OBJExporter);\n  }\n  _createClass(OBJExporter, [{\n    key: \"parse\",\n    value: function parse(object) {\n      var output = '';\n      var indexVertex = 0;\n      var indexVertexUvs = 0;\n      var indexNormals = 0;\n      var vertex = new Vector3();\n      var color = new Color();\n      var normal = new Vector3();\n      var uv = new Vector2();\n      var face = [];\n      function parseMesh(mesh) {\n        var nbVertex = 0;\n        var nbNormals = 0;\n        var nbVertexUvs = 0;\n        var geometry = mesh.geometry;\n        var normalMatrixWorld = new Matrix3();\n        if (geometry.isBufferGeometry !== true) {\n          throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.');\n        }\n\n        // shortcuts\n        var vertices = geometry.getAttribute('position');\n        var normals = geometry.getAttribute('normal');\n        var uvs = geometry.getAttribute('uv');\n        var indices = geometry.getIndex();\n\n        // name of the mesh object\n        output += 'o ' + mesh.name + '\\n';\n\n        // name of the mesh material\n        if (mesh.material && mesh.material.name) {\n          output += 'usemtl ' + mesh.material.name + '\\n';\n        }\n\n        // vertices\n\n        if (vertices !== undefined) {\n          for (var i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n            vertex.fromBufferAttribute(vertices, i);\n\n            // transform the vertex to world space\n            vertex.applyMatrix4(mesh.matrixWorld);\n\n            // transform the vertex to export format\n            output += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n';\n          }\n        }\n\n        // uvs\n\n        if (uvs !== undefined) {\n          for (var _i = 0, _l = uvs.count; _i < _l; _i++, nbVertexUvs++) {\n            uv.fromBufferAttribute(uvs, _i);\n\n            // transform the uv to export format\n            output += 'vt ' + uv.x + ' ' + uv.y + '\\n';\n          }\n        }\n\n        // normals\n\n        if (normals !== undefined) {\n          normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n          for (var _i2 = 0, _l2 = normals.count; _i2 < _l2; _i2++, nbNormals++) {\n            normal.fromBufferAttribute(normals, _i2);\n\n            // transform the normal to world space\n            normal.applyMatrix3(normalMatrixWorld).normalize();\n\n            // transform the normal to export format\n            output += 'vn ' + normal.x + ' ' + normal.y + ' ' + normal.z + '\\n';\n          }\n        }\n\n        // faces\n\n        if (indices !== null) {\n          for (var _i3 = 0, _l3 = indices.count; _i3 < _l3; _i3 += 3) {\n            for (var m = 0; m < 3; m++) {\n              var j = indices.getX(_i3 + m) + 1;\n              face[m] = indexVertex + j + (normals || uvs ? '/' + (uvs ? indexVertexUvs + j : '') + (normals ? '/' + (indexNormals + j) : '') : '');\n            }\n\n            // transform the face to export format\n            output += 'f ' + face.join(' ') + '\\n';\n          }\n        } else {\n          for (var _i4 = 0, _l4 = vertices.count; _i4 < _l4; _i4 += 3) {\n            for (var _m = 0; _m < 3; _m++) {\n              var _j = _i4 + _m + 1;\n              face[_m] = indexVertex + _j + (normals || uvs ? '/' + (uvs ? indexVertexUvs + _j : '') + (normals ? '/' + (indexNormals + _j) : '') : '');\n            }\n\n            // transform the face to export format\n            output += 'f ' + face.join(' ') + '\\n';\n          }\n        }\n\n        // update index\n        indexVertex += nbVertex;\n        indexVertexUvs += nbVertexUvs;\n        indexNormals += nbNormals;\n      }\n      function parseLine(line) {\n        var nbVertex = 0;\n        var geometry = line.geometry;\n        var type = line.type;\n        if (geometry.isBufferGeometry !== true) {\n          throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.');\n        }\n\n        // shortcuts\n        var vertices = geometry.getAttribute('position');\n\n        // name of the line object\n        output += 'o ' + line.name + '\\n';\n        if (vertices !== undefined) {\n          for (var i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n            vertex.fromBufferAttribute(vertices, i);\n\n            // transform the vertex to world space\n            vertex.applyMatrix4(line.matrixWorld);\n\n            // transform the vertex to export format\n            output += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n';\n          }\n        }\n        if (type === 'Line') {\n          output += 'l ';\n          for (var j = 1, _l5 = vertices.count; j <= _l5; j++) {\n            output += indexVertex + j + ' ';\n          }\n          output += '\\n';\n        }\n        if (type === 'LineSegments') {\n          for (var _j2 = 1, k = _j2 + 1, _l6 = vertices.count; _j2 < _l6; _j2 += 2, k = _j2 + 1) {\n            output += 'l ' + (indexVertex + _j2) + ' ' + (indexVertex + k) + '\\n';\n          }\n        }\n\n        // update index\n        indexVertex += nbVertex;\n      }\n      function parsePoints(points) {\n        var nbVertex = 0;\n        var geometry = points.geometry;\n        if (geometry.isBufferGeometry !== true) {\n          throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.');\n        }\n        var vertices = geometry.getAttribute('position');\n        var colors = geometry.getAttribute('color');\n        output += 'o ' + points.name + '\\n';\n        if (vertices !== undefined) {\n          for (var i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n            vertex.fromBufferAttribute(vertices, i);\n            vertex.applyMatrix4(points.matrixWorld);\n            output += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z;\n            if (colors !== undefined) {\n              color.fromBufferAttribute(colors, i).convertLinearToSRGB();\n              output += ' ' + color.r + ' ' + color.g + ' ' + color.b;\n            }\n            output += '\\n';\n          }\n          output += 'p ';\n          for (var j = 1, _l7 = vertices.count; j <= _l7; j++) {\n            output += indexVertex + j + ' ';\n          }\n          output += '\\n';\n        }\n\n        // update index\n        indexVertex += nbVertex;\n      }\n      object.traverse(function (child) {\n        if (child.isMesh === true) {\n          parseMesh(child);\n        }\n        if (child.isLine === true) {\n          parseLine(child);\n        }\n        if (child.isPoints === true) {\n          parsePoints(child);\n        }\n      });\n      return output;\n    }\n  }]);\n  return OBJExporter;\n}();\nexport { OBJExporter };","map":{"version":3,"names":["Color","Matrix3","Vector2","Vector3","OBJExporter","object","output","indexVertex","indexVertexUvs","indexNormals","vertex","color","normal","uv","face","parseMesh","mesh","nbVertex","nbNormals","nbVertexUvs","geometry","normalMatrixWorld","isBufferGeometry","Error","vertices","getAttribute","normals","uvs","indices","getIndex","name","material","undefined","i","l","count","fromBufferAttribute","applyMatrix4","matrixWorld","x","y","z","getNormalMatrix","applyMatrix3","normalize","m","j","getX","join","parseLine","line","type","k","parsePoints","points","colors","convertLinearToSRGB","r","g","b","traverse","child","isMesh","isLine","isPoints"],"sources":["/home/xkruzel/node_modules/three/examples/jsm/exporters/OBJExporter.js"],"sourcesContent":["import {\n\tColor,\n\tMatrix3,\n\tVector2,\n\tVector3\n} from 'three';\n\nclass OBJExporter {\n\n\tparse( object ) {\n\n\t\tlet output = '';\n\n\t\tlet indexVertex = 0;\n\t\tlet indexVertexUvs = 0;\n\t\tlet indexNormals = 0;\n\n\t\tconst vertex = new Vector3();\n\t\tconst color = new Color();\n\t\tconst normal = new Vector3();\n\t\tconst uv = new Vector2();\n\n\t\tconst face = [];\n\n\t\tfunction parseMesh( mesh ) {\n\n\t\t\tlet nbVertex = 0;\n\t\t\tlet nbNormals = 0;\n\t\t\tlet nbVertexUvs = 0;\n\n\t\t\tconst geometry = mesh.geometry;\n\n\t\t\tconst normalMatrixWorld = new Matrix3();\n\n\t\t\tif ( geometry.isBufferGeometry !== true ) {\n\n\t\t\t\tthrow new Error( 'THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.' );\n\n\t\t\t}\n\n\t\t\t// shortcuts\n\t\t\tconst vertices = geometry.getAttribute( 'position' );\n\t\t\tconst normals = geometry.getAttribute( 'normal' );\n\t\t\tconst uvs = geometry.getAttribute( 'uv' );\n\t\t\tconst indices = geometry.getIndex();\n\n\t\t\t// name of the mesh object\n\t\t\toutput += 'o ' + mesh.name + '\\n';\n\n\t\t\t// name of the mesh material\n\t\t\tif ( mesh.material && mesh.material.name ) {\n\n\t\t\t\toutput += 'usemtl ' + mesh.material.name + '\\n';\n\n\t\t\t}\n\n\t\t\t// vertices\n\n\t\t\tif ( vertices !== undefined ) {\n\n\t\t\t\tfor ( let i = 0, l = vertices.count; i < l; i ++, nbVertex ++ ) {\n\n\t\t\t\t\tvertex.fromBufferAttribute( vertices, i );\n\n\t\t\t\t\t// transform the vertex to world space\n\t\t\t\t\tvertex.applyMatrix4( mesh.matrixWorld );\n\n\t\t\t\t\t// transform the vertex to export format\n\t\t\t\t\toutput += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// uvs\n\n\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\tfor ( let i = 0, l = uvs.count; i < l; i ++, nbVertexUvs ++ ) {\n\n\t\t\t\t\tuv.fromBufferAttribute( uvs, i );\n\n\t\t\t\t\t// transform the uv to export format\n\t\t\t\t\toutput += 'vt ' + uv.x + ' ' + uv.y + '\\n';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// normals\n\n\t\t\tif ( normals !== undefined ) {\n\n\t\t\t\tnormalMatrixWorld.getNormalMatrix( mesh.matrixWorld );\n\n\t\t\t\tfor ( let i = 0, l = normals.count; i < l; i ++, nbNormals ++ ) {\n\n\t\t\t\t\tnormal.fromBufferAttribute( normals, i );\n\n\t\t\t\t\t// transform the normal to world space\n\t\t\t\t\tnormal.applyMatrix3( normalMatrixWorld ).normalize();\n\n\t\t\t\t\t// transform the normal to export format\n\t\t\t\t\toutput += 'vn ' + normal.x + ' ' + normal.y + ' ' + normal.z + '\\n';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// faces\n\n\t\t\tif ( indices !== null ) {\n\n\t\t\t\tfor ( let i = 0, l = indices.count; i < l; i += 3 ) {\n\n\t\t\t\t\tfor ( let m = 0; m < 3; m ++ ) {\n\n\t\t\t\t\t\tconst j = indices.getX( i + m ) + 1;\n\n\t\t\t\t\t\tface[ m ] = ( indexVertex + j ) + ( normals || uvs ? '/' + ( uvs ? ( indexVertexUvs + j ) : '' ) + ( normals ? '/' + ( indexNormals + j ) : '' ) : '' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// transform the face to export format\n\t\t\t\t\toutput += 'f ' + face.join( ' ' ) + '\\n';\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let i = 0, l = vertices.count; i < l; i += 3 ) {\n\n\t\t\t\t\tfor ( let m = 0; m < 3; m ++ ) {\n\n\t\t\t\t\t\tconst j = i + m + 1;\n\n\t\t\t\t\t\tface[ m ] = ( indexVertex + j ) + ( normals || uvs ? '/' + ( uvs ? ( indexVertexUvs + j ) : '' ) + ( normals ? '/' + ( indexNormals + j ) : '' ) : '' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// transform the face to export format\n\t\t\t\t\toutput += 'f ' + face.join( ' ' ) + '\\n';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update index\n\t\t\tindexVertex += nbVertex;\n\t\t\tindexVertexUvs += nbVertexUvs;\n\t\t\tindexNormals += nbNormals;\n\n\t\t}\n\n\t\tfunction parseLine( line ) {\n\n\t\t\tlet nbVertex = 0;\n\n\t\t\tconst geometry = line.geometry;\n\t\t\tconst type = line.type;\n\n\t\t\tif ( geometry.isBufferGeometry !== true ) {\n\n\t\t\t\tthrow new Error( 'THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.' );\n\n\t\t\t}\n\n\t\t\t// shortcuts\n\t\t\tconst vertices = geometry.getAttribute( 'position' );\n\n\t\t\t// name of the line object\n\t\t\toutput += 'o ' + line.name + '\\n';\n\n\t\t\tif ( vertices !== undefined ) {\n\n\t\t\t\tfor ( let i = 0, l = vertices.count; i < l; i ++, nbVertex ++ ) {\n\n\t\t\t\t\tvertex.fromBufferAttribute( vertices, i );\n\n\t\t\t\t\t// transform the vertex to world space\n\t\t\t\t\tvertex.applyMatrix4( line.matrixWorld );\n\n\t\t\t\t\t// transform the vertex to export format\n\t\t\t\t\toutput += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( type === 'Line' ) {\n\n\t\t\t\toutput += 'l ';\n\n\t\t\t\tfor ( let j = 1, l = vertices.count; j <= l; j ++ ) {\n\n\t\t\t\t\toutput += ( indexVertex + j ) + ' ';\n\n\t\t\t\t}\n\n\t\t\t\toutput += '\\n';\n\n\t\t\t}\n\n\t\t\tif ( type === 'LineSegments' ) {\n\n\t\t\t\tfor ( let j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1 ) {\n\n\t\t\t\t\toutput += 'l ' + ( indexVertex + j ) + ' ' + ( indexVertex + k ) + '\\n';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update index\n\t\t\tindexVertex += nbVertex;\n\n\t\t}\n\n\t\tfunction parsePoints( points ) {\n\n\t\t\tlet nbVertex = 0;\n\n\t\t\tconst geometry = points.geometry;\n\n\t\t\tif ( geometry.isBufferGeometry !== true ) {\n\n\t\t\t\tthrow new Error( 'THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.' );\n\n\t\t\t}\n\n\t\t\tconst vertices = geometry.getAttribute( 'position' );\n\t\t\tconst colors = geometry.getAttribute( 'color' );\n\n\t\t\toutput += 'o ' + points.name + '\\n';\n\n\t\t\tif ( vertices !== undefined ) {\n\n\t\t\t\tfor ( let i = 0, l = vertices.count; i < l; i ++, nbVertex ++ ) {\n\n\t\t\t\t\tvertex.fromBufferAttribute( vertices, i );\n\t\t\t\t\tvertex.applyMatrix4( points.matrixWorld );\n\n\t\t\t\t\toutput += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z;\n\n\t\t\t\t\tif ( colors !== undefined ) {\n\n\t\t\t\t\t\tcolor.fromBufferAttribute( colors, i ).convertLinearToSRGB();\n\n\t\t\t\t\t\toutput += ' ' + color.r + ' ' + color.g + ' ' + color.b;\n\n\t\t\t\t\t}\n\n\t\t\t\t\toutput += '\\n';\n\n\t\t\t\t}\n\n\t\t\t\toutput += 'p ';\n\n\t\t\t\tfor ( let j = 1, l = vertices.count; j <= l; j ++ ) {\n\n\t\t\t\t\toutput += ( indexVertex + j ) + ' ';\n\n\t\t\t\t}\n\n\t\t\t\toutput += '\\n';\n\n\t\t\t}\n\n\t\t\t// update index\n\t\t\tindexVertex += nbVertex;\n\n\t\t}\n\n\t\tobject.traverse( function ( child ) {\n\n\t\t\tif ( child.isMesh === true ) {\n\n\t\t\t\tparseMesh( child );\n\n\t\t\t}\n\n\t\t\tif ( child.isLine === true ) {\n\n\t\t\t\tparseLine( child );\n\n\t\t\t}\n\n\t\t\tif ( child.isPoints === true ) {\n\n\t\t\t\tparsePoints( child );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn output;\n\n\t}\n\n}\n\nexport { OBJExporter };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}