{"ast":null,"code":"import { EventDispatcher, Object3D, Raycaster, Vector2 } from 'three';\n/**\n * get variable type\n * @param {*} val a variable which you want to get the type\n * @return {String} variable-type\n */\n\nfunction _rt(val) {\n  return Object.prototype.toString.call(val);\n}\n/**\n * Utils tool box\n *\n * @namespace Utils\n */\n\n\nvar Utils = {\n  /**\n   * determine whether it is a `Function`\n   *\n   * @static\n   * @method\n   * @memberof Utils\n   * @param {*} variable a variable which you want to determine\n   * @return {Boolean} type result\n   */\n  isFunction: function () {\n    var ks = _rt(function () {});\n\n    return function (variable) {\n      return _rt(variable) === ks;\n    };\n  }(),\n\n  /**\n   * determine whether it is a `undefined`\n   *\n   * @static\n   * @method\n   * @memberof Utils\n   * @param {*} variable a variable which you want to determine\n   * @return {Boolean} type result\n   */\n  isUndefined: function isUndefined(variable) {\n    return typeof variable === 'undefined';\n  }\n};\n/**\n * proxy `addEventListener` function\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback\n * @return {this} this\n */\n\nEventDispatcher.prototype.on = function (type, fn) {\n  if (!Utils.isFunction(fn)) return;\n  if (this instanceof Object3D) this.interactive = true;\n  this.addEventListener(type, fn);\n  return this;\n};\n/**\n * proxy `removeEventListener` function\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback, which you had bind before\n * @return {this} this\n */\n\n\nEventDispatcher.prototype.off = function (type, fn) {\n  this.removeEventListener(type, fn);\n  return this;\n};\n/**\n * binding a once event, just emit once time\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback\n * @return {this} this\n */\n\n\nEventDispatcher.prototype.once = function (type, fn) {\n  var _this = this;\n\n  if (!Utils.isFunction(fn)) return;\n\n  var cb = function cb(ev) {\n    fn(ev);\n\n    _this.off(type, cb);\n  };\n\n  this.on(type, cb);\n  return this;\n};\n/**\n * emit a event\n *\n * @param {String} type event type, evnet name\n * @return {this} this\n */\n\n\nEventDispatcher.prototype.emit = function (type) {\n  if (this._listeners === undefined || Utils.isUndefined(this._listeners[type])) return;\n  var cbs = this._listeners[type] || [];\n  var cache = cbs.slice(0);\n\n  for (var _len = arguments.length, argument = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    argument[_key - 1] = arguments[_key];\n  }\n\n  for (var i = 0; i < cache.length; i++) {\n    cache[i].apply(this, argument);\n  }\n\n  return this;\n};\n/**\n * whether displayObject is interactively\n */\n\n\nObject3D.prototype.interactive = false;\n/**\n * whether displayObject's children is interactively\n */\n\nObject3D.prototype.interactiveChildren = true;\n/**\n * whether displayObject had touchstart\n * @private\n */\n\nObject3D.prototype.started = false;\n/**\n * tracked event cache, like: touchend、mouseout、pointerout which decided by primary-event\n */\n\nObject.defineProperty(Object3D.prototype, 'trackedPointers', {\n  get: function get() {\n    if (!this._trackedPointers) this._trackedPointers = {};\n    return this._trackedPointers;\n  }\n});\n/**\n * dispatch a raycast\n *\n * @param {Raycaster} raycaster Raycaster object, get from THREE.Raycaster\n * @return {Object|Boolean} had pass hit-test\n */\n\nObject3D.prototype.raycastTest = function (raycaster) {\n  var result = [];\n  this.raycast(raycaster, result);\n\n  if (result.length > 0) {\n    return result[0];\n  }\n\n  return false;\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar classCallCheck = function classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar inherits = function inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n/**\n * Holds all information related to an Interaction event\n *\n * @class\n */\n\n\nvar InteractionData = function () {\n  /**\n   * InteractionData constructor\n   */\n  function InteractionData() {\n    classCallCheck(this, InteractionData);\n    /**\n     * This point stores the global coords of where the touch/mouse event happened\n     *\n     * @member {Vector2}\n     */\n\n    this.global = new Vector2();\n    /**\n     * The target DisplayObject that was interacted with\n     *\n     * @member {Object3D}\n     */\n\n    this.target = null;\n    /**\n     * When passed to an event handler, this will be the original DOM Event that was captured\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent\n     * @member {MouseEvent|TouchEvent|PointerEvent}\n     */\n\n    this.originalEvent = null;\n    /**\n     * Unique identifier for this interaction\n     *\n     * @member {number}\n     */\n\n    this.identifier = null;\n    /**\n     * Indicates whether or not the pointer device that created the event is the primary pointer.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n     * @type {Boolean}\n     */\n\n    this.isPrimary = false;\n    /**\n     * Indicates which button was pressed on the mouse or pointer device to trigger the event.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n     * @type {number}\n     */\n\n    this.button = 0;\n    /**\n     * Indicates which buttons are pressed on the mouse or pointer device when the event is triggered.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n     * @type {number}\n     */\n\n    this.buttons = 0;\n    /**\n     * The width of the pointer's contact along the x-axis, measured in CSS pixels.\n     * radiusX of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n     * @type {number}\n     */\n\n    this.width = 0;\n    /**\n     * The height of the pointer's contact along the y-axis, measured in CSS pixels.\n     * radiusY of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n     * @type {number}\n     */\n\n    this.height = 0;\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX\n     * @type {number}\n     */\n\n    this.tiltX = 0;\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY\n     * @type {number}\n     */\n\n    this.tiltY = 0;\n    /**\n     * The type of pointer that triggered the event.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType\n     * @type {string}\n     */\n\n    this.pointerType = null;\n    /**\n     * Pressure applied by the pointing device during the event. A Touch's force property\n     * will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure\n     * @type {number}\n     */\n\n    this.pressure = 0;\n    /**\n     * From TouchEvents (not PointerEvents triggered by touches), the rotationAngle of the Touch.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Touch/rotationAngle\n     * @type {number}\n     */\n\n    this.rotationAngle = 0;\n    /**\n     * Twist of a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     * @type {number}\n     */\n\n    this.twist = 0;\n    /**\n     * Barrel pressure on a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     * @type {number}\n     */\n\n    this.tangentialPressure = 0;\n  }\n  /**\n   * The unique identifier of the pointer. It will be the same as `identifier`.\n   * @readonly\n   * @member {number}\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId\n   */\n\n\n  createClass(InteractionData, [{\n    key: '_copyEvent',\n\n    /**\n     * Copies properties from normalized event data.\n     *\n     * @param {Touch|MouseEvent|PointerEvent} event The normalized event data\n     * @private\n     */\n    value: function _copyEvent(event) {\n      // isPrimary should only change on touchstart/pointerdown, so we don't want to overwrite\n      // it with \"false\" on later events when our shim for it on touch events might not be\n      // accurate\n      if (event.isPrimary) {\n        this.isPrimary = true;\n      }\n\n      this.button = event.button;\n      this.buttons = event.buttons;\n      this.width = event.width;\n      this.height = event.height;\n      this.tiltX = event.tiltX;\n      this.tiltY = event.tiltY;\n      this.pointerType = event.pointerType;\n      this.pressure = event.pressure;\n      this.rotationAngle = event.rotationAngle;\n      this.twist = event.twist || 0;\n      this.tangentialPressure = event.tangentialPressure || 0;\n    }\n    /**\n     * Resets the data for pooling.\n     *\n     * @private\n     */\n\n  }, {\n    key: '_reset',\n    value: function _reset() {\n      // isPrimary is the only property that we really need to reset - everything else is\n      // guaranteed to be overwritten\n      this.isPrimary = false;\n    }\n  }, {\n    key: 'pointerId',\n    get: function get$$1() {\n      return this.identifier;\n    }\n  }]);\n  return InteractionData;\n}();\n/**\n * Event class that mimics native DOM events.\n *\n * @class\n */\n\n\nvar InteractionEvent = function () {\n  /**\n   * InteractionEvent constructor\n   */\n  function InteractionEvent() {\n    classCallCheck(this, InteractionEvent);\n    /**\n     * Whether this event will continue propagating in the tree\n     *\n     * @member {boolean}\n     */\n\n    this.stopped = false;\n    /**\n     * The object which caused this event to be dispatched.\n     *\n     * @member {Object3D}\n     */\n\n    this.target = null;\n    /**\n     * The object whose event listener’s callback is currently being invoked.\n     *\n     * @member {Object3D}\n     */\n\n    this.currentTarget = null;\n    /**\n     * Type of the event\n     *\n     * @member {string}\n     */\n\n    this.type = null;\n    /**\n     * InteractionData related to this event\n     *\n     * @member {InteractionData}\n     */\n\n    this.data = null;\n    /**\n     * ray caster detial from 3d-mesh\n     *\n     * @member {Intersects}\n     */\n\n    this.intersects = [];\n  }\n  /**\n   * Prevents event from reaching any objects other than the current object.\n   *\n   */\n\n\n  createClass(InteractionEvent, [{\n    key: \"stopPropagation\",\n    value: function stopPropagation() {\n      this.stopped = true;\n    }\n    /**\n     * Resets the event.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_reset\",\n    value: function _reset() {\n      this.stopped = false;\n      this.currentTarget = null;\n      this.target = null;\n      this.intersects = [];\n    }\n  }]);\n  return InteractionEvent;\n}();\n/**\n * DisplayObjects with the `trackedPointers` property use this class to track interactions\n *\n * @class\n * @private\n */\n\n\nvar InteractionTrackingData = function () {\n  /**\n   * @param {number} pointerId - Unique pointer id of the event\n   */\n  function InteractionTrackingData(pointerId) {\n    classCallCheck(this, InteractionTrackingData);\n    this._pointerId = pointerId;\n    this._flags = InteractionTrackingData.FLAGS.NONE;\n  }\n  /**\n   *\n   * @private\n   * @param {number} flag - The interaction flag to set\n   * @param {boolean} yn - Should the flag be set or unset\n   */\n\n\n  createClass(InteractionTrackingData, [{\n    key: \"_doSet\",\n    value: function _doSet(flag, yn) {\n      if (yn) {\n        this._flags = this._flags | flag;\n      } else {\n        this._flags = this._flags & ~flag;\n      }\n    }\n    /**\n     * Unique pointer id of the event\n     *\n     * @readonly\n     * @member {number}\n     */\n\n  }, {\n    key: \"pointerId\",\n    get: function get$$1() {\n      return this._pointerId;\n    }\n    /**\n     * State of the tracking data, expressed as bit flags\n     *\n     * @member {number}\n     */\n\n  }, {\n    key: \"flags\",\n    get: function get$$1() {\n      return this._flags;\n    }\n    /**\n     * Set the flags for the tracking data\n     *\n     * @param {number} flags - Flags to set\n     */\n    ,\n    set: function set$$1(flags) {\n      this._flags = flags;\n    }\n    /**\n     * Is the tracked event inactive (not over or down)?\n     *\n     * @member {number}\n     */\n\n  }, {\n    key: \"none\",\n    get: function get$$1() {\n      return this._flags === this.constructor.FLAGS.NONE;\n    }\n    /**\n     * Is the tracked event over the DisplayObject?\n     *\n     * @member {boolean}\n     */\n\n  }, {\n    key: \"over\",\n    get: function get$$1() {\n      return (this._flags & this.constructor.FLAGS.OVER) !== 0;\n    }\n    /**\n     * Set the over flag\n     *\n     * @param {boolean} yn - Is the event over?\n     */\n    ,\n    set: function set$$1(yn) {\n      this._doSet(this.constructor.FLAGS.OVER, yn);\n    }\n    /**\n     * Did the right mouse button come down in the DisplayObject?\n     *\n     * @member {boolean}\n     */\n\n  }, {\n    key: \"rightDown\",\n    get: function get$$1() {\n      return (this._flags & this.constructor.FLAGS.RIGHT_DOWN) !== 0;\n    }\n    /**\n     * Set the right down flag\n     *\n     * @param {boolean} yn - Is the right mouse button down?\n     */\n    ,\n    set: function set$$1(yn) {\n      this._doSet(this.constructor.FLAGS.RIGHT_DOWN, yn);\n    }\n    /**\n     * Did the left mouse button come down in the DisplayObject?\n     *\n     * @member {boolean}\n     */\n\n  }, {\n    key: \"leftDown\",\n    get: function get$$1() {\n      return (this._flags & this.constructor.FLAGS.LEFT_DOWN) !== 0;\n    }\n    /**\n     * Set the left down flag\n     *\n     * @param {boolean} yn - Is the left mouse button down?\n     */\n    ,\n    set: function set$$1(yn) {\n      this._doSet(this.constructor.FLAGS.LEFT_DOWN, yn);\n    }\n  }]);\n  return InteractionTrackingData;\n}();\n\nInteractionTrackingData.FLAGS = Object.freeze({\n  NONE: 0,\n  OVER: 1 << 0,\n  LEFT_DOWN: 1 << 1,\n  RIGHT_DOWN: 1 << 2\n});\nvar MOUSE_POINTER_ID = 'MOUSE'; // helpers for hitTest() - only used inside hitTest()\n\nvar hitTestEvent = {\n  target: null,\n  data: {\n    global: null\n  }\n};\n/**\n * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive\n * if its interactive parameter is set to true\n * This manager also supports multitouch.\n *\n * reference to [pixi.js](http://www.pixijs.com/) impl\n *\n * @private\n * @class\n * @extends EventDispatcher\n */\n\nvar InteractionManager = function (_EventDispatcher) {\n  inherits(InteractionManager, _EventDispatcher);\n  /**\n   * @param {WebGLRenderer} renderer - A reference to the current renderer\n   * @param {Scene} scene - A reference to the current scene\n   * @param {Camera} camera - A reference to the current camera\n   * @param {Object} [options] - The options for the manager.\n   * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.\n   * @param {Boolean} [options.autoAttach=true] - Should the manager automatically attach target element.\n   * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.\n   */\n\n  function InteractionManager(renderer, scene, camera, options) {\n    classCallCheck(this, InteractionManager);\n\n    var _this = possibleConstructorReturn(this, (InteractionManager.__proto__ || Object.getPrototypeOf(InteractionManager)).call(this));\n\n    options = options || {};\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {WebGLRenderer}\n     */\n\n    _this.renderer = renderer;\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Scene}\n     */\n\n    _this.scene = scene;\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Camera}\n     */\n\n    _this.camera = camera;\n    /**\n     * Should default browser actions automatically be prevented.\n     * Does not apply to pointer events for backwards compatibility\n     * preventDefault on pointer events stops mouse events from firing\n     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.\n     *\n     * @member {boolean}\n     * @default false\n     */\n\n    _this.autoPreventDefault = options.autoPreventDefault || false;\n    /**\n     * Frequency in milliseconds that the mousemove, moveover & mouseout interaction events will be checked.\n     *\n     * @member {number}\n     * @default 10\n     */\n\n    _this.interactionFrequency = options.interactionFrequency || 10;\n    /**\n     * The mouse data\n     *\n     * @member {InteractionData}\n     */\n\n    _this.mouse = new InteractionData();\n    _this.mouse.identifier = MOUSE_POINTER_ID; // setting the mouse to start off far off screen will mean that mouse over does\n    //  not get called before we even move the mouse.\n\n    _this.mouse.global.set(-999999);\n    /**\n     * Actively tracked InteractionData\n     *\n     * @private\n     * @member {Object.<number,InteractionData>}\n     */\n\n\n    _this.activeInteractionData = {};\n    _this.activeInteractionData[MOUSE_POINTER_ID] = _this.mouse;\n    /**\n     * Pool of unused InteractionData\n     *\n     * @private\n     * @member {InteractionData[]}\n     */\n\n    _this.interactionDataPool = [];\n    /**\n     * An event data object to handle all the event tracking/dispatching\n     *\n     * @member {object}\n     */\n\n    _this.eventData = new InteractionEvent();\n    /**\n     * The DOM element to bind to.\n     *\n     * @private\n     * @member {HTMLElement}\n     */\n\n    _this.interactionDOMElement = null;\n    /**\n     * This property determines if mousemove and touchmove events are fired only when the cursor\n     * is over the object.\n     * Setting to true will make things work more in line with how the DOM verison works.\n     * Setting to false can make things easier for things like dragging\n     * It is currently set to false as this is how three.js used to work.\n     *\n     * @member {boolean}\n     * @default true\n     */\n\n    _this.moveWhenInside = true;\n    /**\n     * Have events been attached to the dom element?\n     *\n     * @private\n     * @member {boolean}\n     */\n\n    _this.eventsAdded = false;\n    /**\n     * Is the mouse hovering over the renderer?\n     *\n     * @private\n     * @member {boolean}\n     */\n\n    _this.mouseOverRenderer = false;\n    /**\n     * Does the device support touch events\n     * https://www.w3.org/TR/touch-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n\n    _this.supportsTouchEvents = 'ontouchstart' in window;\n    /**\n     * Does the device support pointer events\n     * https://www.w3.org/Submission/pointer-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n\n    _this.supportsPointerEvents = !!window.PointerEvent; // this will make it so that you don't have to call bind all the time\n\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onClick = _this.onClick.bind(_this);\n    _this.processClick = _this.processClick.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerUp = _this.onPointerUp.bind(_this);\n    _this.processPointerUp = _this.processPointerUp.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerCancel = _this.onPointerCancel.bind(_this);\n    _this.processPointerCancel = _this.processPointerCancel.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerDown = _this.onPointerDown.bind(_this);\n    _this.processPointerDown = _this.processPointerDown.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerMove = _this.onPointerMove.bind(_this);\n    _this.processPointerMove = _this.processPointerMove.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerOut = _this.onPointerOut.bind(_this);\n    _this.processPointerOverOut = _this.processPointerOverOut.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerOver = _this.onPointerOver.bind(_this);\n    /**\n     * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor\n     * values, objects are handled as dictionaries of CSS values for interactionDOMElement,\n     * and functions are called instead of changing the CSS.\n     * Default CSS cursor values are provided for 'default' and 'pointer' modes.\n     * @member {Object.<string, (string|Function|Object.<string, string>)>}\n     */\n\n    _this.cursorStyles = {\n      default: 'inherit',\n      pointer: 'pointer'\n    };\n    /**\n     * The mode of the cursor that is being used.\n     * The value of this is a key from the cursorStyles dictionary.\n     *\n     * @member {string}\n     */\n\n    _this.currentCursorMode = null;\n    /**\n     * Internal cached let.\n     *\n     * @private\n     * @member {string}\n     */\n\n    _this.cursor = null;\n    /**\n     * ray caster, for survey intersects from 3d-scene\n     *\n     * @private\n     * @member {Raycaster}\n     */\n\n    _this.raycaster = new Raycaster();\n    /**\n     * snippet time\n     *\n     * @private\n     * @member {Number}\n     */\n\n    _this._deltaTime = 0;\n\n    _this.setTargetElement(_this.renderer.domElement);\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display\n     * object.\n     *\n     * @event InteractionManager#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object.\n     *\n     * @event InteractionManager#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object.\n     *\n     * @event InteractionManager#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object.\n     *\n     * @event InteractionManager#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object.\n     *\n     * @event InteractionManager#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object.\n     *\n     * @event InteractionManager#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link InteractionManager#event:mousedown}.\n     *\n     * @event InteractionManager#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link InteractionManager#event:rightdown}.\n     *\n     * @event InteractionManager#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object\n     *\n     * @event InteractionManager#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object\n     *\n     * @event InteractionManager#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object\n     *\n     * @event InteractionManager#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     *\n     * @event InteractionManager#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     *\n     * @event InteractionManager#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event\n     *\n     * @event InteractionManager#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     *\n     * @event InteractionManager#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link InteractionManager#event:pointerdown}.\n     *\n     * @event InteractionManager#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object\n     *\n     * @event InteractionManager#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object\n     *\n     * @event InteractionManager#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object\n     *\n     * @event InteractionManager#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     *\n     * @event InteractionManager#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     *\n     * @event InteractionManager#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch\n     *\n     * @event InteractionManager#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     *\n     * @event InteractionManager#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link InteractionManager#event:touchstart}.\n     *\n     * @event InteractionManager#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     *\n     * @event InteractionManager#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link Object3D#event:mousedown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link Object3D#event:rightdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link Object3D#event:pointerdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link Object3D#event:touchstart}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n\n    return _this;\n  }\n  /**\n   * Hit tests a point against the display tree, returning the first interactive object that is hit.\n   *\n   * @param {Point} globalPoint - A point to hit test with, in global space.\n   * @param {Object3D} [root] - The root display object to start from. If omitted, defaults\n   * to the last rendered root of the associated renderer.\n   * @return {Object3D} The hit display object, if any.\n   */\n\n\n  createClass(InteractionManager, [{\n    key: 'hitTest',\n    value: function hitTest(globalPoint, root) {\n      // clear the target for our hit test\n      hitTestEvent.target = null; // assign the global point\n\n      hitTestEvent.data.global = globalPoint; // ensure safety of the root\n\n      if (!root) {\n        root = this.scene;\n      } // run the hit test\n\n\n      this.processInteractive(hitTestEvent, root, null, true); // return our found object - it'll be null if we didn't hit anything\n\n      return hitTestEvent.target;\n    }\n    /**\n     * Sets the DOM element which will receive mouse/touch events. This is useful for when you have\n     * other DOM elements on top of the renderers Canvas element. With this you'll be bale to deletegate\n     * another DOM element to receive those events.\n     *\n     * @param {HTMLCanvasElement} element - the DOM element which will receive mouse and touch events.\n     */\n\n  }, {\n    key: 'setTargetElement',\n    value: function setTargetElement(element) {\n      this.removeEvents();\n      this.interactionDOMElement = element;\n      this.addEvents();\n    }\n    /**\n     * Registers all the DOM events\n     *\n     * @private\n     */\n\n  }, {\n    key: 'addEvents',\n    value: function addEvents() {\n      if (!this.interactionDOMElement || this.eventsAdded) {\n        return;\n      }\n\n      this.emit('addevents');\n      this.interactionDOMElement.addEventListener('click', this.onClick, true);\n\n      if (window.navigator.msPointerEnabled) {\n        this.interactionDOMElement.style['-ms-content-zooming'] = 'none';\n        this.interactionDOMElement.style['-ms-touch-action'] = 'none';\n      } else if (this.supportsPointerEvents) {\n        this.interactionDOMElement.style['touch-action'] = 'none';\n      }\n      /**\n       * These events are added first, so that if pointer events are normalised, they are fired\n       * in the same order as non-normalised events. ie. pointer event 1st, mouse / touch 2nd\n       */\n\n\n      if (this.supportsPointerEvents) {\n        window.document.addEventListener('pointermove', this.onPointerMove, true);\n        this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, true); // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n        // we already handle those, so for the purposes of what we do in onPointerOut, we only\n        // care about the pointerleave event\n\n        this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, true);\n        this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, true);\n        window.addEventListener('pointercancel', this.onPointerCancel, true);\n        window.addEventListener('pointerup', this.onPointerUp, true);\n      } else {\n        window.document.addEventListener('mousemove', this.onPointerMove, true);\n        this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, true);\n        this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, true);\n        this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, true);\n        window.addEventListener('mouseup', this.onPointerUp, true);\n      } // always look directly for touch events so that we can provide original data\n      // In a future version we should change this to being just a fallback and rely solely on\n      // PointerEvents whenever available\n\n\n      if (this.supportsTouchEvents) {\n        this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, true);\n        this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, true);\n        this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, true);\n        this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, true);\n      }\n\n      this.eventsAdded = true;\n    }\n    /**\n     * Removes all the DOM events that were previously registered\n     *\n     * @private\n     */\n\n  }, {\n    key: 'removeEvents',\n    value: function removeEvents() {\n      if (!this.interactionDOMElement) {\n        return;\n      }\n\n      this.emit('removeevents');\n      this.interactionDOMElement.removeEventListener('click', this.onClick, true);\n\n      if (window.navigator.msPointerEnabled) {\n        this.interactionDOMElement.style['-ms-content-zooming'] = '';\n        this.interactionDOMElement.style['-ms-touch-action'] = '';\n      } else if (this.supportsPointerEvents) {\n        this.interactionDOMElement.style['touch-action'] = '';\n      }\n\n      if (this.supportsPointerEvents) {\n        window.document.removeEventListener('pointermove', this.onPointerMove, true);\n        this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, true);\n        this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, true);\n        this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, true);\n        window.removeEventListener('pointercancel', this.onPointerCancel, true);\n        window.removeEventListener('pointerup', this.onPointerUp, true);\n      } else {\n        window.document.removeEventListener('mousemove', this.onPointerMove, true);\n        this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, true);\n        this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, true);\n        this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, true);\n        window.removeEventListener('mouseup', this.onPointerUp, true);\n      }\n\n      if (this.supportsTouchEvents) {\n        this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, true);\n        this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n        this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, true);\n        this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, true);\n      }\n\n      this.interactionDOMElement = null;\n      this.eventsAdded = false;\n    }\n    /**\n     * Updates the state of interactive objects.\n     * Invoked by a throttled ticker.\n     *\n     * @param {number} deltaTime - time delta since last tick\n     */\n\n  }, {\n    key: 'update',\n    value: function update(_ref) {\n      var snippet = _ref.snippet;\n      this._deltaTime += snippet;\n\n      if (this._deltaTime < this.interactionFrequency) {\n        return;\n      }\n\n      this._deltaTime = 0;\n\n      if (!this.interactionDOMElement) {\n        return;\n      } // if the user move the mouse this check has already been done using the mouse move!\n\n\n      if (this.didMove) {\n        this.didMove = false;\n        return;\n      }\n\n      this.cursor = null; // Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,\n      // but there was a scenario of a display object moving under a static mouse cursor.\n      // In this case, mouseover and mouseevents would not pass the flag test in triggerEvent function\n\n      for (var k in this.activeInteractionData) {\n        // eslint-disable-next-line no-prototype-builtins\n        if (this.activeInteractionData.hasOwnProperty(k)) {\n          var interactionData = this.activeInteractionData[k];\n\n          if (interactionData.originalEvent && interactionData.pointerType !== 'touch') {\n            var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, interactionData.originalEvent, interactionData);\n            this.processInteractive(interactionEvent, this.scene, this.processPointerOverOut, true);\n          }\n        }\n      }\n\n      this.setCursorMode(this.cursor); // TODO\n    }\n    /**\n     * Sets the current cursor mode, handling any callbacks or CSS style changes.\n     *\n     * @param {string} mode - cursor mode, a key from the cursorStyles dictionary\n     */\n\n  }, {\n    key: 'setCursorMode',\n    value: function setCursorMode(mode) {\n      mode = mode || 'default'; // if the mode didn't actually change, bail early\n\n      if (this.currentCursorMode === mode) {\n        return;\n      }\n\n      this.currentCursorMode = mode;\n      var style = this.cursorStyles[mode]; // only do things if there is a cursor style for it\n\n      if (style) {\n        switch (typeof style === 'undefined' ? 'undefined' : _typeof(style)) {\n          case 'string':\n            // string styles are handled as cursor CSS\n            this.interactionDOMElement.style.cursor = style;\n            break;\n\n          case 'function':\n            // functions are just called, and passed the cursor mode\n            style(mode);\n            break;\n\n          case 'object':\n            // if it is an object, assume that it is a dictionary of CSS styles,\n            // apply it to the interactionDOMElement\n            Object.assign(this.interactionDOMElement.style, style);\n            break;\n\n          default:\n            break;\n        }\n      } else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n        // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n        // for the mode, then assume that the dev wants it to be CSS for the cursor.\n        this.interactionDOMElement.style.cursor = mode;\n      }\n    }\n    /**\n     * Dispatches an event on the display object that was interacted with\n     *\n     * @param {Object3D} displayObject - the display object in question\n     * @param {string} eventString - the name of the event (e.g, mousedown)\n     * @param {object} eventData - the event data object\n     * @private\n     */\n\n  }, {\n    key: 'triggerEvent',\n    value: function triggerEvent(displayObject, eventString, eventData) {\n      if (!eventData.stopped) {\n        eventData.currentTarget = displayObject;\n        eventData.type = eventString;\n        displayObject.emit(eventString, eventData);\n\n        if (displayObject[eventString]) {\n          displayObject[eventString](eventData);\n        }\n      }\n    }\n    /**\n     * This function is provides a neat way of crawling through the scene graph and running a\n     * specified function on all interactive objects it finds. It will also take care of hit\n     * testing the interactive objects and passes the hit across in the function.\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - event containing the point that\n     *  is tested for collision\n     * @param {Object3D} displayObject - the displayObject\n     *  that will be hit test (recursively crawls its children)\n     * @param {Function} [func] - the function that will be called on each interactive object. The\n     *  interactionEvent, displayObject and hit will be passed to the function\n     * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point\n     * @param {boolean} [interactive] - Whether the displayObject is interactive\n     * @return {boolean} returns true if the displayObject hit the point\n     */\n\n  }, {\n    key: 'processInteractive',\n    value: function processInteractive(interactionEvent, displayObject, func, hitTest, interactive) {\n      if (!displayObject || !displayObject.visible) {\n        return false;\n      } // Took a little while to rework this function correctly! But now it is done and nice and optimised. ^_^\n      //\n      // This function will now loop through all objects and then only hit test the objects it HAS\n      // to, not all of them. MUCH faster..\n      // An object will be hit test if the following is true:\n      //\n      // 1: It is interactive.\n      // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.\n      //\n      // As another little optimisation once an interactive object has been hit we can carry on\n      // through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests\n      // A final optimisation is that an object is not hit test directly if a child has already been hit.\n\n\n      interactive = displayObject.interactive || interactive;\n      var hit = false;\n      var interactiveParent = interactive;\n\n      if (displayObject.interactiveChildren && displayObject.children) {\n        var children = displayObject.children;\n\n        for (var i = children.length - 1; i >= 0; i--) {\n          var child = children[i]; // time to get recursive.. if this function will return if something is hit..\n\n          var childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent);\n\n          if (childHit) {\n            // its a good idea to check if a child has lost its parent.\n            // this means it has been removed whilst looping so its best\n            if (!child.parent) {\n              continue;\n            } // we no longer need to hit test any more objects in this container as we we\n            // now know the parent has been hit\n\n\n            interactiveParent = false; // If the child is interactive , that means that the object hit was actually\n            // interactive and not just the child of an interactive object.\n            // This means we no longer need to hit test anything else. We still need to run\n            // through all objects, but we don't need to perform any hit tests.\n\n            if (childHit) {\n              if (interactionEvent.target) {\n                hitTest = false;\n              }\n\n              hit = true;\n            }\n          }\n        }\n      } // no point running this if the item is not interactive or does not have an interactive parent.\n\n\n      if (interactive) {\n        // if we are hit testing (as in we have no hit any objects yet)\n        // We also don't need to worry about hit testing if once of the displayObjects children\n        // has already been hit - but only if it was interactive, otherwise we need to keep\n        // looking for an interactive child, just in case we hit one\n        if (hitTest && !interactionEvent.target) {\n          if (interactionEvent.intersects[0] && interactionEvent.intersects[0].object === displayObject) {\n            hit = true;\n          }\n        }\n\n        if (displayObject.interactive) {\n          if (hit && !interactionEvent.target) {\n            interactionEvent.data.target = interactionEvent.target = displayObject;\n          }\n\n          if (func) {\n            func(interactionEvent, displayObject, !!hit);\n          }\n        }\n      }\n\n      return hit;\n    }\n    /**\n     * Is called when the click is pressed down on the renderer element\n     *\n     * @private\n     * @param {MouseEvent} originalEvent - The DOM event of a click being pressed down\n     */\n\n  }, {\n    key: 'onClick',\n    value: function onClick(originalEvent) {\n      if (originalEvent.type !== 'click') return;\n      var events = this.normalizeToPointerData(originalEvent);\n\n      if (this.autoPreventDefault && events[0].isNormalized) {\n        originalEvent.preventDefault();\n      }\n\n      var interactionData = this.getInteractionDataForPointerId(events[0]);\n      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, events[0], interactionData);\n      interactionEvent.data.originalEvent = originalEvent;\n      this.processInteractive(interactionEvent, this.scene, this.processClick, true);\n      this.emit('click', interactionEvent);\n    }\n    /**\n     * Processes the result of the click check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     * @param {boolean} hit - the result of the hit test on the display object\n     */\n\n  }, {\n    key: 'processClick',\n    value: function processClick(interactionEvent, displayObject, hit) {\n      if (hit) {\n        this.triggerEvent(displayObject, 'click', interactionEvent);\n      }\n    }\n    /**\n     * Is called when the pointer button is pressed down on the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being pressed down\n     */\n\n  }, {\n    key: 'onPointerDown',\n    value: function onPointerDown(originalEvent) {\n      // if we support touch events, then only use those for touch events, not pointer events\n      if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n      var events = this.normalizeToPointerData(originalEvent);\n      /**\n       * No need to prevent default on natural pointer events, as there are no side effects\n       * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n       * so still need to be prevented.\n       */\n      // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n      if (this.autoPreventDefault && events[0].isNormalized) {\n        originalEvent.preventDefault();\n      }\n\n      var eventLen = events.length;\n\n      for (var i = 0; i < eventLen; i++) {\n        var event = events[i];\n        var interactionData = this.getInteractionDataForPointerId(event);\n        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n        interactionEvent.data.originalEvent = originalEvent;\n        this.processInteractive(interactionEvent, this.scene, this.processPointerDown, true);\n        this.emit('pointerdown', interactionEvent);\n\n        if (event.pointerType === 'touch') {\n          this.emit('touchstart', interactionEvent);\n        } else if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n          var isRightButton = event.button === 2;\n          this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData);\n        }\n      }\n    }\n    /**\n     * Processes the result of the pointer down check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     * @param {boolean} hit - the result of the hit test on the display object\n     */\n\n  }, {\n    key: 'processPointerDown',\n    value: function processPointerDown(interactionEvent, displayObject, hit) {\n      var data = interactionEvent.data;\n      var id = interactionEvent.data.identifier;\n\n      if (hit) {\n        if (!displayObject.trackedPointers[id]) {\n          displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n        }\n\n        this.triggerEvent(displayObject, 'pointerdown', interactionEvent);\n\n        if (data.pointerType === 'touch') {\n          displayObject.started = true;\n          this.triggerEvent(displayObject, 'touchstart', interactionEvent);\n        } else if (data.pointerType === 'mouse' || data.pointerType === 'pen') {\n          var isRightButton = data.button === 2;\n\n          if (isRightButton) {\n            displayObject.trackedPointers[id].rightDown = true;\n          } else {\n            displayObject.trackedPointers[id].leftDown = true;\n          }\n\n          this.triggerEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent);\n        }\n      }\n    }\n    /**\n     * Is called when the pointer button is released on the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being released\n     * @param {boolean} cancelled - true if the pointer is cancelled\n     * @param {Function} func - Function passed to {@link processInteractive}\n     */\n\n  }, {\n    key: 'onPointerComplete',\n    value: function onPointerComplete(originalEvent, cancelled, func) {\n      var events = this.normalizeToPointerData(originalEvent);\n      var eventLen = events.length; // if the event wasn't targeting our canvas, then consider it to be pointerupoutside\n      // in all cases (unless it was a pointercancel)\n\n      var eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';\n\n      for (var i = 0; i < eventLen; i++) {\n        var event = events[i];\n        var interactionData = this.getInteractionDataForPointerId(event);\n        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n        interactionEvent.data.originalEvent = originalEvent; // perform hit testing for events targeting our canvas or cancel events\n\n        this.processInteractive(interactionEvent, this.scene, func, cancelled || !eventAppend);\n        this.emit(cancelled ? 'pointercancel' : 'pointerup' + eventAppend, interactionEvent);\n\n        if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n          var isRightButton = event.button === 2;\n          this.emit(isRightButton ? 'rightup' + eventAppend : 'mouseup' + eventAppend, interactionEvent);\n        } else if (event.pointerType === 'touch') {\n          this.emit(cancelled ? 'touchcancel' : 'touchend' + eventAppend, interactionEvent);\n          this.releaseInteractionDataForPointerId(event.pointerId, interactionData);\n        }\n      }\n    }\n    /**\n     * Is called when the pointer button is cancelled\n     *\n     * @private\n     * @param {PointerEvent} event - The DOM event of a pointer button being released\n     */\n\n  }, {\n    key: 'onPointerCancel',\n    value: function onPointerCancel(event) {\n      // if we support touch events, then only use those for touch events, not pointer events\n      if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n      this.onPointerComplete(event, true, this.processPointerCancel);\n    }\n    /**\n     * Processes the result of the pointer cancel check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     */\n\n  }, {\n    key: 'processPointerCancel',\n    value: function processPointerCancel(interactionEvent, displayObject) {\n      var data = interactionEvent.data;\n      var id = interactionEvent.data.identifier;\n\n      if (displayObject.trackedPointers[id] !== undefined) {\n        delete displayObject.trackedPointers[id];\n        this.triggerEvent(displayObject, 'pointercancel', interactionEvent);\n\n        if (data.pointerType === 'touch') {\n          this.triggerEvent(displayObject, 'touchcancel', interactionEvent);\n        }\n      }\n    }\n    /**\n     * Is called when the pointer button is released on the renderer element\n     *\n     * @private\n     * @param {PointerEvent} event - The DOM event of a pointer button being released\n     */\n\n  }, {\n    key: 'onPointerUp',\n    value: function onPointerUp(event) {\n      // if we support touch events, then only use those for touch events, not pointer events\n      if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n      this.onPointerComplete(event, false, this.processPointerUp);\n    }\n    /**\n     * Processes the result of the pointer up check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     * @param {boolean} hit - the result of the hit test on the display object\n     */\n\n  }, {\n    key: 'processPointerUp',\n    value: function processPointerUp(interactionEvent, displayObject, hit) {\n      var data = interactionEvent.data;\n      var id = interactionEvent.data.identifier;\n      var trackingData = displayObject.trackedPointers[id];\n      var isTouch = data.pointerType === 'touch';\n      var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen'; // Mouse only\n\n      if (isMouse) {\n        var isRightButton = data.button === 2;\n        var flags = InteractionTrackingData.FLAGS;\n        var test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;\n        var isDown = trackingData !== undefined && trackingData.flags & test;\n\n        if (hit) {\n          this.triggerEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent);\n\n          if (isDown) {\n            this.triggerEvent(displayObject, isRightButton ? 'rightclick' : 'leftclick', interactionEvent);\n          }\n        } else if (isDown) {\n          this.triggerEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent);\n        } // update the down state of the tracking data\n\n\n        if (trackingData) {\n          if (isRightButton) {\n            trackingData.rightDown = false;\n          } else {\n            trackingData.leftDown = false;\n          }\n        }\n      } // Pointers and Touches, and Mouse\n\n\n      if (isTouch && displayObject.started) {\n        displayObject.started = false;\n        this.triggerEvent(displayObject, 'touchend', interactionEvent);\n      }\n\n      if (hit) {\n        this.triggerEvent(displayObject, 'pointerup', interactionEvent);\n\n        if (trackingData) {\n          this.triggerEvent(displayObject, 'pointertap', interactionEvent);\n\n          if (isTouch) {\n            this.triggerEvent(displayObject, 'tap', interactionEvent); // touches are no longer over (if they ever were) when we get the touchend\n            // so we should ensure that we don't keep pretending that they are\n\n            trackingData.over = false;\n          }\n        }\n      } else if (trackingData) {\n        this.triggerEvent(displayObject, 'pointerupoutside', interactionEvent);\n        if (isTouch) this.triggerEvent(displayObject, 'touchendoutside', interactionEvent);\n      } // Only remove the tracking data if there is no over/down state still associated with it\n\n\n      if (trackingData && trackingData.none) {\n        delete displayObject.trackedPointers[id];\n      }\n    }\n    /**\n     * Is called when the pointer moves across the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer moving\n     */\n\n  }, {\n    key: 'onPointerMove',\n    value: function onPointerMove(originalEvent) {\n      // if we support touch events, then only use those for touch events, not pointer events\n      if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n      var events = this.normalizeToPointerData(originalEvent);\n\n      if (events[0].pointerType === 'mouse') {\n        this.didMove = true;\n        this.cursor = null;\n      }\n\n      var eventLen = events.length;\n\n      for (var i = 0; i < eventLen; i++) {\n        var event = events[i];\n        var interactionData = this.getInteractionDataForPointerId(event);\n        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n        interactionEvent.data.originalEvent = originalEvent;\n        var interactive = event.pointerType === 'touch' ? this.moveWhenInside : true;\n        this.processInteractive(interactionEvent, this.scene, this.processPointerMove, interactive);\n        this.emit('pointermove', interactionEvent);\n        if (event.pointerType === 'touch') this.emit('touchmove', interactionEvent);\n        if (event.pointerType === 'mouse' || event.pointerType === 'pen') this.emit('mousemove', interactionEvent);\n      }\n\n      if (events[0].pointerType === 'mouse') {\n        this.setCursorMode(this.cursor); // TODO BUG for parents interactive object (border order issue)\n      }\n    }\n    /**\n     * Processes the result of the pointer move check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     * @param {boolean} hit - the result of the hit test on the display object\n     */\n\n  }, {\n    key: 'processPointerMove',\n    value: function processPointerMove(interactionEvent, displayObject, hit) {\n      var data = interactionEvent.data;\n      var isTouch = data.pointerType === 'touch';\n      var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';\n\n      if (isMouse) {\n        this.processPointerOverOut(interactionEvent, displayObject, hit);\n      }\n\n      if (isTouch && displayObject.started) this.triggerEvent(displayObject, 'touchmove', interactionEvent);\n\n      if (!this.moveWhenInside || hit) {\n        this.triggerEvent(displayObject, 'pointermove', interactionEvent);\n        if (isMouse) this.triggerEvent(displayObject, 'mousemove', interactionEvent);\n      }\n    }\n    /**\n     * Is called when the pointer is moved out of the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out\n     */\n\n  }, {\n    key: 'onPointerOut',\n    value: function onPointerOut(originalEvent) {\n      // if we support touch events, then only use those for touch events, not pointer events\n      if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n      var events = this.normalizeToPointerData(originalEvent); // Only mouse and pointer can call onPointerOut, so events will always be length 1\n\n      var event = events[0];\n\n      if (event.pointerType === 'mouse') {\n        this.mouseOverRenderer = false;\n        this.setCursorMode(null);\n      }\n\n      var interactionData = this.getInteractionDataForPointerId(event);\n      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n      interactionEvent.data.originalEvent = event;\n      this.processInteractive(interactionEvent, this.scene, this.processPointerOverOut, false);\n      this.emit('pointerout', interactionEvent);\n\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        this.emit('mouseout', interactionEvent);\n      } else {\n        // we can get touchleave events after touchend, so we want to make sure we don't\n        // introduce memory leaks\n        this.releaseInteractionDataForPointerId(interactionData.identifier);\n      }\n    }\n    /**\n     * Processes the result of the pointer over/out check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     * @param {boolean} hit - the result of the hit test on the display object\n     */\n\n  }, {\n    key: 'processPointerOverOut',\n    value: function processPointerOverOut(interactionEvent, displayObject, hit) {\n      var data = interactionEvent.data;\n      var id = interactionEvent.data.identifier;\n      var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';\n      var trackingData = displayObject.trackedPointers[id]; // if we just moused over the display object, then we need to track that state\n\n      if (hit && !trackingData) {\n        trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n      }\n\n      if (trackingData === undefined) return;\n\n      if (hit && this.mouseOverRenderer) {\n        if (!trackingData.over) {\n          trackingData.over = true;\n          this.triggerEvent(displayObject, 'pointerover', interactionEvent);\n\n          if (isMouse) {\n            this.triggerEvent(displayObject, 'mouseover', interactionEvent);\n          }\n        } // only change the cursor if it has not already been changed (by something deeper in the\n        // display tree)\n\n\n        if (isMouse && this.cursor === null) {\n          this.cursor = displayObject.cursor;\n        }\n      } else if (trackingData.over) {\n        trackingData.over = false;\n        this.triggerEvent(displayObject, 'pointerout', this.eventData);\n\n        if (isMouse) {\n          this.triggerEvent(displayObject, 'mouseout', interactionEvent);\n        } // if there is no mouse down information for the pointer, then it is safe to delete\n\n\n        if (trackingData.none) {\n          delete displayObject.trackedPointers[id];\n        }\n      }\n    }\n    /**\n     * Is called when the pointer is moved into the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being moved into the renderer view\n     */\n\n  }, {\n    key: 'onPointerOver',\n    value: function onPointerOver(originalEvent) {\n      var events = this.normalizeToPointerData(originalEvent); // Only mouse and pointer can call onPointerOver, so events will always be length 1\n\n      var event = events[0];\n      var interactionData = this.getInteractionDataForPointerId(event);\n      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n      interactionEvent.data.originalEvent = event;\n\n      if (event.pointerType === 'mouse') {\n        this.mouseOverRenderer = true;\n      }\n\n      this.emit('pointerover', interactionEvent);\n\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        this.emit('mouseover', interactionEvent);\n      }\n    }\n    /**\n     * Get InteractionData for a given pointerId. Store that data as well\n     *\n     * @private\n     * @param {PointerEvent} event - Normalized pointer event, output from normalizeToPointerData\n     * @return {InteractionData} - Interaction data for the given pointer identifier\n     */\n\n  }, {\n    key: 'getInteractionDataForPointerId',\n    value: function getInteractionDataForPointerId(event) {\n      var pointerId = event.pointerId;\n      var interactionData = void 0;\n\n      if (pointerId === MOUSE_POINTER_ID || event.pointerType === 'mouse') {\n        interactionData = this.mouse;\n      } else if (this.activeInteractionData[pointerId]) {\n        interactionData = this.activeInteractionData[pointerId];\n      } else {\n        interactionData = this.interactionDataPool.pop() || new InteractionData();\n        interactionData.identifier = pointerId;\n        this.activeInteractionData[pointerId] = interactionData;\n      } // copy properties from the event, so that we can make sure that touch/pointer specific\n      // data is available\n\n\n      interactionData._copyEvent(event);\n\n      return interactionData;\n    }\n    /**\n     * Return unused InteractionData to the pool, for a given pointerId\n     *\n     * @private\n     * @param {number} pointerId - Identifier from a pointer event\n     */\n\n  }, {\n    key: 'releaseInteractionDataForPointerId',\n    value: function releaseInteractionDataForPointerId(pointerId) {\n      var interactionData = this.activeInteractionData[pointerId];\n\n      if (interactionData) {\n        delete this.activeInteractionData[pointerId];\n\n        interactionData._reset();\n\n        this.interactionDataPool.push(interactionData);\n      }\n    }\n    /**\n     * Maps x and y coords from a DOM object and maps them correctly to the three.js view. The\n     * resulting value is stored in the point. This takes into account the fact that the DOM\n     * element could be scaled and positioned anywhere on the screen.\n     *\n     * @param  {Vector2} point - the point that the result will be stored in\n     * @param  {number} x - the x coord of the position to map\n     * @param  {number} y - the y coord of the position to map\n     */\n\n  }, {\n    key: 'mapPositionToPoint',\n    value: function mapPositionToPoint(point, x, y) {\n      var rect = void 0; // IE 11 fix\n\n      if (!this.interactionDOMElement.parentElement) {\n        rect = {\n          x: 0,\n          y: 0,\n          left: 0,\n          top: 0,\n          width: 0,\n          height: 0\n        };\n      } else {\n        rect = this.interactionDOMElement.getBoundingClientRect();\n      }\n\n      point.x = (x - rect.left) / rect.width * 2 - 1;\n      point.y = -((y - rect.top) / rect.height) * 2 + 1;\n    }\n    /**\n     * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The event to be configured\n     * @param {PointerEvent} pointerEvent - The DOM event that will be paired with the InteractionEvent\n     * @param {InteractionData} interactionData - The InteractionData that will be paired\n     *        with the InteractionEvent\n     * @return {InteractionEvent} the interaction event that was passed in\n     */\n\n  }, {\n    key: 'configureInteractionEventForDOMEvent',\n    value: function configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {\n      interactionEvent.data = interactionData;\n      this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);\n      this.raycaster.setFromCamera(interactionData.global, this.camera); // Not really sure why this is happening, but it's how a previous version handled things TODO: there should be remove\n\n      if (pointerEvent.pointerType === 'touch') {\n        pointerEvent.globalX = interactionData.global.x;\n        pointerEvent.globalY = interactionData.global.y;\n      }\n\n      interactionData.originalEvent = pointerEvent;\n\n      interactionEvent._reset();\n\n      interactionEvent.intersects = this.raycaster.intersectObjects(this.scene.children, true);\n      return interactionEvent;\n    }\n    /**\n     * Ensures that the original event object contains all data that a regular pointer event would have\n     *\n     * @private\n     * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event\n     * @return {PointerEvent[]} An array containing a single normalized pointer event, in the case of a pointer\n     *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n     */\n\n  }, {\n    key: 'normalizeToPointerData',\n    value: function normalizeToPointerData(event) {\n      var normalizedEvents = [];\n\n      if (this.supportsTouchEvents && event instanceof TouchEvent) {\n        for (var i = 0, li = event.changedTouches.length; i < li; i++) {\n          var touch = event.changedTouches[i];\n          if (typeof touch.button === 'undefined') touch.button = event.touches.length ? 1 : 0;\n          if (typeof touch.buttons === 'undefined') touch.buttons = event.touches.length ? 1 : 0;\n\n          if (typeof touch.isPrimary === 'undefined') {\n            touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n          }\n\n          if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n          if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n          if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n          if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n          if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n          if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n          if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n          touch.twist = 0;\n          touch.tangentialPressure = 0; // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n          // support, and the fill ins are not quite the same\n          // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n          // left is not 0,0 on the page\n\n          if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n          if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY; // mark the touch as normalized, just so that we know we did it\n\n          touch.isNormalized = true;\n          normalizedEvents.push(touch);\n        }\n      } else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent))) {\n        if (typeof event.isPrimary === 'undefined') event.isPrimary = true;\n        if (typeof event.width === 'undefined') event.width = 1;\n        if (typeof event.height === 'undefined') event.height = 1;\n        if (typeof event.tiltX === 'undefined') event.tiltX = 0;\n        if (typeof event.tiltY === 'undefined') event.tiltY = 0;\n        if (typeof event.pointerType === 'undefined') event.pointerType = 'mouse';\n        if (typeof event.pointerId === 'undefined') event.pointerId = MOUSE_POINTER_ID;\n        if (typeof event.pressure === 'undefined') event.pressure = 0.5;\n        event.twist = 0;\n        event.tangentialPressure = 0; // mark the mouse event as normalized, just so that we know we did it\n\n        event.isNormalized = true;\n        normalizedEvents.push(event);\n      } else {\n        normalizedEvents.push(event);\n      }\n\n      return normalizedEvents;\n    }\n    /**\n     * Destroys the interaction manager\n     *\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this.removeEvents();\n      this.removeAllListeners();\n      this.renderer = null;\n      this.mouse = null;\n      this.eventData = null;\n      this.interactionDOMElement = null;\n      this.onPointerDown = null;\n      this.processPointerDown = null;\n      this.onPointerUp = null;\n      this.processPointerUp = null;\n      this.onPointerCancel = null;\n      this.processPointerCancel = null;\n      this.onPointerMove = null;\n      this.processPointerMove = null;\n      this.onPointerOut = null;\n      this.processPointerOverOut = null;\n      this.onPointerOver = null;\n      this._tempPoint = null;\n    }\n  }]);\n  return InteractionManager;\n}(EventDispatcher);\n\nvar MOUSE_POINTER_ID$1 = 'MOUSE'; // helpers for hitTest() - only used inside hitTest()\n\nvar hitTestEvent$1 = {\n  target: null,\n  data: {\n    global: null\n  }\n};\n/**\n * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive\n * if its interactive parameter is set to true\n * This manager also supports multitouch.\n *\n * reference to [pixi.js](http://www.pixijs.com/) impl\n *\n * @private\n * @class\n * @extends EventDispatcher\n */\n\nvar InteractionLayer = function (_EventDispatcher) {\n  inherits(InteractionLayer, _EventDispatcher);\n  /**\n   * @param {WebGLRenderer} renderer - A reference to the current renderer\n   * @param {Object} [options] - The options for the manager.\n   * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.\n   * @param {Boolean} [options.autoAttach=true] - Should the manager automatically attach target element.\n   * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.\n   */\n\n  function InteractionLayer(renderer, options) {\n    classCallCheck(this, InteractionLayer);\n\n    var _this = possibleConstructorReturn(this, (InteractionLayer.__proto__ || Object.getPrototypeOf(InteractionLayer)).call(this));\n\n    options = options || {};\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {WebGLRenderer}\n     */\n\n    _this.renderer = renderer;\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Layer}\n     */\n\n    _this.layer = null;\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Scene}\n     */\n    // this.scene = scene;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Camera}\n     */\n    // this.camera = camera;\n\n    /**\n     * Should default browser actions automatically be prevented.\n     * Does not apply to pointer events for backwards compatibility\n     * preventDefault on pointer events stops mouse events from firing\n     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.\n     *\n     * @member {boolean}\n     * @default false\n     */\n\n    _this.autoPreventDefault = options.autoPreventDefault || false;\n    /**\n     * Frequency in milliseconds that the mousemove, moveover & mouseout interaction events will be checked.\n     *\n     * @member {number}\n     * @default 10\n     */\n\n    _this.interactionFrequency = options.interactionFrequency || 10;\n    /**\n     * The mouse data\n     *\n     * @member {InteractionData}\n     */\n\n    _this.mouse = new InteractionData();\n    _this.mouse.identifier = MOUSE_POINTER_ID$1; // setting the mouse to start off far off screen will mean that mouse over does\n    //  not get called before we even move the mouse.\n\n    _this.mouse.global.set(-999999);\n    /**\n     * Actively tracked InteractionData\n     *\n     * @private\n     * @member {Object.<number,InteractionData>}\n     */\n\n\n    _this.activeInteractionData = {};\n    _this.activeInteractionData[MOUSE_POINTER_ID$1] = _this.mouse;\n    /**\n     * Pool of unused InteractionData\n     *\n     * @private\n     * @member {InteractionData[]}\n     */\n\n    _this.interactionDataPool = [];\n    /**\n     * An event data object to handle all the event tracking/dispatching\n     *\n     * @member {object}\n     */\n\n    _this.eventData = new InteractionEvent();\n    /**\n     * The DOM element to bind to.\n     *\n     * @private\n     * @member {HTMLElement}\n     */\n\n    _this.interactionDOMElement = null;\n    /**\n     * This property determines if mousemove and touchmove events are fired only when the cursor\n     * is over the object.\n     * Setting to true will make things work more in line with how the DOM verison works.\n     * Setting to false can make things easier for things like dragging\n     * It is currently set to false as this is how three.js used to work.\n     *\n     * @member {boolean}\n     * @default true\n     */\n\n    _this.moveWhenInside = true;\n    /**\n     * Have events been attached to the dom element?\n     *\n     * @private\n     * @member {boolean}\n     */\n\n    _this.eventsAdded = false;\n    /**\n     * Is the mouse hovering over the renderer?\n     *\n     * @private\n     * @member {boolean}\n     */\n\n    _this.mouseOverRenderer = false;\n    /**\n     * Does the device support touch events\n     * https://www.w3.org/TR/touch-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n\n    _this.supportsTouchEvents = 'ontouchstart' in window;\n    /**\n     * Does the device support pointer events\n     * https://www.w3.org/Submission/pointer-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n\n    _this.supportsPointerEvents = !!window.PointerEvent; // this will make it so that you don't have to call bind all the time\n\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onClick = _this.onClick.bind(_this);\n    _this.processClick = _this.processClick.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerUp = _this.onPointerUp.bind(_this);\n    _this.processPointerUp = _this.processPointerUp.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerCancel = _this.onPointerCancel.bind(_this);\n    _this.processPointerCancel = _this.processPointerCancel.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerDown = _this.onPointerDown.bind(_this);\n    _this.processPointerDown = _this.processPointerDown.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerMove = _this.onPointerMove.bind(_this);\n    _this.processPointerMove = _this.processPointerMove.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerOut = _this.onPointerOut.bind(_this);\n    _this.processPointerOverOut = _this.processPointerOverOut.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerOver = _this.onPointerOver.bind(_this);\n    /**\n     * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor\n     * values, objects are handled as dictionaries of CSS values for interactionDOMElement,\n     * and functions are called instead of changing the CSS.\n     * Default CSS cursor values are provided for 'default' and 'pointer' modes.\n     * @member {Object.<string, (string|Function|Object.<string, string>)>}\n     */\n\n    _this.cursorStyles = {\n      default: 'inherit',\n      pointer: 'pointer'\n    };\n    /**\n     * The mode of the cursor that is being used.\n     * The value of this is a key from the cursorStyles dictionary.\n     *\n     * @member {string}\n     */\n\n    _this.currentCursorMode = null;\n    /**\n     * Internal cached let.\n     *\n     * @private\n     * @member {string}\n     */\n\n    _this.cursor = null;\n    /**\n     * ray caster, for survey intersects from 3d-scene\n     *\n     * @private\n     * @member {Raycaster}\n     */\n\n    _this.raycaster = new Raycaster();\n    /**\n     * snippet time\n     *\n     * @private\n     * @member {Number}\n     */\n\n    _this._deltaTime = 0;\n\n    _this.setTargetElement(_this.renderer.domElement);\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display\n     * object.\n     *\n     * @event InteractionLayer#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object.\n     *\n     * @event InteractionLayer#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object.\n     *\n     * @event InteractionLayer#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object.\n     *\n     * @event InteractionLayer#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object.\n     *\n     * @event InteractionLayer#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object.\n     *\n     * @event InteractionLayer#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link InteractionLayer#event:mousedown}.\n     *\n     * @event InteractionLayer#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link InteractionLayer#event:rightdown}.\n     *\n     * @event InteractionLayer#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object\n     *\n     * @event InteractionLayer#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object\n     *\n     * @event InteractionLayer#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object\n     *\n     * @event InteractionLayer#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     *\n     * @event InteractionLayer#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     *\n     * @event InteractionLayer#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event\n     *\n     * @event InteractionLayer#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     *\n     * @event InteractionLayer#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link InteractionLayer#event:pointerdown}.\n     *\n     * @event InteractionLayer#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object\n     *\n     * @event InteractionLayer#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object\n     *\n     * @event InteractionLayer#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object\n     *\n     * @event InteractionLayer#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     *\n     * @event InteractionLayer#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     *\n     * @event InteractionLayer#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch\n     *\n     * @event InteractionLayer#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     *\n     * @event InteractionLayer#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link InteractionLayer#event:touchstart}.\n     *\n     * @event InteractionLayer#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     *\n     * @event InteractionLayer#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link Object3D#event:mousedown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link Object3D#event:rightdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link Object3D#event:pointerdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link Object3D#event:touchstart}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n\n    return _this;\n  }\n  /**\n   * @return {boolean}\n   */\n\n\n  createClass(InteractionLayer, [{\n    key: 'isAble',\n    value: function isAble() {\n      return this.layer && this.layer.interactive;\n    }\n    /**\n     * set layer\n     * @param {Layer} layer layer\n     */\n\n  }, {\n    key: 'setLayer',\n    value: function setLayer(layer) {\n      this.layer = layer;\n    }\n    /**\n     * Hit tests a point against the display tree, returning the first interactive object that is hit.\n     *\n     * @param {Point} globalPoint - A point to hit test with, in global space.\n     * @param {Object3D} [root] - The root display object to start from. If omitted, defaults\n     * to the last rendered root of the associated renderer.\n     * @return {Object3D} The hit display object, if any.\n     */\n\n  }, {\n    key: 'hitTest',\n    value: function hitTest(globalPoint, root) {\n      if (!this.isAble()) return null; // clear the target for our hit test\n\n      hitTestEvent$1.target = null; // assign the global point\n\n      hitTestEvent$1.data.global = globalPoint; // ensure safety of the root\n\n      if (!root) {\n        root = this.layer.scene;\n      } // run the hit test\n\n\n      this.processInteractive(hitTestEvent$1, root, null, true); // return our found object - it'll be null if we didn't hit anything\n\n      return hitTestEvent$1.target;\n    }\n    /**\n     * Sets the DOM element which will receive mouse/touch events. This is useful for when you have\n     * other DOM elements on top of the renderers Canvas element. With this you'll be bale to deletegate\n     * another DOM element to receive those events.\n     *\n     * @param {HTMLCanvasElement} element - the DOM element which will receive mouse and touch events.\n     */\n\n  }, {\n    key: 'setTargetElement',\n    value: function setTargetElement(element) {\n      this.removeEvents();\n      this.interactionDOMElement = element;\n      this.addEvents();\n    }\n    /**\n     * Registers all the DOM events\n     *\n     * @private\n     */\n\n  }, {\n    key: 'addEvents',\n    value: function addEvents() {\n      if (!this.interactionDOMElement || this.eventsAdded) {\n        return;\n      }\n\n      this.emit('addevents');\n      this.interactionDOMElement.addEventListener('click', this.onClick, true);\n\n      if (window.navigator.msPointerEnabled) {\n        this.interactionDOMElement.style['-ms-content-zooming'] = 'none';\n        this.interactionDOMElement.style['-ms-touch-action'] = 'none';\n      } else if (this.supportsPointerEvents) {\n        this.interactionDOMElement.style['touch-action'] = 'none';\n      }\n      /**\n       * These events are added first, so that if pointer events are normalised, they are fired\n       * in the same order as non-normalised events. ie. pointer event 1st, mouse / touch 2nd\n       */\n\n\n      if (this.supportsPointerEvents) {\n        window.document.addEventListener('pointermove', this.onPointerMove, true);\n        this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, true); // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n        // we already handle those, so for the purposes of what we do in onPointerOut, we only\n        // care about the pointerleave event\n\n        this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, true);\n        this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, true);\n        window.addEventListener('pointercancel', this.onPointerCancel, true);\n        window.addEventListener('pointerup', this.onPointerUp, true);\n      } else {\n        window.document.addEventListener('mousemove', this.onPointerMove, true);\n        this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, true);\n        this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, true);\n        this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, true);\n        window.addEventListener('mouseup', this.onPointerUp, true);\n      } // always look directly for touch events so that we can provide original data\n      // In a future version we should change this to being just a fallback and rely solely on\n      // PointerEvents whenever available\n\n\n      if (this.supportsTouchEvents) {\n        this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, true);\n        this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, true);\n        this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, true);\n        this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, true);\n      }\n\n      this.eventsAdded = true;\n    }\n    /**\n     * Removes all the DOM events that were previously registered\n     *\n     * @private\n     */\n\n  }, {\n    key: 'removeEvents',\n    value: function removeEvents() {\n      if (!this.interactionDOMElement) {\n        return;\n      }\n\n      this.emit('removeevents');\n      this.interactionDOMElement.removeEventListener('click', this.onClick, true);\n\n      if (window.navigator.msPointerEnabled) {\n        this.interactionDOMElement.style['-ms-content-zooming'] = '';\n        this.interactionDOMElement.style['-ms-touch-action'] = '';\n      } else if (this.supportsPointerEvents) {\n        this.interactionDOMElement.style['touch-action'] = '';\n      }\n\n      if (this.supportsPointerEvents) {\n        window.document.removeEventListener('pointermove', this.onPointerMove, true);\n        this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, true);\n        this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, true);\n        this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, true);\n        window.removeEventListener('pointercancel', this.onPointerCancel, true);\n        window.removeEventListener('pointerup', this.onPointerUp, true);\n      } else {\n        window.document.removeEventListener('mousemove', this.onPointerMove, true);\n        this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, true);\n        this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, true);\n        this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, true);\n        window.removeEventListener('mouseup', this.onPointerUp, true);\n      }\n\n      if (this.supportsTouchEvents) {\n        this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, true);\n        this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n        this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, true);\n        this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, true);\n      }\n\n      this.interactionDOMElement = null;\n      this.eventsAdded = false;\n    }\n    /**\n     * Updates the state of interactive objects.\n     * Invoked by a throttled ticker.\n     *\n     * @param {number} deltaTime - time delta since last tick\n     */\n\n  }, {\n    key: 'update',\n    value: function update(_ref) {\n      var snippet = _ref.snippet;\n      if (!this.isAble()) return;\n      this._deltaTime += snippet;\n\n      if (this._deltaTime < this.interactionFrequency) {\n        return;\n      }\n\n      this._deltaTime = 0;\n\n      if (!this.interactionDOMElement) {\n        return;\n      } // if the user move the mouse this check has already been done using the mouse move!\n\n\n      if (this.didMove) {\n        this.didMove = false;\n        return;\n      }\n\n      this.cursor = null; // Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,\n      // but there was a scenario of a display object moving under a static mouse cursor.\n      // In this case, mouseover and mouseevents would not pass the flag test in triggerEvent function\n\n      for (var k in this.activeInteractionData) {\n        // eslint-disable-next-line no-prototype-builtins\n        if (this.activeInteractionData.hasOwnProperty(k)) {\n          var interactionData = this.activeInteractionData[k];\n\n          if (interactionData.originalEvent && interactionData.pointerType !== 'touch') {\n            var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, interactionData.originalEvent, interactionData);\n            this.processInteractive(interactionEvent, this.layer.scene, this.processPointerOverOut, true);\n          }\n        }\n      }\n\n      this.setCursorMode(this.cursor); // TODO\n    }\n    /**\n     * Sets the current cursor mode, handling any callbacks or CSS style changes.\n     *\n     * @param {string} mode - cursor mode, a key from the cursorStyles dictionary\n     */\n\n  }, {\n    key: 'setCursorMode',\n    value: function setCursorMode(mode) {\n      mode = mode || 'default'; // if the mode didn't actually change, bail early\n\n      if (this.currentCursorMode === mode) {\n        return;\n      }\n\n      this.currentCursorMode = mode;\n      var style = this.cursorStyles[mode]; // only do things if there is a cursor style for it\n\n      if (style) {\n        switch (typeof style === 'undefined' ? 'undefined' : _typeof(style)) {\n          case 'string':\n            // string styles are handled as cursor CSS\n            this.interactionDOMElement.style.cursor = style;\n            break;\n\n          case 'function':\n            // functions are just called, and passed the cursor mode\n            style(mode);\n            break;\n\n          case 'object':\n            // if it is an object, assume that it is a dictionary of CSS styles,\n            // apply it to the interactionDOMElement\n            Object.assign(this.interactionDOMElement.style, style);\n            break;\n\n          default:\n            break;\n        }\n      } else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n        // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n        // for the mode, then assume that the dev wants it to be CSS for the cursor.\n        this.interactionDOMElement.style.cursor = mode;\n      }\n    }\n    /**\n     * Dispatches an event on the display object that was interacted with\n     *\n     * @param {Object3D} displayObject - the display object in question\n     * @param {string} eventString - the name of the event (e.g, mousedown)\n     * @param {object} eventData - the event data object\n     * @private\n     */\n\n  }, {\n    key: 'triggerEvent',\n    value: function triggerEvent(displayObject, eventString, eventData) {\n      if (!eventData.stopped) {\n        eventData.currentTarget = displayObject;\n        eventData.type = eventString;\n        displayObject.emit(eventString, eventData);\n\n        if (displayObject[eventString]) {\n          displayObject[eventString](eventData);\n        }\n      }\n    }\n    /**\n     * This function is provides a neat way of crawling through the scene graph and running a\n     * specified function on all interactive objects it finds. It will also take care of hit\n     * testing the interactive objects and passes the hit across in the function.\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - event containing the point that\n     *  is tested for collision\n     * @param {Object3D} displayObject - the displayObject\n     *  that will be hit test (recursively crawls its children)\n     * @param {Function} [func] - the function that will be called on each interactive object. The\n     *  interactionEvent, displayObject and hit will be passed to the function\n     * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point\n     * @param {boolean} [interactive] - Whether the displayObject is interactive\n     * @return {boolean} returns true if the displayObject hit the point\n     */\n\n  }, {\n    key: 'processInteractive',\n    value: function processInteractive(interactionEvent, displayObject, func, hitTest, interactive) {\n      if (!displayObject || !displayObject.visible) {\n        return false;\n      } // Took a little while to rework this function correctly! But now it is done and nice and optimised. ^_^\n      //\n      // This function will now loop through all objects and then only hit test the objects it HAS\n      // to, not all of them. MUCH faster..\n      // An object will be hit test if the following is true:\n      //\n      // 1: It is interactive.\n      // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.\n      //\n      // As another little optimisation once an interactive object has been hit we can carry on\n      // through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests\n      // A final optimisation is that an object is not hit test directly if a child has already been hit.\n\n\n      interactive = displayObject.interactive || interactive;\n      var hit = false;\n      var interactiveParent = interactive;\n\n      if (displayObject.interactiveChildren && displayObject.children) {\n        var children = displayObject.children;\n\n        for (var i = children.length - 1; i >= 0; i--) {\n          var child = children[i]; // time to get recursive.. if this function will return if something is hit..\n\n          var childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent);\n\n          if (childHit) {\n            // its a good idea to check if a child has lost its parent.\n            // this means it has been removed whilst looping so its best\n            if (!child.parent) {\n              continue;\n            } // we no longer need to hit test any more objects in this container as we we\n            // now know the parent has been hit\n\n\n            interactiveParent = false; // If the child is interactive , that means that the object hit was actually\n            // interactive and not just the child of an interactive object.\n            // This means we no longer need to hit test anything else. We still need to run\n            // through all objects, but we don't need to perform any hit tests.\n\n            if (childHit) {\n              if (interactionEvent.target) {\n                hitTest = false;\n              }\n\n              hit = true;\n            }\n          }\n        }\n      } // no point running this if the item is not interactive or does not have an interactive parent.\n\n\n      if (interactive) {\n        // if we are hit testing (as in we have no hit any objects yet)\n        // We also don't need to worry about hit testing if once of the displayObjects children\n        // has already been hit - but only if it was interactive, otherwise we need to keep\n        // looking for an interactive child, just in case we hit one\n        if (hitTest && !interactionEvent.target) {\n          if (interactionEvent.intersects[0] && interactionEvent.intersects[0].object === displayObject) {\n            hit = true;\n          }\n        }\n\n        if (displayObject.interactive) {\n          if (hit && !interactionEvent.target) {\n            interactionEvent.data.target = interactionEvent.target = displayObject;\n          }\n\n          if (func) {\n            func(interactionEvent, displayObject, !!hit);\n          }\n        }\n      }\n\n      return hit;\n    }\n    /**\n     * Is called when the click is pressed down on the renderer element\n     *\n     * @private\n     * @param {MouseEvent} originalEvent - The DOM event of a click being pressed down\n     */\n\n  }, {\n    key: 'onClick',\n    value: function onClick(originalEvent) {\n      if (!this.isAble()) return;\n      if (originalEvent.type !== 'click') return;\n      var events = this.normalizeToPointerData(originalEvent);\n\n      if (this.autoPreventDefault && events[0].isNormalized) {\n        originalEvent.preventDefault();\n      }\n\n      var interactionData = this.getInteractionDataForPointerId(events[0]);\n      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, events[0], interactionData);\n      interactionEvent.data.originalEvent = originalEvent;\n      this.processInteractive(interactionEvent, this.layer.scene, this.processClick, true);\n      this.emit('click', interactionEvent);\n    }\n    /**\n     * Processes the result of the click check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     * @param {boolean} hit - the result of the hit test on the display object\n     */\n\n  }, {\n    key: 'processClick',\n    value: function processClick(interactionEvent, displayObject, hit) {\n      if (hit) {\n        this.triggerEvent(displayObject, 'click', interactionEvent);\n      }\n    }\n    /**\n     * Is called when the pointer button is pressed down on the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being pressed down\n     */\n\n  }, {\n    key: 'onPointerDown',\n    value: function onPointerDown(originalEvent) {\n      if (!this.isAble()) return; // if we support touch events, then only use those for touch events, not pointer events\n\n      if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n      var events = this.normalizeToPointerData(originalEvent);\n      /**\n       * No need to prevent default on natural pointer events, as there are no side effects\n       * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n       * so still need to be prevented.\n       */\n      // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n      if (this.autoPreventDefault && events[0].isNormalized) {\n        originalEvent.preventDefault();\n      }\n\n      var eventLen = events.length;\n\n      for (var i = 0; i < eventLen; i++) {\n        var event = events[i];\n        var interactionData = this.getInteractionDataForPointerId(event);\n        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n        interactionEvent.data.originalEvent = originalEvent;\n        this.processInteractive(interactionEvent, this.layer.scene, this.processPointerDown, true);\n        this.emit('pointerdown', interactionEvent);\n\n        if (event.pointerType === 'touch') {\n          this.emit('touchstart', interactionEvent);\n        } else if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n          var isRightButton = event.button === 2;\n          this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData);\n        }\n      }\n    }\n    /**\n     * Processes the result of the pointer down check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     * @param {boolean} hit - the result of the hit test on the display object\n     */\n\n  }, {\n    key: 'processPointerDown',\n    value: function processPointerDown(interactionEvent, displayObject, hit) {\n      var data = interactionEvent.data;\n      var id = interactionEvent.data.identifier;\n\n      if (hit) {\n        if (!displayObject.trackedPointers[id]) {\n          displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n        }\n\n        this.triggerEvent(displayObject, 'pointerdown', interactionEvent);\n\n        if (data.pointerType === 'touch') {\n          displayObject.started = true;\n          this.triggerEvent(displayObject, 'touchstart', interactionEvent);\n        } else if (data.pointerType === 'mouse' || data.pointerType === 'pen') {\n          var isRightButton = data.button === 2;\n\n          if (isRightButton) {\n            displayObject.trackedPointers[id].rightDown = true;\n          } else {\n            displayObject.trackedPointers[id].leftDown = true;\n          }\n\n          this.triggerEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent);\n        }\n      }\n    }\n    /**\n     * Is called when the pointer button is released on the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being released\n     * @param {boolean} cancelled - true if the pointer is cancelled\n     * @param {Function} func - Function passed to {@link processInteractive}\n     */\n\n  }, {\n    key: 'onPointerComplete',\n    value: function onPointerComplete(originalEvent, cancelled, func) {\n      var events = this.normalizeToPointerData(originalEvent);\n      var eventLen = events.length; // if the event wasn't targeting our canvas, then consider it to be pointerupoutside\n      // in all cases (unless it was a pointercancel)\n\n      var eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';\n\n      for (var i = 0; i < eventLen; i++) {\n        var event = events[i];\n        var interactionData = this.getInteractionDataForPointerId(event);\n        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n        interactionEvent.data.originalEvent = originalEvent; // perform hit testing for events targeting our canvas or cancel events\n\n        this.processInteractive(interactionEvent, this.layer.scene, func, cancelled || !eventAppend);\n        this.emit(cancelled ? 'pointercancel' : 'pointerup' + eventAppend, interactionEvent);\n\n        if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n          var isRightButton = event.button === 2;\n          this.emit(isRightButton ? 'rightup' + eventAppend : 'mouseup' + eventAppend, interactionEvent);\n        } else if (event.pointerType === 'touch') {\n          this.emit(cancelled ? 'touchcancel' : 'touchend' + eventAppend, interactionEvent);\n          this.releaseInteractionDataForPointerId(event.pointerId, interactionData);\n        }\n      }\n    }\n    /**\n     * Is called when the pointer button is cancelled\n     *\n     * @private\n     * @param {PointerEvent} event - The DOM event of a pointer button being released\n     */\n\n  }, {\n    key: 'onPointerCancel',\n    value: function onPointerCancel(event) {\n      if (!this.isAble()) return; // if we support touch events, then only use those for touch events, not pointer events\n\n      if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n      this.onPointerComplete(event, true, this.processPointerCancel);\n    }\n    /**\n     * Processes the result of the pointer cancel check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     */\n\n  }, {\n    key: 'processPointerCancel',\n    value: function processPointerCancel(interactionEvent, displayObject) {\n      var data = interactionEvent.data;\n      var id = interactionEvent.data.identifier;\n\n      if (displayObject.trackedPointers[id] !== undefined) {\n        delete displayObject.trackedPointers[id];\n        this.triggerEvent(displayObject, 'pointercancel', interactionEvent);\n\n        if (data.pointerType === 'touch') {\n          this.triggerEvent(displayObject, 'touchcancel', interactionEvent);\n        }\n      }\n    }\n    /**\n     * Is called when the pointer button is released on the renderer element\n     *\n     * @private\n     * @param {PointerEvent} event - The DOM event of a pointer button being released\n     */\n\n  }, {\n    key: 'onPointerUp',\n    value: function onPointerUp(event) {\n      if (!this.isAble()) return; // if we support touch events, then only use those for touch events, not pointer events\n\n      if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n      this.onPointerComplete(event, false, this.processPointerUp);\n    }\n    /**\n     * Processes the result of the pointer up check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     * @param {boolean} hit - the result of the hit test on the display object\n     */\n\n  }, {\n    key: 'processPointerUp',\n    value: function processPointerUp(interactionEvent, displayObject, hit) {\n      var data = interactionEvent.data;\n      var id = interactionEvent.data.identifier;\n      var trackingData = displayObject.trackedPointers[id];\n      var isTouch = data.pointerType === 'touch';\n      var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen'; // Mouse only\n\n      if (isMouse) {\n        var isRightButton = data.button === 2;\n        var flags = InteractionTrackingData.FLAGS;\n        var test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;\n        var isDown = trackingData !== undefined && trackingData.flags & test;\n\n        if (hit) {\n          this.triggerEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent);\n\n          if (isDown) {\n            this.triggerEvent(displayObject, isRightButton ? 'rightclick' : 'leftclick', interactionEvent);\n          }\n        } else if (isDown) {\n          this.triggerEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent);\n        } // update the down state of the tracking data\n\n\n        if (trackingData) {\n          if (isRightButton) {\n            trackingData.rightDown = false;\n          } else {\n            trackingData.leftDown = false;\n          }\n        }\n      } // Pointers and Touches, and Mouse\n\n\n      if (isTouch && displayObject.started) {\n        displayObject.started = false;\n        this.triggerEvent(displayObject, 'touchend', interactionEvent);\n      }\n\n      if (hit) {\n        this.triggerEvent(displayObject, 'pointerup', interactionEvent);\n\n        if (trackingData) {\n          this.triggerEvent(displayObject, 'pointertap', interactionEvent);\n\n          if (isTouch) {\n            this.triggerEvent(displayObject, 'tap', interactionEvent); // touches are no longer over (if they ever were) when we get the touchend\n            // so we should ensure that we don't keep pretending that they are\n\n            trackingData.over = false;\n          }\n        }\n      } else if (trackingData) {\n        this.triggerEvent(displayObject, 'pointerupoutside', interactionEvent);\n        if (isTouch) this.triggerEvent(displayObject, 'touchendoutside', interactionEvent);\n      } // Only remove the tracking data if there is no over/down state still associated with it\n\n\n      if (trackingData && trackingData.none) {\n        delete displayObject.trackedPointers[id];\n      }\n    }\n    /**\n     * Is called when the pointer moves across the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer moving\n     */\n\n  }, {\n    key: 'onPointerMove',\n    value: function onPointerMove(originalEvent) {\n      if (!this.isAble()) return; // if we support touch events, then only use those for touch events, not pointer events\n\n      if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n      var events = this.normalizeToPointerData(originalEvent);\n\n      if (events[0].pointerType === 'mouse') {\n        this.didMove = true;\n        this.cursor = null;\n      }\n\n      var eventLen = events.length;\n\n      for (var i = 0; i < eventLen; i++) {\n        var event = events[i];\n        var interactionData = this.getInteractionDataForPointerId(event);\n        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n        interactionEvent.data.originalEvent = originalEvent;\n        var interactive = event.pointerType === 'touch' ? this.moveWhenInside : true;\n        this.processInteractive(interactionEvent, this.layer.scene, this.processPointerMove, interactive);\n        this.emit('pointermove', interactionEvent);\n        if (event.pointerType === 'touch') this.emit('touchmove', interactionEvent);\n        if (event.pointerType === 'mouse' || event.pointerType === 'pen') this.emit('mousemove', interactionEvent);\n      }\n\n      if (events[0].pointerType === 'mouse') {\n        this.setCursorMode(this.cursor); // TODO BUG for parents interactive object (border order issue)\n      }\n    }\n    /**\n     * Processes the result of the pointer move check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     * @param {boolean} hit - the result of the hit test on the display object\n     */\n\n  }, {\n    key: 'processPointerMove',\n    value: function processPointerMove(interactionEvent, displayObject, hit) {\n      var data = interactionEvent.data;\n      var isTouch = data.pointerType === 'touch';\n      var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';\n\n      if (isMouse) {\n        this.processPointerOverOut(interactionEvent, displayObject, hit);\n      }\n\n      if (isTouch && displayObject.started) this.triggerEvent(displayObject, 'touchmove', interactionEvent);\n\n      if (!this.moveWhenInside || hit) {\n        this.triggerEvent(displayObject, 'pointermove', interactionEvent);\n        if (isMouse) this.triggerEvent(displayObject, 'mousemove', interactionEvent);\n      }\n    }\n    /**\n     * Is called when the pointer is moved out of the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out\n     */\n\n  }, {\n    key: 'onPointerOut',\n    value: function onPointerOut(originalEvent) {\n      if (!this.isAble()) return; // if we support touch events, then only use those for touch events, not pointer events\n\n      if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n      var events = this.normalizeToPointerData(originalEvent); // Only mouse and pointer can call onPointerOut, so events will always be length 1\n\n      var event = events[0];\n\n      if (event.pointerType === 'mouse') {\n        this.mouseOverRenderer = false;\n        this.setCursorMode(null);\n      }\n\n      var interactionData = this.getInteractionDataForPointerId(event);\n      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n      interactionEvent.data.originalEvent = event;\n      this.processInteractive(interactionEvent, this.layer.scene, this.processPointerOverOut, false);\n      this.emit('pointerout', interactionEvent);\n\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        this.emit('mouseout', interactionEvent);\n      } else {\n        // we can get touchleave events after touchend, so we want to make sure we don't\n        // introduce memory leaks\n        this.releaseInteractionDataForPointerId(interactionData.identifier);\n      }\n    }\n    /**\n     * Processes the result of the pointer over/out check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     * @param {boolean} hit - the result of the hit test on the display object\n     */\n\n  }, {\n    key: 'processPointerOverOut',\n    value: function processPointerOverOut(interactionEvent, displayObject, hit) {\n      var data = interactionEvent.data;\n      var id = interactionEvent.data.identifier;\n      var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';\n      var trackingData = displayObject.trackedPointers[id]; // if we just moused over the display object, then we need to track that state\n\n      if (hit && !trackingData) {\n        trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n      }\n\n      if (trackingData === undefined) return;\n\n      if (hit && this.mouseOverRenderer) {\n        if (!trackingData.over) {\n          trackingData.over = true;\n          this.triggerEvent(displayObject, 'pointerover', interactionEvent);\n\n          if (isMouse) {\n            this.triggerEvent(displayObject, 'mouseover', interactionEvent);\n          }\n        } // only change the cursor if it has not already been changed (by something deeper in the\n        // display tree)\n\n\n        if (isMouse && this.cursor === null) {\n          this.cursor = displayObject.cursor;\n        }\n      } else if (trackingData.over) {\n        trackingData.over = false;\n        this.triggerEvent(displayObject, 'pointerout', this.eventData);\n\n        if (isMouse) {\n          this.triggerEvent(displayObject, 'mouseout', interactionEvent);\n        } // if there is no mouse down information for the pointer, then it is safe to delete\n\n\n        if (trackingData.none) {\n          delete displayObject.trackedPointers[id];\n        }\n      }\n    }\n    /**\n     * Is called when the pointer is moved into the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being moved into the renderer view\n     */\n\n  }, {\n    key: 'onPointerOver',\n    value: function onPointerOver(originalEvent) {\n      if (!this.isAble()) return;\n      var events = this.normalizeToPointerData(originalEvent); // Only mouse and pointer can call onPointerOver, so events will always be length 1\n\n      var event = events[0];\n      var interactionData = this.getInteractionDataForPointerId(event);\n      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n      interactionEvent.data.originalEvent = event;\n\n      if (event.pointerType === 'mouse') {\n        this.mouseOverRenderer = true;\n      }\n\n      this.emit('pointerover', interactionEvent);\n\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        this.emit('mouseover', interactionEvent);\n      }\n    }\n    /**\n     * Get InteractionData for a given pointerId. Store that data as well\n     *\n     * @private\n     * @param {PointerEvent} event - Normalized pointer event, output from normalizeToPointerData\n     * @return {InteractionData} - Interaction data for the given pointer identifier\n     */\n\n  }, {\n    key: 'getInteractionDataForPointerId',\n    value: function getInteractionDataForPointerId(event) {\n      var pointerId = event.pointerId;\n      var interactionData = void 0;\n\n      if (pointerId === MOUSE_POINTER_ID$1 || event.pointerType === 'mouse') {\n        interactionData = this.mouse;\n      } else if (this.activeInteractionData[pointerId]) {\n        interactionData = this.activeInteractionData[pointerId];\n      } else {\n        interactionData = this.interactionDataPool.pop() || new InteractionData();\n        interactionData.identifier = pointerId;\n        this.activeInteractionData[pointerId] = interactionData;\n      } // copy properties from the event, so that we can make sure that touch/pointer specific\n      // data is available\n\n\n      interactionData._copyEvent(event);\n\n      return interactionData;\n    }\n    /**\n     * Return unused InteractionData to the pool, for a given pointerId\n     *\n     * @private\n     * @param {number} pointerId - Identifier from a pointer event\n     */\n\n  }, {\n    key: 'releaseInteractionDataForPointerId',\n    value: function releaseInteractionDataForPointerId(pointerId) {\n      var interactionData = this.activeInteractionData[pointerId];\n\n      if (interactionData) {\n        delete this.activeInteractionData[pointerId];\n\n        interactionData._reset();\n\n        this.interactionDataPool.push(interactionData);\n      }\n    }\n    /**\n     * Maps x and y coords from a DOM object and maps them correctly to the three.js view. The\n     * resulting value is stored in the point. This takes into account the fact that the DOM\n     * element could be scaled and positioned anywhere on the screen.\n     *\n     * @param  {Vector2} point - the point that the result will be stored in\n     * @param  {number} x - the x coord of the position to map\n     * @param  {number} y - the y coord of the position to map\n     */\n\n  }, {\n    key: 'mapPositionToPoint',\n    value: function mapPositionToPoint(point, x, y) {\n      var rect = void 0; // IE 11 fix\n\n      if (!this.interactionDOMElement.parentElement) {\n        rect = {\n          x: 0,\n          y: 0,\n          left: 0,\n          top: 0,\n          width: 0,\n          height: 0\n        };\n      } else {\n        rect = this.interactionDOMElement.getBoundingClientRect();\n      }\n\n      point.x = (x - rect.left) / rect.width * 2 - 1;\n      point.y = -((y - rect.top) / rect.height) * 2 + 1;\n    }\n    /**\n     * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The event to be configured\n     * @param {PointerEvent} pointerEvent - The DOM event that will be paired with the InteractionEvent\n     * @param {InteractionData} interactionData - The InteractionData that will be paired\n     *        with the InteractionEvent\n     * @return {InteractionEvent} the interaction event that was passed in\n     */\n\n  }, {\n    key: 'configureInteractionEventForDOMEvent',\n    value: function configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {\n      interactionEvent.data = interactionData;\n      this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);\n      if (this.layer && this.layer.interactive) this.raycaster.setFromCamera(interactionData.global, this.layer.camera); // Not really sure why this is happening, but it's how a previous version handled things TODO: there should be remove\n\n      if (pointerEvent.pointerType === 'touch') {\n        pointerEvent.globalX = interactionData.global.x;\n        pointerEvent.globalY = interactionData.global.y;\n      }\n\n      interactionData.originalEvent = pointerEvent;\n\n      interactionEvent._reset();\n\n      interactionEvent.intersects = this.raycaster.intersectObjects(this.scene.children, true);\n      return interactionEvent;\n    }\n    /**\n     * Ensures that the original event object contains all data that a regular pointer event would have\n     *\n     * @private\n     * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event\n     * @return {PointerEvent[]} An array containing a single normalized pointer event, in the case of a pointer\n     *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n     */\n\n  }, {\n    key: 'normalizeToPointerData',\n    value: function normalizeToPointerData(event) {\n      var normalizedEvents = [];\n\n      if (this.supportsTouchEvents && event instanceof TouchEvent) {\n        for (var i = 0, li = event.changedTouches.length; i < li; i++) {\n          var touch = event.changedTouches[i];\n          if (typeof touch.button === 'undefined') touch.button = event.touches.length ? 1 : 0;\n          if (typeof touch.buttons === 'undefined') touch.buttons = event.touches.length ? 1 : 0;\n\n          if (typeof touch.isPrimary === 'undefined') {\n            touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n          }\n\n          if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n          if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n          if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n          if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n          if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n          if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n          if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n          touch.twist = 0;\n          touch.tangentialPressure = 0; // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n          // support, and the fill ins are not quite the same\n          // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n          // left is not 0,0 on the page\n\n          if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n          if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY; // mark the touch as normalized, just so that we know we did it\n\n          touch.isNormalized = true;\n          normalizedEvents.push(touch);\n        }\n      } else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent))) {\n        if (typeof event.isPrimary === 'undefined') event.isPrimary = true;\n        if (typeof event.width === 'undefined') event.width = 1;\n        if (typeof event.height === 'undefined') event.height = 1;\n        if (typeof event.tiltX === 'undefined') event.tiltX = 0;\n        if (typeof event.tiltY === 'undefined') event.tiltY = 0;\n        if (typeof event.pointerType === 'undefined') event.pointerType = 'mouse';\n        if (typeof event.pointerId === 'undefined') event.pointerId = MOUSE_POINTER_ID$1;\n        if (typeof event.pressure === 'undefined') event.pressure = 0.5;\n        event.twist = 0;\n        event.tangentialPressure = 0; // mark the mouse event as normalized, just so that we know we did it\n\n        event.isNormalized = true;\n        normalizedEvents.push(event);\n      } else {\n        normalizedEvents.push(event);\n      }\n\n      return normalizedEvents;\n    }\n    /**\n     * Destroys the interaction manager\n     *\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this.removeEvents();\n      this.removeAllListeners();\n      this.renderer = null;\n      this.mouse = null;\n      this.eventData = null;\n      this.interactionDOMElement = null;\n      this.onPointerDown = null;\n      this.processPointerDown = null;\n      this.onPointerUp = null;\n      this.processPointerUp = null;\n      this.onPointerCancel = null;\n      this.processPointerCancel = null;\n      this.onPointerMove = null;\n      this.processPointerMove = null;\n      this.onPointerOut = null;\n      this.processPointerOverOut = null;\n      this.onPointerOver = null;\n      this._tempPoint = null;\n    }\n  }]);\n  return InteractionLayer;\n}(EventDispatcher);\n\n(function () {\n  var lastTime = 0;\n  var vendors = ['ms', 'moz', 'webkit', 'o'];\n\n  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n  }\n\n  if (!window.requestAnimationFrame) {\n    window.requestAnimationFrame = function (callback) {\n      var currTime = new Date().getTime();\n      var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n      var id = window.setTimeout(function () {\n        callback(currTime + timeToCall);\n      }, timeToCall);\n      lastTime = currTime + timeToCall;\n      return id;\n    };\n  }\n\n  if (!window.cancelAnimationFrame) {\n    window.cancelAnimationFrame = function (id) {\n      clearTimeout(id);\n    };\n  }\n\n  window.RAF = window.requestAnimationFrame;\n  window.CAF = window.cancelAnimationFrame;\n})();\n/**\n * @extends EventDispatcher\n */\n\n\nvar Ticker = function (_EventDispatcher) {\n  inherits(Ticker, _EventDispatcher);\n  /**\n   *\n   */\n\n  function Ticker() {\n    classCallCheck(this, Ticker);\n\n    var _this = possibleConstructorReturn(this, (Ticker.__proto__ || Object.getPrototypeOf(Ticker)).call(this));\n\n    _this.timer = null;\n    _this.started = false;\n    /**\n     * pre-time cache\n     *\n     * @member {Number}\n     * @private\n     */\n\n    _this.pt = 0;\n    /**\n     * how long the time through, at this tick\n     *\n     * @member {Number}\n     * @private\n     */\n\n    _this.snippet = 0;\n\n    _this.start();\n\n    return _this;\n  }\n  /**\n   * start tick loop\n   */\n\n\n  createClass(Ticker, [{\n    key: 'start',\n    value: function start() {\n      var _this2 = this;\n\n      if (this.started) return;\n\n      var loop = function loop() {\n        _this2.timeline();\n\n        _this2.emit('tick', {\n          snippet: _this2.snippet\n        });\n\n        _this2.timer = RAF(loop);\n      };\n\n      loop();\n    }\n    /**\n     * stop tick loop\n     */\n\n  }, {\n    key: 'stop',\n    value: function stop() {\n      CAF(this.timer);\n      this.started = false;\n    }\n    /**\n     * get timeline snippet\n     *\n     * @private\n     */\n\n  }, {\n    key: 'timeline',\n    value: function timeline() {\n      this.snippet = Date.now() - this.pt;\n\n      if (this.pt === 0 || this.snippet > 200) {\n        this.pt = Date.now();\n        this.snippet = Date.now() - this.pt;\n      }\n\n      this.pt += this.snippet;\n    }\n  }]);\n  return Ticker;\n}(EventDispatcher);\n/**\n * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive\n * if its interactive parameter is set to true\n * This manager also supports multitouch.\n *\n * reference to [pixi.js](http://www.pixijs.com/) impl\n *\n * @example\n * import { Scene, PerspectiveCamera, WebGLRenderer, Mesh, BoxGeometry, MeshBasicMaterial } from 'three';\n * import { Interaction } from 'three.interaction';\n * const renderer = new WebGLRenderer({ canvas: canvasElement });\n * const scene = new Scene();\n * const camera = new PerspectiveCamera(60, width / height, 0.1, 100);\n *\n * const interaction = new Interaction(renderer, scene, camera);\n * // then you can bind every interaction event with any mesh which you had `add` into `scene` before\n * const cube = new Mesh(\n *   new BoxGeometry(1, 1, 1),\n *   new MeshBasicMaterial({ color: 0xffffff }),\n * );\n * scene.add(cube);\n * cube.on('touchstart', ev => {\n *   console.log(ev);\n * });\n *\n * cube.on('mousedown', ev => {\n *   console.log(ev);\n * });\n *\n * cube.on('pointerdown', ev => {\n *   console.log(ev);\n * });\n * // and so on ...\n *\n * // you can also listen on parent-node or any display-tree node,\n * // source event will bubble up along with display-tree.\n * // you can stop the bubble-up by invoke ev.stopPropagation function.\n * scene.on('touchstart', ev => {\n *   console.log(ev);\n * })\n *\n * @class\n * @extends InteractionManager\n */\n\n\nvar Interaction = function (_InteractionManager) {\n  inherits(Interaction, _InteractionManager);\n  /**\n   * @param {WebGLRenderer} renderer - A reference to the current renderer\n   * @param {Scene} scene - A reference to the current scene\n   * @param {Camera} camera - A reference to the current camera\n   * @param {Object} [options] - The options for the manager.\n   * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.\n   * @param {Boolean} [options.autoAttach=false] - Should the manager automatically attach target element.\n   * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.\n   */\n\n  function Interaction(renderer, scene, camera, options) {\n    classCallCheck(this, Interaction);\n    options = Object.assign({\n      autoAttach: false\n    }, options);\n    /**\n     * a ticker\n     *\n     * @private\n     * @member {Ticker}\n     */\n\n    var _this = possibleConstructorReturn(this, (Interaction.__proto__ || Object.getPrototypeOf(Interaction)).call(this, renderer, scene, camera, options));\n\n    _this.ticker = new Ticker();\n    /**\n     * update for some over event\n     *\n     * @private\n     */\n\n    _this.update = _this.update.bind(_this);\n\n    _this.on('addevents', function () {\n      _this.ticker.on('tick', _this.update);\n    });\n\n    _this.on('removeevents', function () {\n      _this.ticker.off('tick', _this.update);\n    });\n\n    _this.setTargetElement(_this.renderer.domElement);\n\n    return _this;\n  }\n\n  return Interaction;\n}(InteractionManager);\n\nexport { InteractionManager, InteractionLayer, Interaction };","map":{"version":3,"mappings":"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","names":["_rt","val","Object","prototype","toString","call","Utils","ks","variable","EventDispatcher","on","type","fn","isFunction","Object3D","interactive","addEventListener","off","removeEventListener","once","cb","ev","emit","_listeners","undefined","isUndefined","cbs","cache","slice","argument","i","length","apply","interactiveChildren","started","defineProperty","_trackedPointers","raycastTest","raycaster","result","raycast","InteractionData","global","Vector2","target","originalEvent","identifier","isPrimary","button","buttons","width","height","tiltX","tiltY","pointerType","pressure","rotationAngle","twist","tangentialPressure","event","InteractionEvent","stopped","currentTarget","data","intersects","InteractionTrackingData","pointerId","_pointerId","_flags","FLAGS","NONE","flag","yn","flags","constructor","OVER","_doSet","RIGHT_DOWN","LEFT_DOWN","freeze","MOUSE_POINTER_ID","hitTestEvent","InteractionManager","renderer","scene","camera","options","autoPreventDefault","interactionFrequency","mouse","set","activeInteractionData","_this","interactionDataPool","eventData","interactionDOMElement","moveWhenInside","eventsAdded","mouseOverRenderer","supportsTouchEvents","window","supportsPointerEvents","PointerEvent","onClick","bind","processClick","onPointerUp","processPointerUp","onPointerCancel","processPointerCancel","onPointerDown","processPointerDown","onPointerMove","processPointerMove","onPointerOut","processPointerOverOut","onPointerOver","cursorStyles","currentCursorMode","cursor","Raycaster","_deltaTime","setTargetElement","domElement","globalPoint","root","processInteractive","element","removeEvents","addEvents","navigator","msPointerEnabled","style","document","snippet","didMove","k","hasOwnProperty","interactionData","interactionEvent","configureInteractionEventForDOMEvent","setCursorMode","mode","assign","displayObject","eventString","func","hitTest","visible","hit","interactiveParent","children","child","childHit","parent","object","events","normalizeToPointerData","isNormalized","preventDefault","getInteractionDataForPointerId","triggerEvent","eventLen","isRightButton","id","trackedPointers","rightDown","leftDown","cancelled","eventAppend","releaseInteractionDataForPointerId","onPointerComplete","trackingData","isTouch","isMouse","test","isDown","over","none","pop","_copyEvent","_reset","push","point","x","y","rect","parentElement","getBoundingClientRect","left","top","pointerEvent","mapPositionToPoint","clientX","clientY","setFromCamera","globalX","globalY","intersectObjects","normalizedEvents","TouchEvent","li","changedTouches","touch","touches","radiusX","radiusY","force","layerX","offsetX","layerY","offsetY","MouseEvent","removeAllListeners","_tempPoint","InteractionLayer","layer","isAble","lastTime","vendors","requestAnimationFrame","cancelAnimationFrame","callback","currTime","Date","getTime","timeToCall","Math","max","setTimeout","RAF","CAF","Ticker","timer","pt","start","loop","timeline","_this2","now","Interaction","autoAttach","ticker","update"],"sources":["/home/xkruzel/Desktop/todo/reactapp/node_modules/three.interaction/src/utils/Utils.js","/home/xkruzel/Desktop/todo/reactapp/node_modules/three.interaction/src/patch/EventDispatcher.js","/home/xkruzel/Desktop/todo/reactapp/node_modules/three.interaction/src/patch/Object3D.js","/home/xkruzel/Desktop/todo/reactapp/node_modules/three.interaction/src/interaction/InteractionData.js","/home/xkruzel/Desktop/todo/reactapp/node_modules/three.interaction/src/interaction/InteractionEvent.js","/home/xkruzel/Desktop/todo/reactapp/node_modules/three.interaction/src/interaction/InteractionTrackingData.js","/home/xkruzel/Desktop/todo/reactapp/node_modules/three.interaction/src/interaction/InteractionManager.js","/home/xkruzel/Desktop/todo/reactapp/node_modules/three.interaction/src/interaction/InteractionLayer.js","/home/xkruzel/Desktop/todo/reactapp/node_modules/three.interaction/src/utils/Raf.js","/home/xkruzel/Desktop/todo/reactapp/node_modules/three.interaction/src/utils/Ticker.js","/home/xkruzel/Desktop/todo/reactapp/node_modules/three.interaction/src/interaction/Interaction.js"],"sourcesContent":["/**\n * get variable type\n * @param {*} val a variable which you want to get the type\n * @return {String} variable-type\n */\nfunction _rt(val) {\n  return Object.prototype.toString.call(val);\n}\n\n/**\n * Utils tool box\n *\n * @namespace Utils\n */\nexport const Utils = {\n  /**\n   * determine whether it is a `Function`\n   *\n   * @static\n   * @method\n   * @memberof Utils\n   * @param {*} variable a variable which you want to determine\n   * @return {Boolean} type result\n   */\n  isFunction: (function() {\n    const ks = _rt(function() {});\n    return function(variable) {\n      return _rt(variable) === ks;\n    };\n  })(),\n\n\n  /**\n   * determine whether it is a `undefined`\n   *\n   * @static\n   * @method\n   * @memberof Utils\n   * @param {*} variable a variable which you want to determine\n   * @return {Boolean} type result\n   */\n  isUndefined(variable) {\n    return typeof variable === 'undefined';\n  },\n};\n","import { EventDispatcher, Object3D } from 'three';\nimport { Utils } from '../utils/Utils.js';\n\n/**\n * proxy `addEventListener` function\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback\n * @return {this} this\n */\nEventDispatcher.prototype.on = function(type, fn) {\n  if (!Utils.isFunction(fn)) return;\n  if (this instanceof Object3D) this.interactive = true;\n  this.addEventListener(type, fn);\n  return this;\n};\n\n/**\n * proxy `removeEventListener` function\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback, which you had bind before\n * @return {this} this\n */\nEventDispatcher.prototype.off = function(type, fn) {\n  this.removeEventListener(type, fn);\n  return this;\n};\n\n/**\n * binding a once event, just emit once time\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback\n * @return {this} this\n */\nEventDispatcher.prototype.once = function(type, fn) {\n  if (!Utils.isFunction(fn)) return;\n  const cb = (ev) => {\n    fn(ev);\n    this.off(type, cb);\n  };\n  this.on(type, cb);\n  return this;\n};\n\n/**\n * emit a event\n *\n * @param {String} type event type, evnet name\n * @return {this} this\n */\nEventDispatcher.prototype.emit = function(type, ...argument) {\n  if (this._listeners === undefined || Utils.isUndefined(this._listeners[type])) return;\n  const cbs = this._listeners[type] || [];\n  const cache = cbs.slice(0);\n\n  for (let i = 0; i < cache.length; i++) {\n    cache[i].apply(this, argument);\n  }\n  return this;\n};\n\n","import { Object3D } from 'three';\n\n/**\n * whether displayObject is interactively\n */\nObject3D.prototype.interactive = false;\n\n/**\n * whether displayObject's children is interactively\n */\nObject3D.prototype.interactiveChildren = true;\n\n/**\n * whether displayObject had touchstart\n * @private\n */\nObject3D.prototype.started = false;\n\n/**\n * tracked event cache, like: touchend、mouseout、pointerout which decided by primary-event\n */\nObject.defineProperty(Object3D.prototype, 'trackedPointers', {\n  get() {\n    if (!this._trackedPointers) this._trackedPointers = {};\n    return this._trackedPointers;\n  },\n});\n\n/**\n * dispatch a raycast\n *\n * @param {Raycaster} raycaster Raycaster object, get from THREE.Raycaster\n * @return {Object|Boolean} had pass hit-test\n */\nObject3D.prototype.raycastTest = function(raycaster) {\n  const result = [];\n  this.raycast(raycaster, result);\n\n  if (result.length > 0) {\n    return result[0];\n  }\n\n  return false;\n};\n","import { Vector2 } from 'three';\n\n/**\n * Holds all information related to an Interaction event\n *\n * @class\n */\nclass InteractionData {\n  /**\n   * InteractionData constructor\n   */\n  constructor() {\n    /**\n     * This point stores the global coords of where the touch/mouse event happened\n     *\n     * @member {Vector2}\n     */\n    this.global = new Vector2();\n\n    /**\n     * The target DisplayObject that was interacted with\n     *\n     * @member {Object3D}\n     */\n    this.target = null;\n\n    /**\n     * When passed to an event handler, this will be the original DOM Event that was captured\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent\n     * @member {MouseEvent|TouchEvent|PointerEvent}\n     */\n    this.originalEvent = null;\n\n    /**\n     * Unique identifier for this interaction\n     *\n     * @member {number}\n     */\n    this.identifier = null;\n\n    /**\n     * Indicates whether or not the pointer device that created the event is the primary pointer.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n     * @type {Boolean}\n     */\n    this.isPrimary = false;\n\n    /**\n     * Indicates which button was pressed on the mouse or pointer device to trigger the event.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n     * @type {number}\n     */\n    this.button = 0;\n\n    /**\n     * Indicates which buttons are pressed on the mouse or pointer device when the event is triggered.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n     * @type {number}\n     */\n    this.buttons = 0;\n\n    /**\n     * The width of the pointer's contact along the x-axis, measured in CSS pixels.\n     * radiusX of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n     * @type {number}\n     */\n    this.width = 0;\n\n    /**\n     * The height of the pointer's contact along the y-axis, measured in CSS pixels.\n     * radiusY of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n     * @type {number}\n     */\n    this.height = 0;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX\n     * @type {number}\n     */\n    this.tiltX = 0;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY\n     * @type {number}\n     */\n    this.tiltY = 0;\n\n    /**\n     * The type of pointer that triggered the event.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType\n     * @type {string}\n     */\n    this.pointerType = null;\n\n    /**\n     * Pressure applied by the pointing device during the event. A Touch's force property\n     * will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure\n     * @type {number}\n     */\n    this.pressure = 0;\n\n    /**\n     * From TouchEvents (not PointerEvents triggered by touches), the rotationAngle of the Touch.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Touch/rotationAngle\n     * @type {number}\n     */\n    this.rotationAngle = 0;\n\n    /**\n     * Twist of a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     * @type {number}\n     */\n    this.twist = 0;\n\n    /**\n     * Barrel pressure on a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     * @type {number}\n     */\n    this.tangentialPressure = 0;\n  }\n\n  /**\n   * The unique identifier of the pointer. It will be the same as `identifier`.\n   * @readonly\n   * @member {number}\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId\n   */\n  get pointerId() {\n    return this.identifier;\n  }\n\n  /**\n   * Copies properties from normalized event data.\n   *\n   * @param {Touch|MouseEvent|PointerEvent} event The normalized event data\n   * @private\n   */\n  _copyEvent(event) {\n    // isPrimary should only change on touchstart/pointerdown, so we don't want to overwrite\n    // it with \"false\" on later events when our shim for it on touch events might not be\n    // accurate\n    if (event.isPrimary) {\n      this.isPrimary = true;\n    }\n    this.button = event.button;\n    this.buttons = event.buttons;\n    this.width = event.width;\n    this.height = event.height;\n    this.tiltX = event.tiltX;\n    this.tiltY = event.tiltY;\n    this.pointerType = event.pointerType;\n    this.pressure = event.pressure;\n    this.rotationAngle = event.rotationAngle;\n    this.twist = event.twist || 0;\n    this.tangentialPressure = event.tangentialPressure || 0;\n  }\n\n  /**\n   * Resets the data for pooling.\n   *\n   * @private\n   */\n  _reset() {\n    // isPrimary is the only property that we really need to reset - everything else is\n    // guaranteed to be overwritten\n    this.isPrimary = false;\n  }\n}\n\nexport default InteractionData;\n","/**\n * Event class that mimics native DOM events.\n *\n * @class\n */\nclass InteractionEvent {\n  /**\n   * InteractionEvent constructor\n   */\n  constructor() {\n    /**\n     * Whether this event will continue propagating in the tree\n     *\n     * @member {boolean}\n     */\n    this.stopped = false;\n\n    /**\n     * The object which caused this event to be dispatched.\n     *\n     * @member {Object3D}\n     */\n    this.target = null;\n\n    /**\n     * The object whose event listener’s callback is currently being invoked.\n     *\n     * @member {Object3D}\n     */\n    this.currentTarget = null;\n\n    /**\n     * Type of the event\n     *\n     * @member {string}\n     */\n    this.type = null;\n\n    /**\n     * InteractionData related to this event\n     *\n     * @member {InteractionData}\n     */\n    this.data = null;\n\n    /**\n     * ray caster detial from 3d-mesh\n     *\n     * @member {Intersects}\n     */\n    this.intersects = [];\n  }\n\n  /**\n   * Prevents event from reaching any objects other than the current object.\n   *\n   */\n  stopPropagation() {\n    this.stopped = true;\n  }\n\n  /**\n   * Resets the event.\n   *\n   * @private\n   */\n  _reset() {\n    this.stopped = false;\n    this.currentTarget = null;\n    this.target = null;\n    this.intersects = [];\n  }\n}\n\nexport default InteractionEvent;\n","/**\n * DisplayObjects with the `trackedPointers` property use this class to track interactions\n *\n * @class\n * @private\n */\nexport default class InteractionTrackingData {\n  /**\n   * @param {number} pointerId - Unique pointer id of the event\n   */\n  constructor(pointerId) {\n    this._pointerId = pointerId;\n    this._flags = InteractionTrackingData.FLAGS.NONE;\n  }\n\n  /**\n   *\n   * @private\n   * @param {number} flag - The interaction flag to set\n   * @param {boolean} yn - Should the flag be set or unset\n   */\n  _doSet(flag, yn) {\n    if (yn) {\n      this._flags = this._flags | flag;\n    } else {\n      this._flags = this._flags & (~flag);\n    }\n  }\n\n  /**\n   * Unique pointer id of the event\n   *\n   * @readonly\n   * @member {number}\n   */\n  get pointerId() {\n    return this._pointerId;\n  }\n\n  /**\n   * State of the tracking data, expressed as bit flags\n   *\n   * @member {number}\n   */\n  get flags() {\n    return this._flags;\n  }\n\n  /**\n   * Set the flags for the tracking data\n   *\n   * @param {number} flags - Flags to set\n   */\n  set flags(flags) {\n    this._flags = flags;\n  }\n\n  /**\n   * Is the tracked event inactive (not over or down)?\n   *\n   * @member {number}\n   */\n  get none() {\n    return this._flags === this.constructor.FLAGS.NONE;\n  }\n\n  /**\n   * Is the tracked event over the DisplayObject?\n   *\n   * @member {boolean}\n   */\n  get over() {\n    return (this._flags & this.constructor.FLAGS.OVER) !== 0;\n  }\n\n  /**\n   * Set the over flag\n   *\n   * @param {boolean} yn - Is the event over?\n   */\n  set over(yn) {\n    this._doSet(this.constructor.FLAGS.OVER, yn);\n  }\n\n  /**\n   * Did the right mouse button come down in the DisplayObject?\n   *\n   * @member {boolean}\n   */\n  get rightDown() {\n    return (this._flags & this.constructor.FLAGS.RIGHT_DOWN) !== 0;\n  }\n\n  /**\n   * Set the right down flag\n   *\n   * @param {boolean} yn - Is the right mouse button down?\n   */\n  set rightDown(yn) {\n    this._doSet(this.constructor.FLAGS.RIGHT_DOWN, yn);\n  }\n\n  /**\n   * Did the left mouse button come down in the DisplayObject?\n   *\n   * @member {boolean}\n   */\n  get leftDown() {\n    return (this._flags & this.constructor.FLAGS.LEFT_DOWN) !== 0;\n  }\n\n  /**\n   * Set the left down flag\n   *\n   * @param {boolean} yn - Is the left mouse button down?\n   */\n  set leftDown(yn) {\n    this._doSet(this.constructor.FLAGS.LEFT_DOWN, yn);\n  }\n}\n\nInteractionTrackingData.FLAGS = Object.freeze({\n  NONE: 0,\n  OVER: 1 << 0,\n  LEFT_DOWN: 1 << 1,\n  RIGHT_DOWN: 1 << 2,\n});\n","import '../patch/EventDispatcher';\nimport '../patch/Object3D';\n\nimport { EventDispatcher, Raycaster } from 'three';\nimport InteractionData from './InteractionData';\nimport InteractionEvent from './InteractionEvent';\nimport InteractionTrackingData from './InteractionTrackingData';\n\nconst MOUSE_POINTER_ID = 'MOUSE';\n\n// helpers for hitTest() - only used inside hitTest()\nconst hitTestEvent = {\n  target: null,\n  data: {\n    global: null,\n  },\n};\n\n/**\n * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive\n * if its interactive parameter is set to true\n * This manager also supports multitouch.\n *\n * reference to [pixi.js](http://www.pixijs.com/) impl\n *\n * @private\n * @class\n * @extends EventDispatcher\n */\nclass InteractionManager extends EventDispatcher {\n  /**\n   * @param {WebGLRenderer} renderer - A reference to the current renderer\n   * @param {Scene} scene - A reference to the current scene\n   * @param {Camera} camera - A reference to the current camera\n   * @param {Object} [options] - The options for the manager.\n   * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.\n   * @param {Boolean} [options.autoAttach=true] - Should the manager automatically attach target element.\n   * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.\n   */\n  constructor(renderer, scene, camera, options) {\n    super();\n\n    options = options || {};\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {WebGLRenderer}\n     */\n    this.renderer = renderer;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Scene}\n     */\n    this.scene = scene;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Camera}\n     */\n    this.camera = camera;\n\n    /**\n     * Should default browser actions automatically be prevented.\n     * Does not apply to pointer events for backwards compatibility\n     * preventDefault on pointer events stops mouse events from firing\n     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.\n     *\n     * @member {boolean}\n     * @default false\n     */\n    this.autoPreventDefault = options.autoPreventDefault || false;\n\n    /**\n     * Frequency in milliseconds that the mousemove, moveover & mouseout interaction events will be checked.\n     *\n     * @member {number}\n     * @default 10\n     */\n    this.interactionFrequency = options.interactionFrequency || 10;\n\n    /**\n     * The mouse data\n     *\n     * @member {InteractionData}\n     */\n    this.mouse = new InteractionData();\n    this.mouse.identifier = MOUSE_POINTER_ID;\n\n    // setting the mouse to start off far off screen will mean that mouse over does\n    //  not get called before we even move the mouse.\n    this.mouse.global.set(-999999);\n\n    /**\n     * Actively tracked InteractionData\n     *\n     * @private\n     * @member {Object.<number,InteractionData>}\n     */\n    this.activeInteractionData = {};\n    this.activeInteractionData[MOUSE_POINTER_ID] = this.mouse;\n\n    /**\n     * Pool of unused InteractionData\n     *\n     * @private\n     * @member {InteractionData[]}\n     */\n    this.interactionDataPool = [];\n\n    /**\n     * An event data object to handle all the event tracking/dispatching\n     *\n     * @member {object}\n     */\n    this.eventData = new InteractionEvent();\n\n    /**\n     * The DOM element to bind to.\n     *\n     * @private\n     * @member {HTMLElement}\n     */\n    this.interactionDOMElement = null;\n\n    /**\n     * This property determines if mousemove and touchmove events are fired only when the cursor\n     * is over the object.\n     * Setting to true will make things work more in line with how the DOM verison works.\n     * Setting to false can make things easier for things like dragging\n     * It is currently set to false as this is how three.js used to work.\n     *\n     * @member {boolean}\n     * @default true\n     */\n    this.moveWhenInside = true;\n\n    /**\n     * Have events been attached to the dom element?\n     *\n     * @private\n     * @member {boolean}\n     */\n    this.eventsAdded = false;\n\n    /**\n     * Is the mouse hovering over the renderer?\n     *\n     * @private\n     * @member {boolean}\n     */\n    this.mouseOverRenderer = false;\n\n    /**\n     * Does the device support touch events\n     * https://www.w3.org/TR/touch-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    this.supportsTouchEvents = 'ontouchstart' in window;\n\n    /**\n     * Does the device support pointer events\n     * https://www.w3.org/Submission/pointer-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    this.supportsPointerEvents = !!window.PointerEvent;\n\n    // this will make it so that you don't have to call bind all the time\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onClick = this.onClick.bind(this);\n    this.processClick = this.processClick.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerUp = this.onPointerUp.bind(this);\n    this.processPointerUp = this.processPointerUp.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerCancel = this.onPointerCancel.bind(this);\n    this.processPointerCancel = this.processPointerCancel.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerDown = this.onPointerDown.bind(this);\n    this.processPointerDown = this.processPointerDown.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerMove = this.onPointerMove.bind(this);\n    this.processPointerMove = this.processPointerMove.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerOut = this.onPointerOut.bind(this);\n    this.processPointerOverOut = this.processPointerOverOut.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerOver = this.onPointerOver.bind(this);\n\n    /**\n     * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor\n     * values, objects are handled as dictionaries of CSS values for interactionDOMElement,\n     * and functions are called instead of changing the CSS.\n     * Default CSS cursor values are provided for 'default' and 'pointer' modes.\n     * @member {Object.<string, (string|Function|Object.<string, string>)>}\n     */\n    this.cursorStyles = {\n      default: 'inherit',\n      pointer: 'pointer',\n    };\n\n    /**\n     * The mode of the cursor that is being used.\n     * The value of this is a key from the cursorStyles dictionary.\n     *\n     * @member {string}\n     */\n    this.currentCursorMode = null;\n\n    /**\n     * Internal cached let.\n     *\n     * @private\n     * @member {string}\n     */\n    this.cursor = null;\n\n    /**\n     * ray caster, for survey intersects from 3d-scene\n     *\n     * @private\n     * @member {Raycaster}\n     */\n    this.raycaster = new Raycaster();\n\n    /**\n     * snippet time\n     *\n     * @private\n     * @member {Number}\n     */\n    this._deltaTime = 0;\n\n    this.setTargetElement(this.renderer.domElement);\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display\n     * object.\n     *\n     * @event InteractionManager#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object.\n     *\n     * @event InteractionManager#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object.\n     *\n     * @event InteractionManager#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object.\n     *\n     * @event InteractionManager#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object.\n     *\n     * @event InteractionManager#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object.\n     *\n     * @event InteractionManager#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link InteractionManager#event:mousedown}.\n     *\n     * @event InteractionManager#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link InteractionManager#event:rightdown}.\n     *\n     * @event InteractionManager#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object\n     *\n     * @event InteractionManager#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object\n     *\n     * @event InteractionManager#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object\n     *\n     * @event InteractionManager#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     *\n     * @event InteractionManager#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     *\n     * @event InteractionManager#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event\n     *\n     * @event InteractionManager#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     *\n     * @event InteractionManager#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link InteractionManager#event:pointerdown}.\n     *\n     * @event InteractionManager#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object\n     *\n     * @event InteractionManager#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object\n     *\n     * @event InteractionManager#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object\n     *\n     * @event InteractionManager#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     *\n     * @event InteractionManager#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     *\n     * @event InteractionManager#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch\n     *\n     * @event InteractionManager#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     *\n     * @event InteractionManager#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link InteractionManager#event:touchstart}.\n     *\n     * @event InteractionManager#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     *\n     * @event InteractionManager#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link Object3D#event:mousedown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link Object3D#event:rightdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link Object3D#event:pointerdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link Object3D#event:touchstart}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n  }\n\n  /**\n   * Hit tests a point against the display tree, returning the first interactive object that is hit.\n   *\n   * @param {Point} globalPoint - A point to hit test with, in global space.\n   * @param {Object3D} [root] - The root display object to start from. If omitted, defaults\n   * to the last rendered root of the associated renderer.\n   * @return {Object3D} The hit display object, if any.\n   */\n  hitTest(globalPoint, root) {\n    // clear the target for our hit test\n    hitTestEvent.target = null;\n    // assign the global point\n    hitTestEvent.data.global = globalPoint;\n    // ensure safety of the root\n    if (!root) {\n      root = this.scene;\n    }\n    // run the hit test\n    this.processInteractive(hitTestEvent, root, null, true);\n    // return our found object - it'll be null if we didn't hit anything\n\n    return hitTestEvent.target;\n  }\n\n  /**\n   * Sets the DOM element which will receive mouse/touch events. This is useful for when you have\n   * other DOM elements on top of the renderers Canvas element. With this you'll be bale to deletegate\n   * another DOM element to receive those events.\n   *\n   * @param {HTMLCanvasElement} element - the DOM element which will receive mouse and touch events.\n   */\n  setTargetElement(element) {\n    this.removeEvents();\n\n    this.interactionDOMElement = element;\n\n    this.addEvents();\n  }\n\n  /**\n   * Registers all the DOM events\n   *\n   * @private\n   */\n  addEvents() {\n    if (!this.interactionDOMElement || this.eventsAdded) {\n      return;\n    }\n\n    this.emit('addevents');\n\n    this.interactionDOMElement.addEventListener('click', this.onClick, true);\n\n    if (window.navigator.msPointerEnabled) {\n      this.interactionDOMElement.style['-ms-content-zooming'] = 'none';\n      this.interactionDOMElement.style['-ms-touch-action'] = 'none';\n    } else if (this.supportsPointerEvents) {\n      this.interactionDOMElement.style['touch-action'] = 'none';\n    }\n\n    /**\n     * These events are added first, so that if pointer events are normalised, they are fired\n     * in the same order as non-normalised events. ie. pointer event 1st, mouse / touch 2nd\n     */\n    if (this.supportsPointerEvents) {\n      window.document.addEventListener('pointermove', this.onPointerMove, true);\n      this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, true);\n      // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n      // we already handle those, so for the purposes of what we do in onPointerOut, we only\n      // care about the pointerleave event\n      this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, true);\n      this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, true);\n      window.addEventListener('pointercancel', this.onPointerCancel, true);\n      window.addEventListener('pointerup', this.onPointerUp, true);\n    } else {\n      window.document.addEventListener('mousemove', this.onPointerMove, true);\n      this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, true);\n      this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, true);\n      this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, true);\n      window.addEventListener('mouseup', this.onPointerUp, true);\n    }\n\n    // always look directly for touch events so that we can provide original data\n    // In a future version we should change this to being just a fallback and rely solely on\n    // PointerEvents whenever available\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, true);\n      this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, true);\n      this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, true);\n      this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, true);\n    }\n\n    this.eventsAdded = true;\n  }\n\n  /**\n   * Removes all the DOM events that were previously registered\n   *\n   * @private\n   */\n  removeEvents() {\n    if (!this.interactionDOMElement) {\n      return;\n    }\n\n    this.emit('removeevents');\n\n    this.interactionDOMElement.removeEventListener('click', this.onClick, true);\n\n    if (window.navigator.msPointerEnabled) {\n      this.interactionDOMElement.style['-ms-content-zooming'] = '';\n      this.interactionDOMElement.style['-ms-touch-action'] = '';\n    } else if (this.supportsPointerEvents) {\n      this.interactionDOMElement.style['touch-action'] = '';\n    }\n\n    if (this.supportsPointerEvents) {\n      window.document.removeEventListener('pointermove', this.onPointerMove, true);\n      this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, true);\n      this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, true);\n      window.removeEventListener('pointercancel', this.onPointerCancel, true);\n      window.removeEventListener('pointerup', this.onPointerUp, true);\n    } else {\n      window.document.removeEventListener('mousemove', this.onPointerMove, true);\n      this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, true);\n      this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, true);\n      window.removeEventListener('mouseup', this.onPointerUp, true);\n    }\n\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n      this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, true);\n      this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, true);\n    }\n\n    this.interactionDOMElement = null;\n\n    this.eventsAdded = false;\n  }\n\n  /**\n   * Updates the state of interactive objects.\n   * Invoked by a throttled ticker.\n   *\n   * @param {number} deltaTime - time delta since last tick\n   */\n  update({ snippet }) {\n    this._deltaTime += snippet;\n\n    if (this._deltaTime < this.interactionFrequency) {\n      return;\n    }\n\n    this._deltaTime = 0;\n\n    if (!this.interactionDOMElement) {\n      return;\n    }\n\n    // if the user move the mouse this check has already been done using the mouse move!\n    if (this.didMove) {\n      this.didMove = false;\n\n      return;\n    }\n\n    this.cursor = null;\n\n    // Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,\n    // but there was a scenario of a display object moving under a static mouse cursor.\n    // In this case, mouseover and mouseevents would not pass the flag test in triggerEvent function\n    for (const k in this.activeInteractionData) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (this.activeInteractionData.hasOwnProperty(k)) {\n        const interactionData = this.activeInteractionData[k];\n\n        if (interactionData.originalEvent && interactionData.pointerType !== 'touch') {\n          const interactionEvent = this.configureInteractionEventForDOMEvent(\n            this.eventData,\n            interactionData.originalEvent,\n            interactionData\n          );\n\n          this.processInteractive(\n            interactionEvent,\n            this.scene,\n            this.processPointerOverOut,\n            true\n          );\n        }\n      }\n    }\n\n    this.setCursorMode(this.cursor);\n\n    // TODO\n  }\n\n  /**\n   * Sets the current cursor mode, handling any callbacks or CSS style changes.\n   *\n   * @param {string} mode - cursor mode, a key from the cursorStyles dictionary\n   */\n  setCursorMode(mode) {\n    mode = mode || 'default';\n    // if the mode didn't actually change, bail early\n    if (this.currentCursorMode === mode) {\n      return;\n    }\n    this.currentCursorMode = mode;\n    const style = this.cursorStyles[mode];\n\n    // only do things if there is a cursor style for it\n    if (style) {\n      switch (typeof style) {\n        case 'string':\n          // string styles are handled as cursor CSS\n          this.interactionDOMElement.style.cursor = style;\n          break;\n        case 'function':\n          // functions are just called, and passed the cursor mode\n          style(mode);\n          break;\n        case 'object':\n          // if it is an object, assume that it is a dictionary of CSS styles,\n          // apply it to the interactionDOMElement\n          Object.assign(this.interactionDOMElement.style, style);\n          break;\n        default:\n          break;\n      }\n    } else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n      // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n      // for the mode, then assume that the dev wants it to be CSS for the cursor.\n      this.interactionDOMElement.style.cursor = mode;\n    }\n  }\n\n  /**\n   * Dispatches an event on the display object that was interacted with\n   *\n   * @param {Object3D} displayObject - the display object in question\n   * @param {string} eventString - the name of the event (e.g, mousedown)\n   * @param {object} eventData - the event data object\n   * @private\n   */\n  triggerEvent(displayObject, eventString, eventData) {\n    if (!eventData.stopped) {\n      eventData.currentTarget = displayObject;\n      eventData.type = eventString;\n\n      displayObject.emit(eventString, eventData);\n\n      if (displayObject[eventString]) {\n        displayObject[eventString](eventData);\n      }\n    }\n  }\n\n  /**\n   * This function is provides a neat way of crawling through the scene graph and running a\n   * specified function on all interactive objects it finds. It will also take care of hit\n   * testing the interactive objects and passes the hit across in the function.\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - event containing the point that\n   *  is tested for collision\n   * @param {Object3D} displayObject - the displayObject\n   *  that will be hit test (recursively crawls its children)\n   * @param {Function} [func] - the function that will be called on each interactive object. The\n   *  interactionEvent, displayObject and hit will be passed to the function\n   * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point\n   * @param {boolean} [interactive] - Whether the displayObject is interactive\n   * @return {boolean} returns true if the displayObject hit the point\n   */\n  processInteractive(interactionEvent, displayObject, func, hitTest, interactive) {\n    if (!displayObject || !displayObject.visible) {\n      return false;\n    }\n\n    // Took a little while to rework this function correctly! But now it is done and nice and optimised. ^_^\n    //\n    // This function will now loop through all objects and then only hit test the objects it HAS\n    // to, not all of them. MUCH faster..\n    // An object will be hit test if the following is true:\n    //\n    // 1: It is interactive.\n    // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.\n    //\n    // As another little optimisation once an interactive object has been hit we can carry on\n    // through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests\n    // A final optimisation is that an object is not hit test directly if a child has already been hit.\n\n    interactive = displayObject.interactive || interactive;\n\n    let hit = false;\n    let interactiveParent = interactive;\n\n    if (displayObject.interactiveChildren && displayObject.children) {\n      const children = displayObject.children;\n\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n\n        // time to get recursive.. if this function will return if something is hit..\n        const childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent);\n\n        if (childHit) {\n          // its a good idea to check if a child has lost its parent.\n          // this means it has been removed whilst looping so its best\n          if (!child.parent) {\n            continue;\n          }\n\n          // we no longer need to hit test any more objects in this container as we we\n          // now know the parent has been hit\n          interactiveParent = false;\n\n          // If the child is interactive , that means that the object hit was actually\n          // interactive and not just the child of an interactive object.\n          // This means we no longer need to hit test anything else. We still need to run\n          // through all objects, but we don't need to perform any hit tests.\n\n          if (childHit) {\n            if (interactionEvent.target) {\n              hitTest = false;\n            }\n            hit = true;\n          }\n        }\n      }\n    }\n\n    // no point running this if the item is not interactive or does not have an interactive parent.\n    if (interactive) {\n      // if we are hit testing (as in we have no hit any objects yet)\n      // We also don't need to worry about hit testing if once of the displayObjects children\n      // has already been hit - but only if it was interactive, otherwise we need to keep\n      // looking for an interactive child, just in case we hit one\n      if (hitTest && !interactionEvent.target) {\n        if (interactionEvent.intersects[0] && interactionEvent.intersects[0].object === displayObject) {\n          hit = true;\n        }\n      }\n\n      if (displayObject.interactive) {\n        if (hit && !interactionEvent.target) {\n          interactionEvent.data.target = interactionEvent.target = displayObject;\n        }\n\n        if (func) {\n          func(interactionEvent, displayObject, !!hit);\n        }\n      }\n    }\n\n    return hit;\n  }\n\n\n  /**\n   * Is called when the click is pressed down on the renderer element\n   *\n   * @private\n   * @param {MouseEvent} originalEvent - The DOM event of a click being pressed down\n   */\n  onClick(originalEvent) {\n    if (originalEvent.type !== 'click') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      originalEvent.preventDefault();\n    }\n\n    const interactionData = this.getInteractionDataForPointerId(events[0]);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, events[0], interactionData);\n\n    interactionEvent.data.originalEvent = originalEvent;\n\n    this.processInteractive(interactionEvent, this.scene, this.processClick, true);\n\n    this.emit('click', interactionEvent);\n  }\n\n  /**\n   * Processes the result of the click check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processClick(interactionEvent, displayObject, hit) {\n    if (hit) {\n      this.triggerEvent(displayObject, 'click', interactionEvent);\n    }\n  }\n\n  /**\n   * Is called when the pointer button is pressed down on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being pressed down\n   */\n  onPointerDown(originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    /**\n     * No need to prevent default on natural pointer events, as there are no side effects\n     * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n     * so still need to be prevented.\n     */\n\n    // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      originalEvent.preventDefault();\n    }\n\n    const eventLen = events.length;\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      this.processInteractive(interactionEvent, this.scene, this.processPointerDown, true);\n\n      this.emit('pointerdown', interactionEvent);\n      if (event.pointerType === 'touch') {\n        this.emit('touchstart', interactionEvent);\n      } else if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        const isRightButton = event.button === 2;\n\n        this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData);\n      }\n    }\n  }\n\n  /**\n   * Processes the result of the pointer down check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerDown(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n    const id = interactionEvent.data.identifier;\n\n    if (hit) {\n      if (!displayObject.trackedPointers[id]) {\n        displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n      }\n      this.triggerEvent(displayObject, 'pointerdown', interactionEvent);\n\n      if (data.pointerType === 'touch') {\n        displayObject.started = true;\n        this.triggerEvent(displayObject, 'touchstart', interactionEvent);\n      } else if (data.pointerType === 'mouse' || data.pointerType === 'pen') {\n        const isRightButton = data.button === 2;\n\n        if (isRightButton) {\n          displayObject.trackedPointers[id].rightDown = true;\n        } else {\n          displayObject.trackedPointers[id].leftDown = true;\n        }\n\n        this.triggerEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is released on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being released\n   * @param {boolean} cancelled - true if the pointer is cancelled\n   * @param {Function} func - Function passed to {@link processInteractive}\n   */\n  onPointerComplete(originalEvent, cancelled, func) {\n    const events = this.normalizeToPointerData(originalEvent);\n\n    const eventLen = events.length;\n\n    // if the event wasn't targeting our canvas, then consider it to be pointerupoutside\n    // in all cases (unless it was a pointercancel)\n    const eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      // perform hit testing for events targeting our canvas or cancel events\n      this.processInteractive(interactionEvent, this.scene, func, cancelled || !eventAppend);\n\n      this.emit(cancelled ? 'pointercancel' : `pointerup${eventAppend}`, interactionEvent);\n\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        const isRightButton = event.button === 2;\n\n        this.emit(isRightButton ? `rightup${eventAppend}` : `mouseup${eventAppend}`, interactionEvent);\n      } else if (event.pointerType === 'touch') {\n        this.emit(cancelled ? 'touchcancel' : `touchend${eventAppend}`, interactionEvent);\n        this.releaseInteractionDataForPointerId(event.pointerId, interactionData);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is cancelled\n   *\n   * @private\n   * @param {PointerEvent} event - The DOM event of a pointer button being released\n   */\n  onPointerCancel(event) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n\n    this.onPointerComplete(event, true, this.processPointerCancel);\n  }\n\n  /**\n   * Processes the result of the pointer cancel check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   */\n  processPointerCancel(interactionEvent, displayObject) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    if (displayObject.trackedPointers[id] !== undefined) {\n      delete displayObject.trackedPointers[id];\n      this.triggerEvent(displayObject, 'pointercancel', interactionEvent);\n\n      if (data.pointerType === 'touch') {\n        this.triggerEvent(displayObject, 'touchcancel', interactionEvent);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is released on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} event - The DOM event of a pointer button being released\n   */\n  onPointerUp(event) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n\n    this.onPointerComplete(event, false, this.processPointerUp);\n  }\n\n  /**\n   * Processes the result of the pointer up check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerUp(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    const trackingData = displayObject.trackedPointers[id];\n\n    const isTouch = data.pointerType === 'touch';\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    // Mouse only\n    if (isMouse) {\n      const isRightButton = data.button === 2;\n\n      const flags = InteractionTrackingData.FLAGS;\n\n      const test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;\n\n      const isDown = trackingData !== undefined && (trackingData.flags & test);\n\n      if (hit) {\n        this.triggerEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent);\n\n        if (isDown) {\n          this.triggerEvent(displayObject, isRightButton ? 'rightclick' : 'leftclick', interactionEvent);\n        }\n      } else if (isDown) {\n        this.triggerEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent);\n      }\n      // update the down state of the tracking data\n      if (trackingData) {\n        if (isRightButton) {\n          trackingData.rightDown = false;\n        } else {\n          trackingData.leftDown = false;\n        }\n      }\n    }\n\n    // Pointers and Touches, and Mouse\n    if (isTouch && displayObject.started) {\n      displayObject.started = false;\n      this.triggerEvent(displayObject, 'touchend', interactionEvent);\n    }\n    if (hit) {\n      this.triggerEvent(displayObject, 'pointerup', interactionEvent);\n\n      if (trackingData) {\n        this.triggerEvent(displayObject, 'pointertap', interactionEvent);\n        if (isTouch) {\n          this.triggerEvent(displayObject, 'tap', interactionEvent);\n          // touches are no longer over (if they ever were) when we get the touchend\n          // so we should ensure that we don't keep pretending that they are\n          trackingData.over = false;\n        }\n      }\n    } else if (trackingData) {\n      this.triggerEvent(displayObject, 'pointerupoutside', interactionEvent);\n      if (isTouch) this.triggerEvent(displayObject, 'touchendoutside', interactionEvent);\n    }\n    // Only remove the tracking data if there is no over/down state still associated with it\n    if (trackingData && trackingData.none) {\n      delete displayObject.trackedPointers[id];\n    }\n  }\n\n  /**\n   * Is called when the pointer moves across the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer moving\n   */\n  onPointerMove(originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    if (events[0].pointerType === 'mouse') {\n      this.didMove = true;\n\n      this.cursor = null;\n    }\n\n    const eventLen = events.length;\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      const interactive = event.pointerType === 'touch' ? this.moveWhenInside : true;\n\n      this.processInteractive(\n        interactionEvent,\n        this.scene,\n        this.processPointerMove,\n        interactive\n      );\n      this.emit('pointermove', interactionEvent);\n      if (event.pointerType === 'touch') this.emit('touchmove', interactionEvent);\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') this.emit('mousemove', interactionEvent);\n    }\n\n    if (events[0].pointerType === 'mouse') {\n      this.setCursorMode(this.cursor);\n\n      // TODO BUG for parents interactive object (border order issue)\n    }\n  }\n\n  /**\n   * Processes the result of the pointer move check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerMove(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const isTouch = data.pointerType === 'touch';\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    if (isMouse) {\n      this.processPointerOverOut(interactionEvent, displayObject, hit);\n    }\n\n    if (isTouch && displayObject.started) this.triggerEvent(displayObject, 'touchmove', interactionEvent);\n    if (!this.moveWhenInside || hit) {\n      this.triggerEvent(displayObject, 'pointermove', interactionEvent);\n      if (isMouse) this.triggerEvent(displayObject, 'mousemove', interactionEvent);\n    }\n  }\n\n  /**\n   * Is called when the pointer is moved out of the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out\n   */\n  onPointerOut(originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    // Only mouse and pointer can call onPointerOut, so events will always be length 1\n    const event = events[0];\n\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = false;\n      this.setCursorMode(null);\n    }\n\n    const interactionData = this.getInteractionDataForPointerId(event);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n    interactionEvent.data.originalEvent = event;\n\n    this.processInteractive(interactionEvent, this.scene, this.processPointerOverOut, false);\n\n    this.emit('pointerout', interactionEvent);\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseout', interactionEvent);\n    } else {\n      // we can get touchleave events after touchend, so we want to make sure we don't\n      // introduce memory leaks\n      this.releaseInteractionDataForPointerId(interactionData.identifier);\n    }\n  }\n\n  /**\n   * Processes the result of the pointer over/out check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerOverOut(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    let trackingData = displayObject.trackedPointers[id];\n\n    // if we just moused over the display object, then we need to track that state\n    if (hit && !trackingData) {\n      trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n    }\n\n    if (trackingData === undefined) return;\n\n    if (hit && this.mouseOverRenderer) {\n      if (!trackingData.over) {\n        trackingData.over = true;\n        this.triggerEvent(displayObject, 'pointerover', interactionEvent);\n        if (isMouse) {\n          this.triggerEvent(displayObject, 'mouseover', interactionEvent);\n        }\n      }\n\n      // only change the cursor if it has not already been changed (by something deeper in the\n      // display tree)\n      if (isMouse && this.cursor === null) {\n        this.cursor = displayObject.cursor;\n      }\n    } else if (trackingData.over) {\n      trackingData.over = false;\n      this.triggerEvent(displayObject, 'pointerout', this.eventData);\n      if (isMouse) {\n        this.triggerEvent(displayObject, 'mouseout', interactionEvent);\n      }\n      // if there is no mouse down information for the pointer, then it is safe to delete\n      if (trackingData.none) {\n        delete displayObject.trackedPointers[id];\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer is moved into the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being moved into the renderer view\n   */\n  onPointerOver(originalEvent) {\n    const events = this.normalizeToPointerData(originalEvent);\n\n    // Only mouse and pointer can call onPointerOver, so events will always be length 1\n    const event = events[0];\n\n    const interactionData = this.getInteractionDataForPointerId(event);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n    interactionEvent.data.originalEvent = event;\n\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = true;\n    }\n\n    this.emit('pointerover', interactionEvent);\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseover', interactionEvent);\n    }\n  }\n\n  /**\n   * Get InteractionData for a given pointerId. Store that data as well\n   *\n   * @private\n   * @param {PointerEvent} event - Normalized pointer event, output from normalizeToPointerData\n   * @return {InteractionData} - Interaction data for the given pointer identifier\n   */\n  getInteractionDataForPointerId(event) {\n    const pointerId = event.pointerId;\n\n    let interactionData;\n\n    if (pointerId === MOUSE_POINTER_ID || event.pointerType === 'mouse') {\n      interactionData = this.mouse;\n    } else if (this.activeInteractionData[pointerId]) {\n      interactionData = this.activeInteractionData[pointerId];\n    } else {\n      interactionData = this.interactionDataPool.pop() || new InteractionData();\n      interactionData.identifier = pointerId;\n      this.activeInteractionData[pointerId] = interactionData;\n    }\n    // copy properties from the event, so that we can make sure that touch/pointer specific\n    // data is available\n    interactionData._copyEvent(event);\n\n    return interactionData;\n  }\n\n  /**\n   * Return unused InteractionData to the pool, for a given pointerId\n   *\n   * @private\n   * @param {number} pointerId - Identifier from a pointer event\n   */\n  releaseInteractionDataForPointerId(pointerId) {\n    const interactionData = this.activeInteractionData[pointerId];\n\n    if (interactionData) {\n      delete this.activeInteractionData[pointerId];\n      interactionData._reset();\n      this.interactionDataPool.push(interactionData);\n    }\n  }\n\n  /**\n   * Maps x and y coords from a DOM object and maps them correctly to the three.js view. The\n   * resulting value is stored in the point. This takes into account the fact that the DOM\n   * element could be scaled and positioned anywhere on the screen.\n   *\n   * @param  {Vector2} point - the point that the result will be stored in\n   * @param  {number} x - the x coord of the position to map\n   * @param  {number} y - the y coord of the position to map\n   */\n  mapPositionToPoint(point, x, y) {\n    let rect;\n\n    // IE 11 fix\n    if (!this.interactionDOMElement.parentElement) {\n      rect = {\n        x: 0,\n        y: 0,\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0,\n      };\n    } else {\n      rect = this.interactionDOMElement.getBoundingClientRect();\n    }\n\n    point.x = ((x - rect.left) / rect.width) * 2 - 1;\n    point.y = -((y - rect.top) / rect.height) * 2 + 1;\n  }\n\n  /**\n   * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The event to be configured\n   * @param {PointerEvent} pointerEvent - The DOM event that will be paired with the InteractionEvent\n   * @param {InteractionData} interactionData - The InteractionData that will be paired\n   *        with the InteractionEvent\n   * @return {InteractionEvent} the interaction event that was passed in\n   */\n  configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {\n    interactionEvent.data = interactionData;\n\n    this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);\n\n    this.raycaster.setFromCamera(interactionData.global, this.camera);\n\n    // Not really sure why this is happening, but it's how a previous version handled things TODO: there should be remove\n    if (pointerEvent.pointerType === 'touch') {\n      pointerEvent.globalX = interactionData.global.x;\n      pointerEvent.globalY = interactionData.global.y;\n    }\n\n    interactionData.originalEvent = pointerEvent;\n    interactionEvent._reset();\n    interactionEvent.intersects = this.raycaster.intersectObjects(this.scene.children, true);\n\n    return interactionEvent;\n  }\n\n  /**\n   * Ensures that the original event object contains all data that a regular pointer event would have\n   *\n   * @private\n   * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event\n   * @return {PointerEvent[]} An array containing a single normalized pointer event, in the case of a pointer\n   *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n   */\n  normalizeToPointerData(event) {\n    const normalizedEvents = [];\n\n    if (this.supportsTouchEvents && event instanceof TouchEvent) {\n      for (let i = 0, li = event.changedTouches.length; i < li; i++) {\n        const touch = event.changedTouches[i];\n\n        if (typeof touch.button === 'undefined') touch.button = event.touches.length ? 1 : 0;\n        if (typeof touch.buttons === 'undefined') touch.buttons = event.touches.length ? 1 : 0;\n        if (typeof touch.isPrimary === 'undefined') {\n          touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n        }\n        if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n        if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n        if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n        if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n        if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n        if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n        if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n        touch.twist = 0;\n        touch.tangentialPressure = 0;\n        // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n        // support, and the fill ins are not quite the same\n        // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n        // left is not 0,0 on the page\n        if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n        if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY;\n\n        // mark the touch as normalized, just so that we know we did it\n        touch.isNormalized = true;\n\n        normalizedEvents.push(touch);\n      }\n    } else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent))) {\n      if (typeof event.isPrimary === 'undefined') event.isPrimary = true;\n      if (typeof event.width === 'undefined') event.width = 1;\n      if (typeof event.height === 'undefined') event.height = 1;\n      if (typeof event.tiltX === 'undefined') event.tiltX = 0;\n      if (typeof event.tiltY === 'undefined') event.tiltY = 0;\n      if (typeof event.pointerType === 'undefined') event.pointerType = 'mouse';\n      if (typeof event.pointerId === 'undefined') event.pointerId = MOUSE_POINTER_ID;\n      if (typeof event.pressure === 'undefined') event.pressure = 0.5;\n      event.twist = 0;\n      event.tangentialPressure = 0;\n\n      // mark the mouse event as normalized, just so that we know we did it\n      event.isNormalized = true;\n\n      normalizedEvents.push(event);\n    } else {\n      normalizedEvents.push(event);\n    }\n\n    return normalizedEvents;\n  }\n\n  /**\n   * Destroys the interaction manager\n   *\n   */\n  destroy() {\n    this.removeEvents();\n\n    this.removeAllListeners();\n\n    this.renderer = null;\n\n    this.mouse = null;\n\n    this.eventData = null;\n\n    this.interactionDOMElement = null;\n\n    this.onPointerDown = null;\n    this.processPointerDown = null;\n\n    this.onPointerUp = null;\n    this.processPointerUp = null;\n\n    this.onPointerCancel = null;\n    this.processPointerCancel = null;\n\n    this.onPointerMove = null;\n    this.processPointerMove = null;\n\n    this.onPointerOut = null;\n    this.processPointerOverOut = null;\n\n    this.onPointerOver = null;\n\n    this._tempPoint = null;\n  }\n}\n\nexport default InteractionManager;\n","import '../patch/EventDispatcher';\nimport '../patch/Object3D';\n\nimport { EventDispatcher, Raycaster } from 'three';\nimport InteractionData from './InteractionData';\nimport InteractionEvent from './InteractionEvent';\nimport InteractionTrackingData from './InteractionTrackingData';\n\nconst MOUSE_POINTER_ID = 'MOUSE';\n\n// helpers for hitTest() - only used inside hitTest()\nconst hitTestEvent = {\n  target: null,\n  data: {\n    global: null,\n  },\n};\n\n/**\n * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive\n * if its interactive parameter is set to true\n * This manager also supports multitouch.\n *\n * reference to [pixi.js](http://www.pixijs.com/) impl\n *\n * @private\n * @class\n * @extends EventDispatcher\n */\nclass InteractionLayer extends EventDispatcher {\n  /**\n   * @param {WebGLRenderer} renderer - A reference to the current renderer\n   * @param {Object} [options] - The options for the manager.\n   * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.\n   * @param {Boolean} [options.autoAttach=true] - Should the manager automatically attach target element.\n   * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.\n   */\n  constructor(renderer, options) {\n    super();\n\n    options = options || {};\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {WebGLRenderer}\n     */\n    this.renderer = renderer;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Layer}\n     */\n    this.layer = null;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Scene}\n     */\n    // this.scene = scene;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Camera}\n     */\n    // this.camera = camera;\n\n    /**\n     * Should default browser actions automatically be prevented.\n     * Does not apply to pointer events for backwards compatibility\n     * preventDefault on pointer events stops mouse events from firing\n     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.\n     *\n     * @member {boolean}\n     * @default false\n     */\n    this.autoPreventDefault = options.autoPreventDefault || false;\n\n    /**\n     * Frequency in milliseconds that the mousemove, moveover & mouseout interaction events will be checked.\n     *\n     * @member {number}\n     * @default 10\n     */\n    this.interactionFrequency = options.interactionFrequency || 10;\n\n    /**\n     * The mouse data\n     *\n     * @member {InteractionData}\n     */\n    this.mouse = new InteractionData();\n    this.mouse.identifier = MOUSE_POINTER_ID;\n\n    // setting the mouse to start off far off screen will mean that mouse over does\n    //  not get called before we even move the mouse.\n    this.mouse.global.set(-999999);\n\n    /**\n     * Actively tracked InteractionData\n     *\n     * @private\n     * @member {Object.<number,InteractionData>}\n     */\n    this.activeInteractionData = {};\n    this.activeInteractionData[MOUSE_POINTER_ID] = this.mouse;\n\n    /**\n     * Pool of unused InteractionData\n     *\n     * @private\n     * @member {InteractionData[]}\n     */\n    this.interactionDataPool = [];\n\n    /**\n     * An event data object to handle all the event tracking/dispatching\n     *\n     * @member {object}\n     */\n    this.eventData = new InteractionEvent();\n\n    /**\n     * The DOM element to bind to.\n     *\n     * @private\n     * @member {HTMLElement}\n     */\n    this.interactionDOMElement = null;\n\n    /**\n     * This property determines if mousemove and touchmove events are fired only when the cursor\n     * is over the object.\n     * Setting to true will make things work more in line with how the DOM verison works.\n     * Setting to false can make things easier for things like dragging\n     * It is currently set to false as this is how three.js used to work.\n     *\n     * @member {boolean}\n     * @default true\n     */\n    this.moveWhenInside = true;\n\n    /**\n     * Have events been attached to the dom element?\n     *\n     * @private\n     * @member {boolean}\n     */\n    this.eventsAdded = false;\n\n    /**\n     * Is the mouse hovering over the renderer?\n     *\n     * @private\n     * @member {boolean}\n     */\n    this.mouseOverRenderer = false;\n\n    /**\n     * Does the device support touch events\n     * https://www.w3.org/TR/touch-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    this.supportsTouchEvents = 'ontouchstart' in window;\n\n    /**\n     * Does the device support pointer events\n     * https://www.w3.org/Submission/pointer-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    this.supportsPointerEvents = !!window.PointerEvent;\n\n    // this will make it so that you don't have to call bind all the time\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onClick = this.onClick.bind(this);\n    this.processClick = this.processClick.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerUp = this.onPointerUp.bind(this);\n    this.processPointerUp = this.processPointerUp.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerCancel = this.onPointerCancel.bind(this);\n    this.processPointerCancel = this.processPointerCancel.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerDown = this.onPointerDown.bind(this);\n    this.processPointerDown = this.processPointerDown.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerMove = this.onPointerMove.bind(this);\n    this.processPointerMove = this.processPointerMove.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerOut = this.onPointerOut.bind(this);\n    this.processPointerOverOut = this.processPointerOverOut.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerOver = this.onPointerOver.bind(this);\n\n    /**\n     * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor\n     * values, objects are handled as dictionaries of CSS values for interactionDOMElement,\n     * and functions are called instead of changing the CSS.\n     * Default CSS cursor values are provided for 'default' and 'pointer' modes.\n     * @member {Object.<string, (string|Function|Object.<string, string>)>}\n     */\n    this.cursorStyles = {\n      default: 'inherit',\n      pointer: 'pointer',\n    };\n\n    /**\n     * The mode of the cursor that is being used.\n     * The value of this is a key from the cursorStyles dictionary.\n     *\n     * @member {string}\n     */\n    this.currentCursorMode = null;\n\n    /**\n     * Internal cached let.\n     *\n     * @private\n     * @member {string}\n     */\n    this.cursor = null;\n\n    /**\n     * ray caster, for survey intersects from 3d-scene\n     *\n     * @private\n     * @member {Raycaster}\n     */\n    this.raycaster = new Raycaster();\n\n    /**\n     * snippet time\n     *\n     * @private\n     * @member {Number}\n     */\n    this._deltaTime = 0;\n\n    this.setTargetElement(this.renderer.domElement);\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display\n     * object.\n     *\n     * @event InteractionLayer#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object.\n     *\n     * @event InteractionLayer#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object.\n     *\n     * @event InteractionLayer#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object.\n     *\n     * @event InteractionLayer#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object.\n     *\n     * @event InteractionLayer#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object.\n     *\n     * @event InteractionLayer#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link InteractionLayer#event:mousedown}.\n     *\n     * @event InteractionLayer#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link InteractionLayer#event:rightdown}.\n     *\n     * @event InteractionLayer#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object\n     *\n     * @event InteractionLayer#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object\n     *\n     * @event InteractionLayer#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object\n     *\n     * @event InteractionLayer#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     *\n     * @event InteractionLayer#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     *\n     * @event InteractionLayer#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event\n     *\n     * @event InteractionLayer#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     *\n     * @event InteractionLayer#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link InteractionLayer#event:pointerdown}.\n     *\n     * @event InteractionLayer#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object\n     *\n     * @event InteractionLayer#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object\n     *\n     * @event InteractionLayer#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object\n     *\n     * @event InteractionLayer#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     *\n     * @event InteractionLayer#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     *\n     * @event InteractionLayer#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch\n     *\n     * @event InteractionLayer#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     *\n     * @event InteractionLayer#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link InteractionLayer#event:touchstart}.\n     *\n     * @event InteractionLayer#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     *\n     * @event InteractionLayer#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link Object3D#event:mousedown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link Object3D#event:rightdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link Object3D#event:pointerdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link Object3D#event:touchstart}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isAble() {\n    return this.layer && this.layer.interactive;\n  }\n\n  /**\n   * set layer\n   * @param {Layer} layer layer\n   */\n  setLayer(layer) {\n    this.layer = layer;\n  }\n\n  /**\n   * Hit tests a point against the display tree, returning the first interactive object that is hit.\n   *\n   * @param {Point} globalPoint - A point to hit test with, in global space.\n   * @param {Object3D} [root] - The root display object to start from. If omitted, defaults\n   * to the last rendered root of the associated renderer.\n   * @return {Object3D} The hit display object, if any.\n   */\n  hitTest(globalPoint, root) {\n    if (!this.isAble()) return null;\n    // clear the target for our hit test\n    hitTestEvent.target = null;\n    // assign the global point\n    hitTestEvent.data.global = globalPoint;\n    // ensure safety of the root\n    if (!root) {\n      root = this.layer.scene;\n    }\n    // run the hit test\n    this.processInteractive(hitTestEvent, root, null, true);\n    // return our found object - it'll be null if we didn't hit anything\n\n    return hitTestEvent.target;\n  }\n\n  /**\n   * Sets the DOM element which will receive mouse/touch events. This is useful for when you have\n   * other DOM elements on top of the renderers Canvas element. With this you'll be bale to deletegate\n   * another DOM element to receive those events.\n   *\n   * @param {HTMLCanvasElement} element - the DOM element which will receive mouse and touch events.\n   */\n  setTargetElement(element) {\n    this.removeEvents();\n\n    this.interactionDOMElement = element;\n\n    this.addEvents();\n  }\n\n  /**\n   * Registers all the DOM events\n   *\n   * @private\n   */\n  addEvents() {\n    if (!this.interactionDOMElement || this.eventsAdded) {\n      return;\n    }\n\n    this.emit('addevents');\n\n    this.interactionDOMElement.addEventListener('click', this.onClick, true);\n\n    if (window.navigator.msPointerEnabled) {\n      this.interactionDOMElement.style['-ms-content-zooming'] = 'none';\n      this.interactionDOMElement.style['-ms-touch-action'] = 'none';\n    } else if (this.supportsPointerEvents) {\n      this.interactionDOMElement.style['touch-action'] = 'none';\n    }\n\n    /**\n     * These events are added first, so that if pointer events are normalised, they are fired\n     * in the same order as non-normalised events. ie. pointer event 1st, mouse / touch 2nd\n     */\n    if (this.supportsPointerEvents) {\n      window.document.addEventListener('pointermove', this.onPointerMove, true);\n      this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, true);\n      // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n      // we already handle those, so for the purposes of what we do in onPointerOut, we only\n      // care about the pointerleave event\n      this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, true);\n      this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, true);\n      window.addEventListener('pointercancel', this.onPointerCancel, true);\n      window.addEventListener('pointerup', this.onPointerUp, true);\n    } else {\n      window.document.addEventListener('mousemove', this.onPointerMove, true);\n      this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, true);\n      this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, true);\n      this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, true);\n      window.addEventListener('mouseup', this.onPointerUp, true);\n    }\n\n    // always look directly for touch events so that we can provide original data\n    // In a future version we should change this to being just a fallback and rely solely on\n    // PointerEvents whenever available\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, true);\n      this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, true);\n      this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, true);\n      this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, true);\n    }\n\n    this.eventsAdded = true;\n  }\n\n  /**\n   * Removes all the DOM events that were previously registered\n   *\n   * @private\n   */\n  removeEvents() {\n    if (!this.interactionDOMElement) {\n      return;\n    }\n\n    this.emit('removeevents');\n\n    this.interactionDOMElement.removeEventListener('click', this.onClick, true);\n\n    if (window.navigator.msPointerEnabled) {\n      this.interactionDOMElement.style['-ms-content-zooming'] = '';\n      this.interactionDOMElement.style['-ms-touch-action'] = '';\n    } else if (this.supportsPointerEvents) {\n      this.interactionDOMElement.style['touch-action'] = '';\n    }\n\n    if (this.supportsPointerEvents) {\n      window.document.removeEventListener('pointermove', this.onPointerMove, true);\n      this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, true);\n      this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, true);\n      window.removeEventListener('pointercancel', this.onPointerCancel, true);\n      window.removeEventListener('pointerup', this.onPointerUp, true);\n    } else {\n      window.document.removeEventListener('mousemove', this.onPointerMove, true);\n      this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, true);\n      this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, true);\n      window.removeEventListener('mouseup', this.onPointerUp, true);\n    }\n\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n      this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, true);\n      this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, true);\n    }\n\n    this.interactionDOMElement = null;\n\n    this.eventsAdded = false;\n  }\n\n  /**\n   * Updates the state of interactive objects.\n   * Invoked by a throttled ticker.\n   *\n   * @param {number} deltaTime - time delta since last tick\n   */\n  update({ snippet }) {\n    if (!this.isAble()) return;\n    this._deltaTime += snippet;\n\n    if (this._deltaTime < this.interactionFrequency) {\n      return;\n    }\n\n    this._deltaTime = 0;\n\n    if (!this.interactionDOMElement) {\n      return;\n    }\n\n    // if the user move the mouse this check has already been done using the mouse move!\n    if (this.didMove) {\n      this.didMove = false;\n\n      return;\n    }\n\n    this.cursor = null;\n\n    // Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,\n    // but there was a scenario of a display object moving under a static mouse cursor.\n    // In this case, mouseover and mouseevents would not pass the flag test in triggerEvent function\n    for (const k in this.activeInteractionData) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (this.activeInteractionData.hasOwnProperty(k)) {\n        const interactionData = this.activeInteractionData[k];\n\n        if (interactionData.originalEvent && interactionData.pointerType !== 'touch') {\n          const interactionEvent = this.configureInteractionEventForDOMEvent(\n            this.eventData,\n            interactionData.originalEvent,\n            interactionData\n          );\n\n          this.processInteractive(\n            interactionEvent,\n            this.layer.scene,\n            this.processPointerOverOut,\n            true\n          );\n        }\n      }\n    }\n\n    this.setCursorMode(this.cursor);\n\n    // TODO\n  }\n\n  /**\n   * Sets the current cursor mode, handling any callbacks or CSS style changes.\n   *\n   * @param {string} mode - cursor mode, a key from the cursorStyles dictionary\n   */\n  setCursorMode(mode) {\n    mode = mode || 'default';\n    // if the mode didn't actually change, bail early\n    if (this.currentCursorMode === mode) {\n      return;\n    }\n    this.currentCursorMode = mode;\n    const style = this.cursorStyles[mode];\n\n    // only do things if there is a cursor style for it\n    if (style) {\n      switch (typeof style) {\n        case 'string':\n          // string styles are handled as cursor CSS\n          this.interactionDOMElement.style.cursor = style;\n          break;\n        case 'function':\n          // functions are just called, and passed the cursor mode\n          style(mode);\n          break;\n        case 'object':\n          // if it is an object, assume that it is a dictionary of CSS styles,\n          // apply it to the interactionDOMElement\n          Object.assign(this.interactionDOMElement.style, style);\n          break;\n        default:\n          break;\n      }\n    } else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n      // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n      // for the mode, then assume that the dev wants it to be CSS for the cursor.\n      this.interactionDOMElement.style.cursor = mode;\n    }\n  }\n\n  /**\n   * Dispatches an event on the display object that was interacted with\n   *\n   * @param {Object3D} displayObject - the display object in question\n   * @param {string} eventString - the name of the event (e.g, mousedown)\n   * @param {object} eventData - the event data object\n   * @private\n   */\n  triggerEvent(displayObject, eventString, eventData) {\n    if (!eventData.stopped) {\n      eventData.currentTarget = displayObject;\n      eventData.type = eventString;\n\n      displayObject.emit(eventString, eventData);\n\n      if (displayObject[eventString]) {\n        displayObject[eventString](eventData);\n      }\n    }\n  }\n\n  /**\n   * This function is provides a neat way of crawling through the scene graph and running a\n   * specified function on all interactive objects it finds. It will also take care of hit\n   * testing the interactive objects and passes the hit across in the function.\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - event containing the point that\n   *  is tested for collision\n   * @param {Object3D} displayObject - the displayObject\n   *  that will be hit test (recursively crawls its children)\n   * @param {Function} [func] - the function that will be called on each interactive object. The\n   *  interactionEvent, displayObject and hit will be passed to the function\n   * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point\n   * @param {boolean} [interactive] - Whether the displayObject is interactive\n   * @return {boolean} returns true if the displayObject hit the point\n   */\n  processInteractive(interactionEvent, displayObject, func, hitTest, interactive) {\n    if (!displayObject || !displayObject.visible) {\n      return false;\n    }\n\n    // Took a little while to rework this function correctly! But now it is done and nice and optimised. ^_^\n    //\n    // This function will now loop through all objects and then only hit test the objects it HAS\n    // to, not all of them. MUCH faster..\n    // An object will be hit test if the following is true:\n    //\n    // 1: It is interactive.\n    // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.\n    //\n    // As another little optimisation once an interactive object has been hit we can carry on\n    // through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests\n    // A final optimisation is that an object is not hit test directly if a child has already been hit.\n\n    interactive = displayObject.interactive || interactive;\n\n    let hit = false;\n    let interactiveParent = interactive;\n\n    if (displayObject.interactiveChildren && displayObject.children) {\n      const children = displayObject.children;\n\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n\n        // time to get recursive.. if this function will return if something is hit..\n        const childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent);\n\n        if (childHit) {\n          // its a good idea to check if a child has lost its parent.\n          // this means it has been removed whilst looping so its best\n          if (!child.parent) {\n            continue;\n          }\n\n          // we no longer need to hit test any more objects in this container as we we\n          // now know the parent has been hit\n          interactiveParent = false;\n\n          // If the child is interactive , that means that the object hit was actually\n          // interactive and not just the child of an interactive object.\n          // This means we no longer need to hit test anything else. We still need to run\n          // through all objects, but we don't need to perform any hit tests.\n\n          if (childHit) {\n            if (interactionEvent.target) {\n              hitTest = false;\n            }\n            hit = true;\n          }\n        }\n      }\n    }\n\n    // no point running this if the item is not interactive or does not have an interactive parent.\n    if (interactive) {\n      // if we are hit testing (as in we have no hit any objects yet)\n      // We also don't need to worry about hit testing if once of the displayObjects children\n      // has already been hit - but only if it was interactive, otherwise we need to keep\n      // looking for an interactive child, just in case we hit one\n      if (hitTest && !interactionEvent.target) {\n        if (interactionEvent.intersects[0] && interactionEvent.intersects[0].object === displayObject) {\n          hit = true;\n        }\n      }\n\n      if (displayObject.interactive) {\n        if (hit && !interactionEvent.target) {\n          interactionEvent.data.target = interactionEvent.target = displayObject;\n        }\n\n        if (func) {\n          func(interactionEvent, displayObject, !!hit);\n        }\n      }\n    }\n\n    return hit;\n  }\n\n\n  /**\n   * Is called when the click is pressed down on the renderer element\n   *\n   * @private\n   * @param {MouseEvent} originalEvent - The DOM event of a click being pressed down\n   */\n  onClick(originalEvent) {\n    if (!this.isAble()) return;\n    if (originalEvent.type !== 'click') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      originalEvent.preventDefault();\n    }\n\n    const interactionData = this.getInteractionDataForPointerId(events[0]);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, events[0], interactionData);\n\n    interactionEvent.data.originalEvent = originalEvent;\n\n    this.processInteractive(interactionEvent, this.layer.scene, this.processClick, true);\n\n    this.emit('click', interactionEvent);\n  }\n\n  /**\n   * Processes the result of the click check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processClick(interactionEvent, displayObject, hit) {\n    if (hit) {\n      this.triggerEvent(displayObject, 'click', interactionEvent);\n    }\n  }\n\n  /**\n   * Is called when the pointer button is pressed down on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being pressed down\n   */\n  onPointerDown(originalEvent) {\n    if (!this.isAble()) return;\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    /**\n     * No need to prevent default on natural pointer events, as there are no side effects\n     * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n     * so still need to be prevented.\n     */\n\n    // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      originalEvent.preventDefault();\n    }\n\n    const eventLen = events.length;\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      this.processInteractive(interactionEvent, this.layer.scene, this.processPointerDown, true);\n\n      this.emit('pointerdown', interactionEvent);\n      if (event.pointerType === 'touch') {\n        this.emit('touchstart', interactionEvent);\n      } else if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        const isRightButton = event.button === 2;\n\n        this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData);\n      }\n    }\n  }\n\n  /**\n   * Processes the result of the pointer down check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerDown(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n    const id = interactionEvent.data.identifier;\n\n    if (hit) {\n      if (!displayObject.trackedPointers[id]) {\n        displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n      }\n      this.triggerEvent(displayObject, 'pointerdown', interactionEvent);\n\n      if (data.pointerType === 'touch') {\n        displayObject.started = true;\n        this.triggerEvent(displayObject, 'touchstart', interactionEvent);\n      } else if (data.pointerType === 'mouse' || data.pointerType === 'pen') {\n        const isRightButton = data.button === 2;\n\n        if (isRightButton) {\n          displayObject.trackedPointers[id].rightDown = true;\n        } else {\n          displayObject.trackedPointers[id].leftDown = true;\n        }\n\n        this.triggerEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is released on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being released\n   * @param {boolean} cancelled - true if the pointer is cancelled\n   * @param {Function} func - Function passed to {@link processInteractive}\n   */\n  onPointerComplete(originalEvent, cancelled, func) {\n    const events = this.normalizeToPointerData(originalEvent);\n\n    const eventLen = events.length;\n\n    // if the event wasn't targeting our canvas, then consider it to be pointerupoutside\n    // in all cases (unless it was a pointercancel)\n    const eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      // perform hit testing for events targeting our canvas or cancel events\n      this.processInteractive(interactionEvent, this.layer.scene, func, cancelled || !eventAppend);\n\n      this.emit(cancelled ? 'pointercancel' : `pointerup${eventAppend}`, interactionEvent);\n\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        const isRightButton = event.button === 2;\n\n        this.emit(isRightButton ? `rightup${eventAppend}` : `mouseup${eventAppend}`, interactionEvent);\n      } else if (event.pointerType === 'touch') {\n        this.emit(cancelled ? 'touchcancel' : `touchend${eventAppend}`, interactionEvent);\n        this.releaseInteractionDataForPointerId(event.pointerId, interactionData);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is cancelled\n   *\n   * @private\n   * @param {PointerEvent} event - The DOM event of a pointer button being released\n   */\n  onPointerCancel(event) {\n    if (!this.isAble()) return;\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n\n    this.onPointerComplete(event, true, this.processPointerCancel);\n  }\n\n  /**\n   * Processes the result of the pointer cancel check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   */\n  processPointerCancel(interactionEvent, displayObject) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    if (displayObject.trackedPointers[id] !== undefined) {\n      delete displayObject.trackedPointers[id];\n      this.triggerEvent(displayObject, 'pointercancel', interactionEvent);\n\n      if (data.pointerType === 'touch') {\n        this.triggerEvent(displayObject, 'touchcancel', interactionEvent);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is released on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} event - The DOM event of a pointer button being released\n   */\n  onPointerUp(event) {\n    if (!this.isAble()) return;\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n\n    this.onPointerComplete(event, false, this.processPointerUp);\n  }\n\n  /**\n   * Processes the result of the pointer up check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerUp(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    const trackingData = displayObject.trackedPointers[id];\n\n    const isTouch = data.pointerType === 'touch';\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    // Mouse only\n    if (isMouse) {\n      const isRightButton = data.button === 2;\n\n      const flags = InteractionTrackingData.FLAGS;\n\n      const test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;\n\n      const isDown = trackingData !== undefined && (trackingData.flags & test);\n\n      if (hit) {\n        this.triggerEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent);\n\n        if (isDown) {\n          this.triggerEvent(displayObject, isRightButton ? 'rightclick' : 'leftclick', interactionEvent);\n        }\n      } else if (isDown) {\n        this.triggerEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent);\n      }\n      // update the down state of the tracking data\n      if (trackingData) {\n        if (isRightButton) {\n          trackingData.rightDown = false;\n        } else {\n          trackingData.leftDown = false;\n        }\n      }\n    }\n\n    // Pointers and Touches, and Mouse\n    if (isTouch && displayObject.started) {\n      displayObject.started = false;\n      this.triggerEvent(displayObject, 'touchend', interactionEvent);\n    }\n    if (hit) {\n      this.triggerEvent(displayObject, 'pointerup', interactionEvent);\n\n      if (trackingData) {\n        this.triggerEvent(displayObject, 'pointertap', interactionEvent);\n        if (isTouch) {\n          this.triggerEvent(displayObject, 'tap', interactionEvent);\n          // touches are no longer over (if they ever were) when we get the touchend\n          // so we should ensure that we don't keep pretending that they are\n          trackingData.over = false;\n        }\n      }\n    } else if (trackingData) {\n      this.triggerEvent(displayObject, 'pointerupoutside', interactionEvent);\n      if (isTouch) this.triggerEvent(displayObject, 'touchendoutside', interactionEvent);\n    }\n    // Only remove the tracking data if there is no over/down state still associated with it\n    if (trackingData && trackingData.none) {\n      delete displayObject.trackedPointers[id];\n    }\n  }\n\n  /**\n   * Is called when the pointer moves across the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer moving\n   */\n  onPointerMove(originalEvent) {\n    if (!this.isAble()) return;\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    if (events[0].pointerType === 'mouse') {\n      this.didMove = true;\n\n      this.cursor = null;\n    }\n\n    const eventLen = events.length;\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      const interactive = event.pointerType === 'touch' ? this.moveWhenInside : true;\n\n      this.processInteractive(\n        interactionEvent,\n        this.layer.scene,\n        this.processPointerMove,\n        interactive\n      );\n      this.emit('pointermove', interactionEvent);\n      if (event.pointerType === 'touch') this.emit('touchmove', interactionEvent);\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') this.emit('mousemove', interactionEvent);\n    }\n\n    if (events[0].pointerType === 'mouse') {\n      this.setCursorMode(this.cursor);\n\n      // TODO BUG for parents interactive object (border order issue)\n    }\n  }\n\n  /**\n   * Processes the result of the pointer move check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerMove(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const isTouch = data.pointerType === 'touch';\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    if (isMouse) {\n      this.processPointerOverOut(interactionEvent, displayObject, hit);\n    }\n\n    if (isTouch && displayObject.started) this.triggerEvent(displayObject, 'touchmove', interactionEvent);\n    if (!this.moveWhenInside || hit) {\n      this.triggerEvent(displayObject, 'pointermove', interactionEvent);\n      if (isMouse) this.triggerEvent(displayObject, 'mousemove', interactionEvent);\n    }\n  }\n\n  /**\n   * Is called when the pointer is moved out of the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out\n   */\n  onPointerOut(originalEvent) {\n    if (!this.isAble()) return;\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    // Only mouse and pointer can call onPointerOut, so events will always be length 1\n    const event = events[0];\n\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = false;\n      this.setCursorMode(null);\n    }\n\n    const interactionData = this.getInteractionDataForPointerId(event);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n    interactionEvent.data.originalEvent = event;\n\n    this.processInteractive(interactionEvent, this.layer.scene, this.processPointerOverOut, false);\n\n    this.emit('pointerout', interactionEvent);\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseout', interactionEvent);\n    } else {\n      // we can get touchleave events after touchend, so we want to make sure we don't\n      // introduce memory leaks\n      this.releaseInteractionDataForPointerId(interactionData.identifier);\n    }\n  }\n\n  /**\n   * Processes the result of the pointer over/out check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerOverOut(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    let trackingData = displayObject.trackedPointers[id];\n\n    // if we just moused over the display object, then we need to track that state\n    if (hit && !trackingData) {\n      trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n    }\n\n    if (trackingData === undefined) return;\n\n    if (hit && this.mouseOverRenderer) {\n      if (!trackingData.over) {\n        trackingData.over = true;\n        this.triggerEvent(displayObject, 'pointerover', interactionEvent);\n        if (isMouse) {\n          this.triggerEvent(displayObject, 'mouseover', interactionEvent);\n        }\n      }\n\n      // only change the cursor if it has not already been changed (by something deeper in the\n      // display tree)\n      if (isMouse && this.cursor === null) {\n        this.cursor = displayObject.cursor;\n      }\n    } else if (trackingData.over) {\n      trackingData.over = false;\n      this.triggerEvent(displayObject, 'pointerout', this.eventData);\n      if (isMouse) {\n        this.triggerEvent(displayObject, 'mouseout', interactionEvent);\n      }\n      // if there is no mouse down information for the pointer, then it is safe to delete\n      if (trackingData.none) {\n        delete displayObject.trackedPointers[id];\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer is moved into the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being moved into the renderer view\n   */\n  onPointerOver(originalEvent) {\n    if (!this.isAble()) return;\n    const events = this.normalizeToPointerData(originalEvent);\n\n    // Only mouse and pointer can call onPointerOver, so events will always be length 1\n    const event = events[0];\n\n    const interactionData = this.getInteractionDataForPointerId(event);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n    interactionEvent.data.originalEvent = event;\n\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = true;\n    }\n\n    this.emit('pointerover', interactionEvent);\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseover', interactionEvent);\n    }\n  }\n\n  /**\n   * Get InteractionData for a given pointerId. Store that data as well\n   *\n   * @private\n   * @param {PointerEvent} event - Normalized pointer event, output from normalizeToPointerData\n   * @return {InteractionData} - Interaction data for the given pointer identifier\n   */\n  getInteractionDataForPointerId(event) {\n    const pointerId = event.pointerId;\n\n    let interactionData;\n\n    if (pointerId === MOUSE_POINTER_ID || event.pointerType === 'mouse') {\n      interactionData = this.mouse;\n    } else if (this.activeInteractionData[pointerId]) {\n      interactionData = this.activeInteractionData[pointerId];\n    } else {\n      interactionData = this.interactionDataPool.pop() || new InteractionData();\n      interactionData.identifier = pointerId;\n      this.activeInteractionData[pointerId] = interactionData;\n    }\n    // copy properties from the event, so that we can make sure that touch/pointer specific\n    // data is available\n    interactionData._copyEvent(event);\n\n    return interactionData;\n  }\n\n  /**\n   * Return unused InteractionData to the pool, for a given pointerId\n   *\n   * @private\n   * @param {number} pointerId - Identifier from a pointer event\n   */\n  releaseInteractionDataForPointerId(pointerId) {\n    const interactionData = this.activeInteractionData[pointerId];\n\n    if (interactionData) {\n      delete this.activeInteractionData[pointerId];\n      interactionData._reset();\n      this.interactionDataPool.push(interactionData);\n    }\n  }\n\n  /**\n   * Maps x and y coords from a DOM object and maps them correctly to the three.js view. The\n   * resulting value is stored in the point. This takes into account the fact that the DOM\n   * element could be scaled and positioned anywhere on the screen.\n   *\n   * @param  {Vector2} point - the point that the result will be stored in\n   * @param  {number} x - the x coord of the position to map\n   * @param  {number} y - the y coord of the position to map\n   */\n  mapPositionToPoint(point, x, y) {\n    let rect;\n\n    // IE 11 fix\n    if (!this.interactionDOMElement.parentElement) {\n      rect = {\n        x: 0,\n        y: 0,\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0,\n      };\n    } else {\n      rect = this.interactionDOMElement.getBoundingClientRect();\n    }\n\n    point.x = ((x - rect.left) / rect.width) * 2 - 1;\n    point.y = -((y - rect.top) / rect.height) * 2 + 1;\n  }\n\n  /**\n   * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The event to be configured\n   * @param {PointerEvent} pointerEvent - The DOM event that will be paired with the InteractionEvent\n   * @param {InteractionData} interactionData - The InteractionData that will be paired\n   *        with the InteractionEvent\n   * @return {InteractionEvent} the interaction event that was passed in\n   */\n  configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {\n    interactionEvent.data = interactionData;\n\n    this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);\n\n    if (this.layer && this.layer.interactive) this.raycaster.setFromCamera(interactionData.global, this.layer.camera);\n\n    // Not really sure why this is happening, but it's how a previous version handled things TODO: there should be remove\n    if (pointerEvent.pointerType === 'touch') {\n      pointerEvent.globalX = interactionData.global.x;\n      pointerEvent.globalY = interactionData.global.y;\n    }\n\n    interactionData.originalEvent = pointerEvent;\n    interactionEvent._reset();\n    interactionEvent.intersects = this.raycaster.intersectObjects(this.scene.children, true);\n\n    return interactionEvent;\n  }\n\n  /**\n   * Ensures that the original event object contains all data that a regular pointer event would have\n   *\n   * @private\n   * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event\n   * @return {PointerEvent[]} An array containing a single normalized pointer event, in the case of a pointer\n   *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n   */\n  normalizeToPointerData(event) {\n    const normalizedEvents = [];\n\n    if (this.supportsTouchEvents && event instanceof TouchEvent) {\n      for (let i = 0, li = event.changedTouches.length; i < li; i++) {\n        const touch = event.changedTouches[i];\n\n        if (typeof touch.button === 'undefined') touch.button = event.touches.length ? 1 : 0;\n        if (typeof touch.buttons === 'undefined') touch.buttons = event.touches.length ? 1 : 0;\n        if (typeof touch.isPrimary === 'undefined') {\n          touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n        }\n        if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n        if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n        if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n        if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n        if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n        if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n        if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n        touch.twist = 0;\n        touch.tangentialPressure = 0;\n        // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n        // support, and the fill ins are not quite the same\n        // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n        // left is not 0,0 on the page\n        if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n        if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY;\n\n        // mark the touch as normalized, just so that we know we did it\n        touch.isNormalized = true;\n\n        normalizedEvents.push(touch);\n      }\n    } else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent))) {\n      if (typeof event.isPrimary === 'undefined') event.isPrimary = true;\n      if (typeof event.width === 'undefined') event.width = 1;\n      if (typeof event.height === 'undefined') event.height = 1;\n      if (typeof event.tiltX === 'undefined') event.tiltX = 0;\n      if (typeof event.tiltY === 'undefined') event.tiltY = 0;\n      if (typeof event.pointerType === 'undefined') event.pointerType = 'mouse';\n      if (typeof event.pointerId === 'undefined') event.pointerId = MOUSE_POINTER_ID;\n      if (typeof event.pressure === 'undefined') event.pressure = 0.5;\n      event.twist = 0;\n      event.tangentialPressure = 0;\n\n      // mark the mouse event as normalized, just so that we know we did it\n      event.isNormalized = true;\n\n      normalizedEvents.push(event);\n    } else {\n      normalizedEvents.push(event);\n    }\n\n    return normalizedEvents;\n  }\n\n  /**\n   * Destroys the interaction manager\n   *\n   */\n  destroy() {\n    this.removeEvents();\n\n    this.removeAllListeners();\n\n    this.renderer = null;\n\n    this.mouse = null;\n\n    this.eventData = null;\n\n    this.interactionDOMElement = null;\n\n    this.onPointerDown = null;\n    this.processPointerDown = null;\n\n    this.onPointerUp = null;\n    this.processPointerUp = null;\n\n    this.onPointerCancel = null;\n    this.processPointerCancel = null;\n\n    this.onPointerMove = null;\n    this.processPointerMove = null;\n\n    this.onPointerOut = null;\n    this.processPointerOverOut = null;\n\n    this.onPointerOver = null;\n\n    this._tempPoint = null;\n  }\n}\n\nexport default InteractionLayer;\n","(function() {\n  let lastTime = 0;\n  let vendors = ['ms', 'moz', 'webkit', 'o'];\n  for (let x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] ||\n            window[vendors[x] + 'CancelRequestAnimationFrame'];\n  }\n\n  if (!window.requestAnimationFrame) {\n    window.requestAnimationFrame = function(callback) {\n      let currTime = new Date().getTime();\n      let timeToCall = Math.max(0, 16 - (currTime - lastTime));\n      let id = window.setTimeout(function() {\n        callback(currTime + timeToCall);\n      }, timeToCall);\n      lastTime = currTime + timeToCall;\n      return id;\n    };\n  }\n\n  if (!window.cancelAnimationFrame) {\n    window.cancelAnimationFrame = function(id) {\n      clearTimeout(id);\n    };\n  }\n\n  window.RAF = window.requestAnimationFrame;\n  window.CAF = window.cancelAnimationFrame;\n})();\n","import './Raf';\nimport { EventDispatcher } from 'three';\n\n/**\n * @extends EventDispatcher\n */\nclass Ticker extends EventDispatcher {\n  /**\n   *\n   */\n  constructor() {\n    super();\n    this.timer = null;\n    this.started = false;\n\n    /**\n     * pre-time cache\n     *\n     * @member {Number}\n     * @private\n     */\n    this.pt = 0;\n\n    /**\n     * how long the time through, at this tick\n     *\n     * @member {Number}\n     * @private\n     */\n    this.snippet = 0;\n\n    this.start();\n  }\n\n  /**\n   * start tick loop\n   */\n  start() {\n    if (this.started) return;\n    const loop = () => {\n      this.timeline();\n      this.emit('tick', { snippet: this.snippet });\n      this.timer = RAF(loop);\n    };\n    loop();\n  }\n\n  /**\n   * stop tick loop\n   */\n  stop() {\n    CAF(this.timer);\n    this.started = false;\n  }\n\n  /**\n   * get timeline snippet\n   *\n   * @private\n   */\n  timeline() {\n    this.snippet = Date.now() - this.pt;\n    if (this.pt === 0 || this.snippet > 200) {\n      this.pt = Date.now();\n      this.snippet = Date.now() - this.pt;\n    }\n\n    this.pt += this.snippet;\n  }\n}\n\nexport default Ticker;\n","import Ticker from '../utils/Ticker';\nimport InteractionManager from './InteractionManager';\n\n/**\n * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive\n * if its interactive parameter is set to true\n * This manager also supports multitouch.\n *\n * reference to [pixi.js](http://www.pixijs.com/) impl\n *\n * @example\n * import { Scene, PerspectiveCamera, WebGLRenderer, Mesh, BoxGeometry, MeshBasicMaterial } from 'three';\n * import { Interaction } from 'three.interaction';\n * const renderer = new WebGLRenderer({ canvas: canvasElement });\n * const scene = new Scene();\n * const camera = new PerspectiveCamera(60, width / height, 0.1, 100);\n *\n * const interaction = new Interaction(renderer, scene, camera);\n * // then you can bind every interaction event with any mesh which you had `add` into `scene` before\n * const cube = new Mesh(\n *   new BoxGeometry(1, 1, 1),\n *   new MeshBasicMaterial({ color: 0xffffff }),\n * );\n * scene.add(cube);\n * cube.on('touchstart', ev => {\n *   console.log(ev);\n * });\n *\n * cube.on('mousedown', ev => {\n *   console.log(ev);\n * });\n *\n * cube.on('pointerdown', ev => {\n *   console.log(ev);\n * });\n * // and so on ...\n *\n * // you can also listen on parent-node or any display-tree node,\n * // source event will bubble up along with display-tree.\n * // you can stop the bubble-up by invoke ev.stopPropagation function.\n * scene.on('touchstart', ev => {\n *   console.log(ev);\n * })\n *\n * @class\n * @extends InteractionManager\n */\nclass Interaction extends InteractionManager {\n  /**\n   * @param {WebGLRenderer} renderer - A reference to the current renderer\n   * @param {Scene} scene - A reference to the current scene\n   * @param {Camera} camera - A reference to the current camera\n   * @param {Object} [options] - The options for the manager.\n   * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.\n   * @param {Boolean} [options.autoAttach=false] - Should the manager automatically attach target element.\n   * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.\n   */\n  constructor(renderer, scene, camera, options) {\n    options = Object.assign({ autoAttach: false }, options);\n    super(renderer, scene, camera, options);\n\n    /**\n     * a ticker\n     *\n     * @private\n     * @member {Ticker}\n     */\n    this.ticker = new Ticker();\n\n    /**\n     * update for some over event\n     *\n     * @private\n     */\n    this.update = this.update.bind(this);\n\n    this.on('addevents', () => {\n      this.ticker.on('tick', this.update);\n    });\n\n    this.on('removeevents', () => {\n      this.ticker.off('tick', this.update);\n    });\n\n    this.setTargetElement(this.renderer.domElement);\n  }\n}\n\nexport default Interaction;\n"]},"metadata":{},"sourceType":"module"}