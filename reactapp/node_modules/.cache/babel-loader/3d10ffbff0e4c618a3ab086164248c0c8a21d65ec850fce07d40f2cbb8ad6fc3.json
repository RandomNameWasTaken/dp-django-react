{"ast":null,"code":"import _regeneratorRuntime from \"/home/xkruzel/Desktop/todo/reactapp/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/home/xkruzel/Desktop/todo/reactapp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/home/xkruzel/Desktop/todo/reactapp/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/xkruzel/Desktop/todo/reactapp/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { BufferAttribute, ClampToEdgeWrapping, DoubleSide, InterpolateDiscrete, InterpolateLinear, LinearEncoding, LinearFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, MathUtils, Matrix4, MirroredRepeatWrapping, NearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, PropertyBinding, RGBAFormat, RepeatWrapping, Scene, Source, sRGBEncoding, Vector3 } from 'three';\nvar GLTFExporter = /*#__PURE__*/function () {\n  function GLTFExporter() {\n    _classCallCheck(this, GLTFExporter);\n    this.pluginCallbacks = [];\n    this.register(function (writer) {\n      return new GLTFLightExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsUnlitExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsPBRSpecularGlossiness(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsTransmissionExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsVolumeExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsClearcoatExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsIridescenceExtension(writer);\n    });\n  }\n  _createClass(GLTFExporter, [{\n    key: \"register\",\n    value: function register(callback) {\n      if (this.pluginCallbacks.indexOf(callback) === -1) {\n        this.pluginCallbacks.push(callback);\n      }\n      return this;\n    }\n  }, {\n    key: \"unregister\",\n    value: function unregister(callback) {\n      if (this.pluginCallbacks.indexOf(callback) !== -1) {\n        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n      }\n      return this;\n    }\n\n    /**\n     * Parse scenes and generate GLTF output\n     * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n     * @param  {Function} onDone  Callback on completed\n     * @param  {Function} onError  Callback on errors\n     * @param  {Object} options options\n     */\n  }, {\n    key: \"parse\",\n    value: function parse(input, onDone, onError, options) {\n      if (typeof onError === 'object') {\n        console.warn('THREE.GLTFExporter: parse() expects options as the fourth argument now.');\n        options = onError;\n      }\n      var writer = new GLTFWriter();\n      var plugins = [];\n      for (var i = 0, il = this.pluginCallbacks.length; i < il; i++) {\n        plugins.push(this.pluginCallbacks[i](writer));\n      }\n      writer.setPlugins(plugins);\n      writer.write(input, onDone, options).catch(onError);\n    }\n  }, {\n    key: \"parseAsync\",\n    value: function parseAsync(input, options) {\n      var scope = this;\n      return new Promise(function (resolve, reject) {\n        scope.parse(input, resolve, reject, options);\n      });\n    }\n  }]);\n  return GLTFExporter;\n}(); //------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\nvar WEBGL_CONSTANTS = {\n  POINTS: 0x0000,\n  LINES: 0x0001,\n  LINE_LOOP: 0x0002,\n  LINE_STRIP: 0x0003,\n  TRIANGLES: 0x0004,\n  TRIANGLE_STRIP: 0x0005,\n  TRIANGLE_FAN: 0x0006,\n  UNSIGNED_BYTE: 0x1401,\n  UNSIGNED_SHORT: 0x1403,\n  FLOAT: 0x1406,\n  UNSIGNED_INT: 0x1405,\n  ARRAY_BUFFER: 0x8892,\n  ELEMENT_ARRAY_BUFFER: 0x8893,\n  NEAREST: 0x2600,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_NEAREST: 0x2700,\n  LINEAR_MIPMAP_NEAREST: 0x2701,\n  NEAREST_MIPMAP_LINEAR: 0x2702,\n  LINEAR_MIPMAP_LINEAR: 0x2703,\n  CLAMP_TO_EDGE: 33071,\n  MIRRORED_REPEAT: 33648,\n  REPEAT: 10497\n};\nvar THREE_TO_WEBGL = {};\nTHREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\nvar PATH_PROPERTIES = {\n  scale: 'scale',\n  position: 'translation',\n  quaternion: 'rotation',\n  morphTargetInfluences: 'weights'\n};\n\n// GLB constants\n// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\nvar GLB_HEADER_BYTES = 12;\nvar GLB_HEADER_MAGIC = 0x46546C67;\nvar GLB_VERSION = 2;\nvar GLB_CHUNK_PREFIX_BYTES = 8;\nvar GLB_CHUNK_TYPE_JSON = 0x4E4F534A;\nvar GLB_CHUNK_TYPE_BIN = 0x004E4942;\n\n//------------------------------------------------------------------------------\n// Utility functions\n//------------------------------------------------------------------------------\n\n/**\n * Compare two arrays\n * @param  {Array} array1 Array 1 to compare\n * @param  {Array} array2 Array 2 to compare\n * @return {Boolean}        Returns true if both arrays are equal\n */\nfunction equalArray(array1, array2) {\n  return array1.length === array2.length && array1.every(function (element, index) {\n    return element === array2[index];\n  });\n}\n\n/**\n * Converts a string to an ArrayBuffer.\n * @param  {string} text\n * @return {ArrayBuffer}\n */\nfunction stringToArrayBuffer(text) {\n  return new TextEncoder().encode(text).buffer;\n}\n\n/**\n * Is identity matrix\n *\n * @param {Matrix4} matrix\n * @returns {Boolean} Returns true, if parameter is identity matrix\n */\nfunction isIdentityMatrix(matrix) {\n  return equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n}\n\n/**\n * Get the min and max vectors from the given attribute\n * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\n * @param  {Integer} start\n * @param  {Integer} count\n * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\n */\nfunction getMinMax(attribute, start, count) {\n  var output = {\n    min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n    max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\n  };\n  for (var i = start; i < start + count; i++) {\n    for (var a = 0; a < attribute.itemSize; a++) {\n      var value = void 0;\n      if (attribute.itemSize > 4) {\n        // no support for interleaved data for itemSize > 4\n\n        value = attribute.array[i * attribute.itemSize + a];\n      } else {\n        if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n      }\n      output.min[a] = Math.min(output.min[a], value);\n      output.max[a] = Math.max(output.max[a], value);\n    }\n  }\n  return output;\n}\n\n/**\n * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n *\n * @param {Integer} bufferSize The size the original buffer.\n * @returns {Integer} new buffer size with required padding.\n *\n */\nfunction getPaddedBufferSize(bufferSize) {\n  return Math.ceil(bufferSize / 4) * 4;\n}\n\n/**\n * Returns a buffer aligned to 4-byte boundary.\n *\n * @param {ArrayBuffer} arrayBuffer Buffer to pad\n * @param {Integer} paddingByte (Optional)\n * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n */\nfunction getPaddedArrayBuffer(arrayBuffer) {\n  var paddingByte = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);\n  if (paddedLength !== arrayBuffer.byteLength) {\n    var array = new Uint8Array(paddedLength);\n    array.set(new Uint8Array(arrayBuffer));\n    if (paddingByte !== 0) {\n      for (var i = arrayBuffer.byteLength; i < paddedLength; i++) {\n        array[i] = paddingByte;\n      }\n    }\n    return array.buffer;\n  }\n  return arrayBuffer;\n}\nfunction getCanvas() {\n  if (typeof document === 'undefined' && typeof OffscreenCanvas !== 'undefined') {\n    return new OffscreenCanvas(1, 1);\n  }\n  return document.createElement('canvas');\n}\nfunction getToBlobPromise(canvas, mimeType) {\n  if (canvas.toBlob !== undefined) {\n    return new Promise(function (resolve) {\n      return canvas.toBlob(resolve, mimeType);\n    });\n  }\n  var quality;\n\n  // Blink's implementation of convertToBlob seems to default to a quality level of 100%\n  // Use the Blink default quality levels of toBlob instead so that file sizes are comparable.\n  if (mimeType === 'image/jpeg') {\n    quality = 0.92;\n  } else if (mimeType === 'image/webp') {\n    quality = 0.8;\n  }\n  return canvas.convertToBlob({\n    type: mimeType,\n    quality: quality\n  });\n}\n\n/**\n * Writer\n */\nvar GLTFWriter = /*#__PURE__*/function () {\n  function GLTFWriter() {\n    _classCallCheck(this, GLTFWriter);\n    this.plugins = [];\n    this.options = {};\n    this.pending = [];\n    this.buffers = [];\n    this.byteOffset = 0;\n    this.buffers = [];\n    this.nodeMap = new Map();\n    this.skins = [];\n    this.extensionsUsed = {};\n    this.uids = new Map();\n    this.uid = 0;\n    this.json = {\n      asset: {\n        version: '2.0',\n        generator: 'THREE.GLTFExporter'\n      }\n    };\n    this.cache = {\n      meshes: new Map(),\n      attributes: new Map(),\n      attributesNormalized: new Map(),\n      materials: new Map(),\n      textures: new Map(),\n      images: new Map()\n    };\n  }\n  _createClass(GLTFWriter, [{\n    key: \"setPlugins\",\n    value: function setPlugins(plugins) {\n      this.plugins = plugins;\n    }\n\n    /**\n     * Parse scenes and generate GLTF output\n     * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n     * @param  {Function} onDone  Callback on completed\n     * @param  {Object} options options\n     */\n  }, {\n    key: \"write\",\n    value: function () {\n      var _write = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(input, onDone, options) {\n        var writer, buffers, json, extensionsUsed, blob, extensionsUsedList, reader, _reader;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.options = Object.assign({}, {\n                  // default options\n                  binary: false,\n                  trs: false,\n                  onlyVisible: true,\n                  truncateDrawRange: true,\n                  maxTextureSize: Infinity,\n                  animations: [],\n                  includeCustomExtensions: false\n                }, options);\n                if (this.options.animations.length > 0) {\n                  // Only TRS properties, and not matrices, may be targeted by animation.\n                  this.options.trs = true;\n                }\n                this.processInput(input);\n                _context.next = 5;\n                return Promise.all(this.pending);\n              case 5:\n                writer = this;\n                buffers = writer.buffers;\n                json = writer.json;\n                options = writer.options;\n                extensionsUsed = writer.extensionsUsed; // Merge buffers.\n                blob = new Blob(buffers, {\n                  type: 'application/octet-stream'\n                }); // Declare extensions.\n                extensionsUsedList = Object.keys(extensionsUsed);\n                if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList;\n\n                // Update bytelength of the single buffer.\n                if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size;\n                if (options.binary === true) {\n                  // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n                  reader = new FileReader();\n                  reader.readAsArrayBuffer(blob);\n                  reader.onloadend = function () {\n                    // Binary chunk.\n                    var binaryChunk = getPaddedArrayBuffer(reader.result);\n                    var binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n                    binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\n                    binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true);\n\n                    // JSON chunk.\n                    var jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 0x20);\n                    var jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n                    jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\n                    jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true);\n\n                    // GLB header.\n                    var header = new ArrayBuffer(GLB_HEADER_BYTES);\n                    var headerView = new DataView(header);\n                    headerView.setUint32(0, GLB_HEADER_MAGIC, true);\n                    headerView.setUint32(4, GLB_VERSION, true);\n                    var totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n                    headerView.setUint32(8, totalByteLength, true);\n                    var glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\n                      type: 'application/octet-stream'\n                    });\n                    var glbReader = new FileReader();\n                    glbReader.readAsArrayBuffer(glbBlob);\n                    glbReader.onloadend = function () {\n                      onDone(glbReader.result);\n                    };\n                  };\n                } else {\n                  if (json.buffers && json.buffers.length > 0) {\n                    _reader = new FileReader();\n                    _reader.readAsDataURL(blob);\n                    _reader.onloadend = function () {\n                      var base64data = _reader.result;\n                      json.buffers[0].uri = base64data;\n                      onDone(json);\n                    };\n                  } else {\n                    onDone(json);\n                  }\n                }\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function write(_x, _x2, _x3) {\n        return _write.apply(this, arguments);\n      }\n      return write;\n    }()\n    /**\n     * Serializes a userData.\n     *\n     * @param {THREE.Object3D|THREE.Material} object\n     * @param {Object} objectDef\n     */\n  }, {\n    key: \"serializeUserData\",\n    value: function serializeUserData(object, objectDef) {\n      if (Object.keys(object.userData).length === 0) return;\n      var options = this.options;\n      var extensionsUsed = this.extensionsUsed;\n      try {\n        var json = JSON.parse(JSON.stringify(object.userData));\n        if (options.includeCustomExtensions && json.gltfExtensions) {\n          if (objectDef.extensions === undefined) objectDef.extensions = {};\n          for (var extensionName in json.gltfExtensions) {\n            objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];\n            extensionsUsed[extensionName] = true;\n          }\n          delete json.gltfExtensions;\n        }\n        if (Object.keys(json).length > 0) objectDef.extras = json;\n      } catch (error) {\n        console.warn('THREE.GLTFExporter: userData of \\'' + object.name + '\\' ' + 'won\\'t be serialized because of JSON.stringify error - ' + error.message);\n      }\n    }\n\n    /**\n     * Returns ids for buffer attributes.\n     * @param  {Object} object\n     * @return {Integer}\n     */\n  }, {\n    key: \"getUID\",\n    value: function getUID(attribute) {\n      var isRelativeCopy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (this.uids.has(attribute) === false) {\n        var _uids = new Map();\n        _uids.set(true, this.uid++);\n        _uids.set(false, this.uid++);\n        this.uids.set(attribute, _uids);\n      }\n      var uids = this.uids.get(attribute);\n      return uids.get(isRelativeCopy);\n    }\n\n    /**\n     * Checks if normal attribute values are normalized.\n     *\n     * @param {BufferAttribute} normal\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isNormalizedNormalAttribute\",\n    value: function isNormalizedNormalAttribute(normal) {\n      var cache = this.cache;\n      if (cache.attributesNormalized.has(normal)) return false;\n      var v = new Vector3();\n      for (var i = 0, il = normal.count; i < il; i++) {\n        // 0.0005 is from glTF-validator\n        if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1.0) > 0.0005) return false;\n      }\n      return true;\n    }\n\n    /**\n     * Creates normalized normal buffer attribute.\n     *\n     * @param {BufferAttribute} normal\n     * @returns {BufferAttribute}\n     *\n     */\n  }, {\n    key: \"createNormalizedNormalAttribute\",\n    value: function createNormalizedNormalAttribute(normal) {\n      var cache = this.cache;\n      if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal);\n      var attribute = normal.clone();\n      var v = new Vector3();\n      for (var i = 0, il = attribute.count; i < il; i++) {\n        v.fromBufferAttribute(attribute, i);\n        if (v.x === 0 && v.y === 0 && v.z === 0) {\n          // if values can't be normalized set (1, 0, 0)\n          v.setX(1.0);\n        } else {\n          v.normalize();\n        }\n        attribute.setXYZ(i, v.x, v.y, v.z);\n      }\n      cache.attributesNormalized.set(normal, attribute);\n      return attribute;\n    }\n\n    /**\n     * Applies a texture transform, if present, to the map definition. Requires\n     * the KHR_texture_transform extension.\n     *\n     * @param {Object} mapDef\n     * @param {THREE.Texture} texture\n     */\n  }, {\n    key: \"applyTextureTransform\",\n    value: function applyTextureTransform(mapDef, texture) {\n      var didTransform = false;\n      var transformDef = {};\n      if (texture.offset.x !== 0 || texture.offset.y !== 0) {\n        transformDef.offset = texture.offset.toArray();\n        didTransform = true;\n      }\n      if (texture.rotation !== 0) {\n        transformDef.rotation = texture.rotation;\n        didTransform = true;\n      }\n      if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\n        transformDef.scale = texture.repeat.toArray();\n        didTransform = true;\n      }\n      if (didTransform) {\n        mapDef.extensions = mapDef.extensions || {};\n        mapDef.extensions['KHR_texture_transform'] = transformDef;\n        this.extensionsUsed['KHR_texture_transform'] = true;\n      }\n    }\n  }, {\n    key: \"buildMetalRoughTexture\",\n    value: function buildMetalRoughTexture(metalnessMap, roughnessMap) {\n      if (metalnessMap === roughnessMap) return metalnessMap;\n      function getEncodingConversion(map) {\n        if (map.encoding === sRGBEncoding) {\n          return function SRGBToLinear(c) {\n            return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n          };\n        }\n        return function LinearToLinear(c) {\n          return c;\n        };\n      }\n      console.warn('THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.');\n      var metalness = metalnessMap === null || metalnessMap === void 0 ? void 0 : metalnessMap.image;\n      var roughness = roughnessMap === null || roughnessMap === void 0 ? void 0 : roughnessMap.image;\n      var width = Math.max((metalness === null || metalness === void 0 ? void 0 : metalness.width) || 0, (roughness === null || roughness === void 0 ? void 0 : roughness.width) || 0);\n      var height = Math.max((metalness === null || metalness === void 0 ? void 0 : metalness.height) || 0, (roughness === null || roughness === void 0 ? void 0 : roughness.height) || 0);\n      var canvas = getCanvas();\n      canvas.width = width;\n      canvas.height = height;\n      var context = canvas.getContext('2d');\n      context.fillStyle = '#00ffff';\n      context.fillRect(0, 0, width, height);\n      var composite = context.getImageData(0, 0, width, height);\n      if (metalness) {\n        context.drawImage(metalness, 0, 0, width, height);\n        var convert = getEncodingConversion(metalnessMap);\n        var data = context.getImageData(0, 0, width, height).data;\n        for (var i = 2; i < data.length; i += 4) {\n          composite.data[i] = convert(data[i] / 256) * 256;\n        }\n      }\n      if (roughness) {\n        context.drawImage(roughness, 0, 0, width, height);\n        var _convert = getEncodingConversion(roughnessMap);\n        var _data = context.getImageData(0, 0, width, height).data;\n        for (var _i = 1; _i < _data.length; _i += 4) {\n          composite.data[_i] = _convert(_data[_i] / 256) * 256;\n        }\n      }\n      context.putImageData(composite, 0, 0);\n\n      //\n\n      var reference = metalnessMap || roughnessMap;\n      var texture = reference.clone();\n      texture.source = new Source(canvas);\n      texture.encoding = LinearEncoding;\n      return texture;\n    }\n\n    /**\n     * Process a buffer to append to the default one.\n     * @param  {ArrayBuffer} buffer\n     * @return {Integer}\n     */\n  }, {\n    key: \"processBuffer\",\n    value: function processBuffer(buffer) {\n      var json = this.json;\n      var buffers = this.buffers;\n      if (!json.buffers) json.buffers = [{\n        byteLength: 0\n      }];\n\n      // All buffers are merged before export.\n      buffers.push(buffer);\n      return 0;\n    }\n\n    /**\n     * Process and generate a BufferView\n     * @param  {BufferAttribute} attribute\n     * @param  {number} componentType\n     * @param  {number} start\n     * @param  {number} count\n     * @param  {number} target (Optional) Target usage of the BufferView\n     * @return {Object}\n     */\n  }, {\n    key: \"processBufferView\",\n    value: function processBufferView(attribute, componentType, start, count, target) {\n      var json = this.json;\n      if (!json.bufferViews) json.bufferViews = [];\n\n      // Create a new dataview and dump the attribute's array into it\n\n      var componentSize;\n      if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n        componentSize = 1;\n      } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n        componentSize = 2;\n      } else {\n        componentSize = 4;\n      }\n      var byteLength = getPaddedBufferSize(count * attribute.itemSize * componentSize);\n      var dataView = new DataView(new ArrayBuffer(byteLength));\n      var offset = 0;\n      for (var i = start; i < start + count; i++) {\n        for (var a = 0; a < attribute.itemSize; a++) {\n          var value = void 0;\n          if (attribute.itemSize > 4) {\n            // no support for interleaved data for itemSize > 4\n\n            value = attribute.array[i * attribute.itemSize + a];\n          } else {\n            if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n          }\n          if (componentType === WEBGL_CONSTANTS.FLOAT) {\n            dataView.setFloat32(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n            dataView.setUint32(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n            dataView.setUint16(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n            dataView.setUint8(offset, value);\n          }\n          offset += componentSize;\n        }\n      }\n      var bufferViewDef = {\n        buffer: this.processBuffer(dataView.buffer),\n        byteOffset: this.byteOffset,\n        byteLength: byteLength\n      };\n      if (target !== undefined) bufferViewDef.target = target;\n      if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n        // Only define byteStride for vertex attributes.\n        bufferViewDef.byteStride = attribute.itemSize * componentSize;\n      }\n      this.byteOffset += byteLength;\n      json.bufferViews.push(bufferViewDef);\n\n      // @TODO Merge bufferViews where possible.\n      var output = {\n        id: json.bufferViews.length - 1,\n        byteLength: 0\n      };\n      return output;\n    }\n\n    /**\n     * Process and generate a BufferView from an image Blob.\n     * @param {Blob} blob\n     * @return {Promise<Integer>}\n     */\n  }, {\n    key: \"processBufferViewImage\",\n    value: function processBufferViewImage(blob) {\n      var writer = this;\n      var json = writer.json;\n      if (!json.bufferViews) json.bufferViews = [];\n      return new Promise(function (resolve) {\n        var reader = new FileReader();\n        reader.readAsArrayBuffer(blob);\n        reader.onloadend = function () {\n          var buffer = getPaddedArrayBuffer(reader.result);\n          var bufferViewDef = {\n            buffer: writer.processBuffer(buffer),\n            byteOffset: writer.byteOffset,\n            byteLength: buffer.byteLength\n          };\n          writer.byteOffset += buffer.byteLength;\n          resolve(json.bufferViews.push(bufferViewDef) - 1);\n        };\n      });\n    }\n\n    /**\n     * Process attribute to generate an accessor\n     * @param  {BufferAttribute} attribute Attribute to process\n     * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n     * @param  {Integer} start (Optional)\n     * @param  {Integer} count (Optional)\n     * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n     */\n  }, {\n    key: \"processAccessor\",\n    value: function processAccessor(attribute, geometry, start, count) {\n      var options = this.options;\n      var json = this.json;\n      var types = {\n        1: 'SCALAR',\n        2: 'VEC2',\n        3: 'VEC3',\n        4: 'VEC4',\n        16: 'MAT4'\n      };\n      var componentType;\n\n      // Detect the component type of the attribute array (float, uint or ushort)\n      if (attribute.array.constructor === Float32Array) {\n        componentType = WEBGL_CONSTANTS.FLOAT;\n      } else if (attribute.array.constructor === Uint32Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n      } else if (attribute.array.constructor === Uint16Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n      } else if (attribute.array.constructor === Uint8Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n      } else {\n        throw new Error('THREE.GLTFExporter: Unsupported bufferAttribute component type.');\n      }\n      if (start === undefined) start = 0;\n      if (count === undefined) count = attribute.count;\n\n      // @TODO Indexed buffer geometry with drawRange not supported yet\n      if (options.truncateDrawRange && geometry !== undefined && geometry.index === null) {\n        var end = start + count;\n        var end2 = geometry.drawRange.count === Infinity ? attribute.count : geometry.drawRange.start + geometry.drawRange.count;\n        start = Math.max(start, geometry.drawRange.start);\n        count = Math.min(end, end2) - start;\n        if (count < 0) count = 0;\n      }\n\n      // Skip creating an accessor if the attribute doesn't have data to export\n      if (count === 0) return null;\n      var minMax = getMinMax(attribute, start, count);\n      var bufferViewTarget;\n\n      // If geometry isn't provided, don't infer the target usage of the bufferView. For\n      // animation samplers, target must not be set.\n      if (geometry !== undefined) {\n        bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n      }\n      var bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);\n      var accessorDef = {\n        bufferView: bufferView.id,\n        byteOffset: bufferView.byteOffset,\n        componentType: componentType,\n        count: count,\n        max: minMax.max,\n        min: minMax.min,\n        type: types[attribute.itemSize]\n      };\n      if (attribute.normalized === true) accessorDef.normalized = true;\n      if (!json.accessors) json.accessors = [];\n      return json.accessors.push(accessorDef) - 1;\n    }\n\n    /**\n     * Process image\n     * @param  {Image} image to process\n     * @param  {Integer} format of the image (RGBAFormat)\n     * @param  {Boolean} flipY before writing out the image\n     * @param  {String} mimeType export format\n     * @return {Integer}     Index of the processed texture in the \"images\" array\n     */\n  }, {\n    key: \"processImage\",\n    value: function processImage(image, format, flipY) {\n      var mimeType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'image/png';\n      var writer = this;\n      var cache = writer.cache;\n      var json = writer.json;\n      var options = writer.options;\n      var pending = writer.pending;\n      if (!cache.images.has(image)) cache.images.set(image, {});\n      var cachedImages = cache.images.get(image);\n      var key = mimeType + ':flipY/' + flipY.toString();\n      if (cachedImages[key] !== undefined) return cachedImages[key];\n      if (!json.images) json.images = [];\n      var imageDef = {\n        mimeType: mimeType\n      };\n      var canvas = getCanvas();\n      canvas.width = Math.min(image.width, options.maxTextureSize);\n      canvas.height = Math.min(image.height, options.maxTextureSize);\n      var ctx = canvas.getContext('2d');\n      if (flipY === true) {\n        ctx.translate(0, canvas.height);\n        ctx.scale(1, -1);\n      }\n      if (image.data !== undefined) {\n        // THREE.DataTexture\n\n        if (format !== RGBAFormat) {\n          console.error('GLTFExporter: Only RGBAFormat is supported.');\n        }\n        if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\n          console.warn('GLTFExporter: Image size is bigger than maxTextureSize', image);\n        }\n        var data = new Uint8ClampedArray(image.height * image.width * 4);\n        for (var i = 0; i < data.length; i += 4) {\n          data[i + 0] = image.data[i + 0];\n          data[i + 1] = image.data[i + 1];\n          data[i + 2] = image.data[i + 2];\n          data[i + 3] = image.data[i + 3];\n        }\n        ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);\n      } else {\n        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n      }\n      if (options.binary === true) {\n        pending.push(getToBlobPromise(canvas, mimeType).then(function (blob) {\n          return writer.processBufferViewImage(blob);\n        }).then(function (bufferViewIndex) {\n          imageDef.bufferView = bufferViewIndex;\n        }));\n      } else {\n        if (canvas.toDataURL !== undefined) {\n          imageDef.uri = canvas.toDataURL(mimeType);\n        } else {\n          pending.push(getToBlobPromise(canvas, mimeType).then(function (blob) {\n            return new FileReader().readAsDataURL(blob);\n          }).then(function (dataURL) {\n            imageDef.uri = dataURL;\n          }));\n        }\n      }\n      var index = json.images.push(imageDef) - 1;\n      cachedImages[key] = index;\n      return index;\n    }\n\n    /**\n     * Process sampler\n     * @param  {Texture} map Texture to process\n     * @return {Integer}     Index of the processed texture in the \"samplers\" array\n     */\n  }, {\n    key: \"processSampler\",\n    value: function processSampler(map) {\n      var json = this.json;\n      if (!json.samplers) json.samplers = [];\n      var samplerDef = {\n        magFilter: THREE_TO_WEBGL[map.magFilter],\n        minFilter: THREE_TO_WEBGL[map.minFilter],\n        wrapS: THREE_TO_WEBGL[map.wrapS],\n        wrapT: THREE_TO_WEBGL[map.wrapT]\n      };\n      return json.samplers.push(samplerDef) - 1;\n    }\n\n    /**\n     * Process texture\n     * @param  {Texture} map Map to process\n     * @return {Integer} Index of the processed texture in the \"textures\" array\n     */\n  }, {\n    key: \"processTexture\",\n    value: function processTexture(map) {\n      var cache = this.cache;\n      var json = this.json;\n      if (cache.textures.has(map)) return cache.textures.get(map);\n      if (!json.textures) json.textures = [];\n      var mimeType = map.userData.mimeType;\n      if (mimeType === 'image/webp') mimeType = 'image/png';\n      var textureDef = {\n        sampler: this.processSampler(map),\n        source: this.processImage(map.image, map.format, map.flipY, mimeType)\n      };\n      if (map.name) textureDef.name = map.name;\n      this._invokeAll(function (ext) {\n        ext.writeTexture && ext.writeTexture(map, textureDef);\n      });\n      var index = json.textures.push(textureDef) - 1;\n      cache.textures.set(map, index);\n      return index;\n    }\n\n    /**\n     * Process material\n     * @param  {THREE.Material} material Material to process\n     * @return {Integer|null} Index of the processed material in the \"materials\" array\n     */\n  }, {\n    key: \"processMaterial\",\n    value: function processMaterial(material) {\n      var cache = this.cache;\n      var json = this.json;\n      if (cache.materials.has(material)) return cache.materials.get(material);\n      if (material.isShaderMaterial) {\n        console.warn('GLTFExporter: THREE.ShaderMaterial not supported.');\n        return null;\n      }\n      if (!json.materials) json.materials = [];\n\n      // @QUESTION Should we avoid including any attribute that has the default value?\n      var materialDef = {\n        pbrMetallicRoughness: {}\n      };\n      if (material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true) {\n        console.warn('GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.');\n      }\n\n      // pbrMetallicRoughness.baseColorFactor\n      var color = material.color.toArray().concat([material.opacity]);\n      if (!equalArray(color, [1, 1, 1, 1])) {\n        materialDef.pbrMetallicRoughness.baseColorFactor = color;\n      }\n      if (material.isMeshStandardMaterial) {\n        materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n        materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n      } else {\n        materialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n        materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n      }\n\n      // pbrMetallicRoughness.metallicRoughnessTexture\n      if (material.metalnessMap || material.roughnessMap) {\n        var metalRoughTexture = this.buildMetalRoughTexture(material.metalnessMap, material.roughnessMap);\n        var metalRoughMapDef = {\n          index: this.processTexture(metalRoughTexture)\n        };\n        this.applyTextureTransform(metalRoughMapDef, metalRoughTexture);\n        materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n      }\n\n      // pbrMetallicRoughness.baseColorTexture or pbrSpecularGlossiness diffuseTexture\n      if (material.map) {\n        var baseColorMapDef = {\n          index: this.processTexture(material.map)\n        };\n        this.applyTextureTransform(baseColorMapDef, material.map);\n        materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n      }\n      if (material.emissive) {\n        // note: emissive components are limited to stay within the 0 - 1 range to accommodate glTF spec. see #21849 and #22000.\n        var emissive = material.emissive.clone().multiplyScalar(material.emissiveIntensity);\n        var maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);\n        if (maxEmissiveComponent > 1) {\n          emissive.multiplyScalar(1 / maxEmissiveComponent);\n          console.warn('THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited');\n        }\n        if (maxEmissiveComponent > 0) {\n          materialDef.emissiveFactor = emissive.toArray();\n        }\n\n        // emissiveTexture\n        if (material.emissiveMap) {\n          var emissiveMapDef = {\n            index: this.processTexture(material.emissiveMap)\n          };\n          this.applyTextureTransform(emissiveMapDef, material.emissiveMap);\n          materialDef.emissiveTexture = emissiveMapDef;\n        }\n      }\n\n      // normalTexture\n      if (material.normalMap) {\n        var normalMapDef = {\n          index: this.processTexture(material.normalMap)\n        };\n        if (material.normalScale && material.normalScale.x !== 1) {\n          // glTF normal scale is univariate. Ignore `y`, which may be flipped.\n          // Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n          normalMapDef.scale = material.normalScale.x;\n        }\n        this.applyTextureTransform(normalMapDef, material.normalMap);\n        materialDef.normalTexture = normalMapDef;\n      }\n\n      // occlusionTexture\n      if (material.aoMap) {\n        var occlusionMapDef = {\n          index: this.processTexture(material.aoMap),\n          texCoord: 1\n        };\n        if (material.aoMapIntensity !== 1.0) {\n          occlusionMapDef.strength = material.aoMapIntensity;\n        }\n        this.applyTextureTransform(occlusionMapDef, material.aoMap);\n        materialDef.occlusionTexture = occlusionMapDef;\n      }\n\n      // alphaMode\n      if (material.transparent) {\n        materialDef.alphaMode = 'BLEND';\n      } else {\n        if (material.alphaTest > 0.0) {\n          materialDef.alphaMode = 'MASK';\n          materialDef.alphaCutoff = material.alphaTest;\n        }\n      }\n\n      // doubleSided\n      if (material.side === DoubleSide) materialDef.doubleSided = true;\n      if (material.name !== '') materialDef.name = material.name;\n      this.serializeUserData(material, materialDef);\n      this._invokeAll(function (ext) {\n        ext.writeMaterial && ext.writeMaterial(material, materialDef);\n      });\n      var index = json.materials.push(materialDef) - 1;\n      cache.materials.set(material, index);\n      return index;\n    }\n\n    /**\n     * Process mesh\n     * @param  {THREE.Mesh} mesh Mesh to process\n     * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n     */\n  }, {\n    key: \"processMesh\",\n    value: function processMesh(mesh) {\n      var cache = this.cache;\n      var json = this.json;\n      var meshCacheKeyParts = [mesh.geometry.uuid];\n      if (Array.isArray(mesh.material)) {\n        for (var i = 0, l = mesh.material.length; i < l; i++) {\n          meshCacheKeyParts.push(mesh.material[i].uuid);\n        }\n      } else {\n        meshCacheKeyParts.push(mesh.material.uuid);\n      }\n      var meshCacheKey = meshCacheKeyParts.join(':');\n      if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey);\n      var geometry = mesh.geometry;\n      var mode;\n\n      // Use the correct mode\n      if (mesh.isLineSegments) {\n        mode = WEBGL_CONSTANTS.LINES;\n      } else if (mesh.isLineLoop) {\n        mode = WEBGL_CONSTANTS.LINE_LOOP;\n      } else if (mesh.isLine) {\n        mode = WEBGL_CONSTANTS.LINE_STRIP;\n      } else if (mesh.isPoints) {\n        mode = WEBGL_CONSTANTS.POINTS;\n      } else {\n        mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n      }\n      if (geometry.isBufferGeometry !== true) {\n        throw new Error('THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.');\n      }\n      var meshDef = {};\n      var attributes = {};\n      var primitives = [];\n      var targets = [];\n\n      // Conversion between attributes names in threejs and gltf spec\n      var nameConversion = {\n        uv: 'TEXCOORD_0',\n        uv2: 'TEXCOORD_1',\n        color: 'COLOR_0',\n        skinWeight: 'WEIGHTS_0',\n        skinIndex: 'JOINTS_0'\n      };\n      var originalNormal = geometry.getAttribute('normal');\n      if (originalNormal !== undefined && !this.isNormalizedNormalAttribute(originalNormal)) {\n        console.warn('THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.');\n        geometry.setAttribute('normal', this.createNormalizedNormalAttribute(originalNormal));\n      }\n\n      // @QUESTION Detect if .vertexColors = true?\n      // For every attribute create an accessor\n      var modifiedAttribute = null;\n      for (var attributeName in geometry.attributes) {\n        // Ignore morph target attributes, which are exported later.\n        if (attributeName.slice(0, 5) === 'morph') continue;\n        var attribute = geometry.attributes[attributeName];\n        attributeName = nameConversion[attributeName] || attributeName.toUpperCase();\n\n        // Prefix all geometry attributes except the ones specifically\n        // listed in the spec; non-spec attributes are considered custom.\n        var validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n        if (!validVertexAttributes.test(attributeName)) attributeName = '_' + attributeName;\n        if (cache.attributes.has(this.getUID(attribute))) {\n          attributes[attributeName] = cache.attributes.get(this.getUID(attribute));\n          continue;\n        }\n\n        // JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n        modifiedAttribute = null;\n        var array = attribute.array;\n        if (attributeName === 'JOINTS_0' && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n          console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\n          modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\n        }\n        var accessor = this.processAccessor(modifiedAttribute || attribute, geometry);\n        if (accessor !== null) {\n          attributes[attributeName] = accessor;\n          cache.attributes.set(this.getUID(attribute), accessor);\n        }\n      }\n      if (originalNormal !== undefined) geometry.setAttribute('normal', originalNormal);\n\n      // Skip if no exportable attributes found\n      if (Object.keys(attributes).length === 0) return null;\n\n      // Morph targets\n      if (mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0) {\n        var weights = [];\n        var targetNames = [];\n        var reverseDictionary = {};\n        if (mesh.morphTargetDictionary !== undefined) {\n          for (var key in mesh.morphTargetDictionary) {\n            reverseDictionary[mesh.morphTargetDictionary[key]] = key;\n          }\n        }\n        for (var _i2 = 0; _i2 < mesh.morphTargetInfluences.length; ++_i2) {\n          var target = {};\n          var warned = false;\n          for (var _attributeName in geometry.morphAttributes) {\n            // glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n            // Three.js doesn't support TANGENT yet.\n\n            if (_attributeName !== 'position' && _attributeName !== 'normal') {\n              if (!warned) {\n                console.warn('GLTFExporter: Only POSITION and NORMAL morph are supported.');\n                warned = true;\n              }\n              continue;\n            }\n            var _attribute = geometry.morphAttributes[_attributeName][_i2];\n            var gltfAttributeName = _attributeName.toUpperCase();\n\n            // Three.js morph attribute has absolute values while the one of glTF has relative values.\n            //\n            // glTF 2.0 Specification:\n            // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n            var baseAttribute = geometry.attributes[_attributeName];\n            if (cache.attributes.has(this.getUID(_attribute, true))) {\n              target[gltfAttributeName] = cache.attributes.get(this.getUID(_attribute, true));\n              continue;\n            }\n\n            // Clones attribute not to override\n            var relativeAttribute = _attribute.clone();\n            if (!geometry.morphTargetsRelative) {\n              for (var j = 0, jl = _attribute.count; j < jl; j++) {\n                relativeAttribute.setXYZ(j, _attribute.getX(j) - baseAttribute.getX(j), _attribute.getY(j) - baseAttribute.getY(j), _attribute.getZ(j) - baseAttribute.getZ(j));\n              }\n            }\n            target[gltfAttributeName] = this.processAccessor(relativeAttribute, geometry);\n            cache.attributes.set(this.getUID(baseAttribute, true), target[gltfAttributeName]);\n          }\n          targets.push(target);\n          weights.push(mesh.morphTargetInfluences[_i2]);\n          if (mesh.morphTargetDictionary !== undefined) targetNames.push(reverseDictionary[_i2]);\n        }\n        meshDef.weights = weights;\n        if (targetNames.length > 0) {\n          meshDef.extras = {};\n          meshDef.extras.targetNames = targetNames;\n        }\n      }\n      var isMultiMaterial = Array.isArray(mesh.material);\n      if (isMultiMaterial && geometry.groups.length === 0) return null;\n      var materials = isMultiMaterial ? mesh.material : [mesh.material];\n      var groups = isMultiMaterial ? geometry.groups : [{\n        materialIndex: 0,\n        start: undefined,\n        count: undefined\n      }];\n      for (var _i3 = 0, il = groups.length; _i3 < il; _i3++) {\n        var primitive = {\n          mode: mode,\n          attributes: attributes\n        };\n        this.serializeUserData(geometry, primitive);\n        if (targets.length > 0) primitive.targets = targets;\n        if (geometry.index !== null) {\n          var cacheKey = this.getUID(geometry.index);\n          if (groups[_i3].start !== undefined || groups[_i3].count !== undefined) {\n            cacheKey += ':' + groups[_i3].start + ':' + groups[_i3].count;\n          }\n          if (cache.attributes.has(cacheKey)) {\n            primitive.indices = cache.attributes.get(cacheKey);\n          } else {\n            primitive.indices = this.processAccessor(geometry.index, geometry, groups[_i3].start, groups[_i3].count);\n            cache.attributes.set(cacheKey, primitive.indices);\n          }\n          if (primitive.indices === null) delete primitive.indices;\n        }\n        var material = this.processMaterial(materials[groups[_i3].materialIndex]);\n        if (material !== null) primitive.material = material;\n        primitives.push(primitive);\n      }\n      meshDef.primitives = primitives;\n      if (!json.meshes) json.meshes = [];\n      this._invokeAll(function (ext) {\n        ext.writeMesh && ext.writeMesh(mesh, meshDef);\n      });\n      var index = json.meshes.push(meshDef) - 1;\n      cache.meshes.set(meshCacheKey, index);\n      return index;\n    }\n\n    /**\n     * Process camera\n     * @param  {THREE.Camera} camera Camera to process\n     * @return {Integer}      Index of the processed mesh in the \"camera\" array\n     */\n  }, {\n    key: \"processCamera\",\n    value: function processCamera(camera) {\n      var json = this.json;\n      if (!json.cameras) json.cameras = [];\n      var isOrtho = camera.isOrthographicCamera;\n      var cameraDef = {\n        type: isOrtho ? 'orthographic' : 'perspective'\n      };\n      if (isOrtho) {\n        cameraDef.orthographic = {\n          xmag: camera.right * 2,\n          ymag: camera.top * 2,\n          zfar: camera.far <= 0 ? 0.001 : camera.far,\n          znear: camera.near < 0 ? 0 : camera.near\n        };\n      } else {\n        cameraDef.perspective = {\n          aspectRatio: camera.aspect,\n          yfov: MathUtils.degToRad(camera.fov),\n          zfar: camera.far <= 0 ? 0.001 : camera.far,\n          znear: camera.near < 0 ? 0 : camera.near\n        };\n      }\n\n      // Question: Is saving \"type\" as name intentional?\n      if (camera.name !== '') cameraDef.name = camera.type;\n      return json.cameras.push(cameraDef) - 1;\n    }\n\n    /**\n     * Creates glTF animation entry from AnimationClip object.\n     *\n     * Status:\n     * - Only properties listed in PATH_PROPERTIES may be animated.\n     *\n     * @param {THREE.AnimationClip} clip\n     * @param {THREE.Object3D} root\n     * @return {number|null}\n     */\n  }, {\n    key: \"processAnimation\",\n    value: function processAnimation(clip, root) {\n      var json = this.json;\n      var nodeMap = this.nodeMap;\n      if (!json.animations) json.animations = [];\n      clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\n      var tracks = clip.tracks;\n      var channels = [];\n      var samplers = [];\n      for (var i = 0; i < tracks.length; ++i) {\n        var track = tracks[i];\n        var trackBinding = PropertyBinding.parseTrackName(track.name);\n        var trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);\n        var trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\n        if (trackBinding.objectName === 'bones') {\n          if (trackNode.isSkinnedMesh === true) {\n            trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\n          } else {\n            trackNode = undefined;\n          }\n        }\n        if (!trackNode || !trackProperty) {\n          console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\n          return null;\n        }\n        var inputItemSize = 1;\n        var outputItemSize = track.values.length / track.times.length;\n        if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n          outputItemSize /= trackNode.morphTargetInfluences.length;\n        }\n        var interpolation = void 0;\n\n        // @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n\n        // Detecting glTF cubic spline interpolant by checking factory method's special property\n        // GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n        // valid value from .getInterpolation().\n        if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {\n          interpolation = 'CUBICSPLINE';\n\n          // itemSize of CUBICSPLINE keyframe is 9\n          // (VEC3 * 3: inTangent, splineVertex, and outTangent)\n          // but needs to be stored as VEC3 so dividing by 3 here.\n          outputItemSize /= 3;\n        } else if (track.getInterpolation() === InterpolateDiscrete) {\n          interpolation = 'STEP';\n        } else {\n          interpolation = 'LINEAR';\n        }\n        samplers.push({\n          input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),\n          output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),\n          interpolation: interpolation\n        });\n        channels.push({\n          sampler: samplers.length - 1,\n          target: {\n            node: nodeMap.get(trackNode),\n            path: trackProperty\n          }\n        });\n      }\n      json.animations.push({\n        name: clip.name || 'clip_' + json.animations.length,\n        samplers: samplers,\n        channels: channels\n      });\n      return json.animations.length - 1;\n    }\n\n    /**\n     * @param {THREE.Object3D} object\n     * @return {number|null}\n     */\n  }, {\n    key: \"processSkin\",\n    value: function processSkin(object) {\n      var json = this.json;\n      var nodeMap = this.nodeMap;\n      var node = json.nodes[nodeMap.get(object)];\n      var skeleton = object.skeleton;\n      if (skeleton === undefined) return null;\n      var rootJoint = object.skeleton.bones[0];\n      if (rootJoint === undefined) return null;\n      var joints = [];\n      var inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\n      var temporaryBoneInverse = new Matrix4();\n      for (var i = 0; i < skeleton.bones.length; ++i) {\n        joints.push(nodeMap.get(skeleton.bones[i]));\n        temporaryBoneInverse.copy(skeleton.boneInverses[i]);\n        temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);\n      }\n      if (json.skins === undefined) json.skins = [];\n      json.skins.push({\n        inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),\n        joints: joints,\n        skeleton: nodeMap.get(rootJoint)\n      });\n      var skinIndex = node.skin = json.skins.length - 1;\n      return skinIndex;\n    }\n\n    /**\n     * Process Object3D node\n     * @param  {THREE.Object3D} node Object3D to processNode\n     * @return {Integer} Index of the node in the nodes list\n     */\n  }, {\n    key: \"processNode\",\n    value: function processNode(object) {\n      var json = this.json;\n      var options = this.options;\n      var nodeMap = this.nodeMap;\n      if (!json.nodes) json.nodes = [];\n      var nodeDef = {};\n      if (options.trs) {\n        var rotation = object.quaternion.toArray();\n        var position = object.position.toArray();\n        var scale = object.scale.toArray();\n        if (!equalArray(rotation, [0, 0, 0, 1])) {\n          nodeDef.rotation = rotation;\n        }\n        if (!equalArray(position, [0, 0, 0])) {\n          nodeDef.translation = position;\n        }\n        if (!equalArray(scale, [1, 1, 1])) {\n          nodeDef.scale = scale;\n        }\n      } else {\n        if (object.matrixAutoUpdate) {\n          object.updateMatrix();\n        }\n        if (isIdentityMatrix(object.matrix) === false) {\n          nodeDef.matrix = object.matrix.elements;\n        }\n      }\n\n      // We don't export empty strings name because it represents no-name in Three.js.\n      if (object.name !== '') nodeDef.name = String(object.name);\n      this.serializeUserData(object, nodeDef);\n      if (object.isMesh || object.isLine || object.isPoints) {\n        var meshIndex = this.processMesh(object);\n        if (meshIndex !== null) nodeDef.mesh = meshIndex;\n      } else if (object.isCamera) {\n        nodeDef.camera = this.processCamera(object);\n      }\n      if (object.isSkinnedMesh) this.skins.push(object);\n      if (object.children.length > 0) {\n        var children = [];\n        for (var i = 0, l = object.children.length; i < l; i++) {\n          var child = object.children[i];\n          if (child.visible || options.onlyVisible === false) {\n            var _nodeIndex = this.processNode(child);\n            if (_nodeIndex !== null) children.push(_nodeIndex);\n          }\n        }\n        if (children.length > 0) nodeDef.children = children;\n      }\n      this._invokeAll(function (ext) {\n        ext.writeNode && ext.writeNode(object, nodeDef);\n      });\n      var nodeIndex = json.nodes.push(nodeDef) - 1;\n      nodeMap.set(object, nodeIndex);\n      return nodeIndex;\n    }\n\n    /**\n     * Process Scene\n     * @param  {Scene} node Scene to process\n     */\n  }, {\n    key: \"processScene\",\n    value: function processScene(scene) {\n      var json = this.json;\n      var options = this.options;\n      if (!json.scenes) {\n        json.scenes = [];\n        json.scene = 0;\n      }\n      var sceneDef = {};\n      if (scene.name !== '') sceneDef.name = scene.name;\n      json.scenes.push(sceneDef);\n      var nodes = [];\n      for (var i = 0, l = scene.children.length; i < l; i++) {\n        var child = scene.children[i];\n        if (child.visible || options.onlyVisible === false) {\n          var nodeIndex = this.processNode(child);\n          if (nodeIndex !== null) nodes.push(nodeIndex);\n        }\n      }\n      if (nodes.length > 0) sceneDef.nodes = nodes;\n      this.serializeUserData(scene, sceneDef);\n    }\n\n    /**\n     * Creates a Scene to hold a list of objects and parse it\n     * @param  {Array} objects List of objects to process\n     */\n  }, {\n    key: \"processObjects\",\n    value: function processObjects(objects) {\n      var scene = new Scene();\n      scene.name = 'AuxScene';\n      for (var i = 0; i < objects.length; i++) {\n        // We push directly to children instead of calling `add` to prevent\n        // modify the .parent and break its original scene and hierarchy\n        scene.children.push(objects[i]);\n      }\n      this.processScene(scene);\n    }\n\n    /**\n     * @param {THREE.Object3D|Array<THREE.Object3D>} input\n     */\n  }, {\n    key: \"processInput\",\n    value: function processInput(input) {\n      var options = this.options;\n      input = input instanceof Array ? input : [input];\n      this._invokeAll(function (ext) {\n        ext.beforeParse && ext.beforeParse(input);\n      });\n      var objectsWithoutScene = [];\n      for (var i = 0; i < input.length; i++) {\n        if (input[i] instanceof Scene) {\n          this.processScene(input[i]);\n        } else {\n          objectsWithoutScene.push(input[i]);\n        }\n      }\n      if (objectsWithoutScene.length > 0) this.processObjects(objectsWithoutScene);\n      for (var _i4 = 0; _i4 < this.skins.length; ++_i4) {\n        this.processSkin(this.skins[_i4]);\n      }\n      for (var _i5 = 0; _i5 < options.animations.length; ++_i5) {\n        this.processAnimation(options.animations[_i5], input[0]);\n      }\n      this._invokeAll(function (ext) {\n        ext.afterParse && ext.afterParse(input);\n      });\n    }\n  }, {\n    key: \"_invokeAll\",\n    value: function _invokeAll(func) {\n      for (var i = 0, il = this.plugins.length; i < il; i++) {\n        func(this.plugins[i]);\n      }\n    }\n  }]);\n  return GLTFWriter;\n}();\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nvar GLTFLightExtension = /*#__PURE__*/function () {\n  function GLTFLightExtension(writer) {\n    _classCallCheck(this, GLTFLightExtension);\n    this.writer = writer;\n    this.name = 'KHR_lights_punctual';\n  }\n  _createClass(GLTFLightExtension, [{\n    key: \"writeNode\",\n    value: function writeNode(light, nodeDef) {\n      if (!light.isLight) return;\n      if (!light.isDirectionalLight && !light.isPointLight && !light.isSpotLight) {\n        console.warn('THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light);\n        return;\n      }\n      var writer = this.writer;\n      var json = writer.json;\n      var extensionsUsed = writer.extensionsUsed;\n      var lightDef = {};\n      if (light.name) lightDef.name = light.name;\n      lightDef.color = light.color.toArray();\n      lightDef.intensity = light.intensity;\n      if (light.isDirectionalLight) {\n        lightDef.type = 'directional';\n      } else if (light.isPointLight) {\n        lightDef.type = 'point';\n        if (light.distance > 0) lightDef.range = light.distance;\n      } else if (light.isSpotLight) {\n        lightDef.type = 'spot';\n        if (light.distance > 0) lightDef.range = light.distance;\n        lightDef.spot = {};\n        lightDef.spot.innerConeAngle = (light.penumbra - 1.0) * light.angle * -1.0;\n        lightDef.spot.outerConeAngle = light.angle;\n      }\n      if (light.decay !== undefined && light.decay !== 2) {\n        console.warn('THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, ' + 'and expects light.decay=2.');\n      }\n      if (light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {\n        console.warn('THREE.GLTFExporter: Light direction may be lost. For best results, ' + 'make light.target a child of the light with position 0,0,-1.');\n      }\n      if (!extensionsUsed[this.name]) {\n        json.extensions = json.extensions || {};\n        json.extensions[this.name] = {\n          lights: []\n        };\n        extensionsUsed[this.name] = true;\n      }\n      var lights = json.extensions[this.name].lights;\n      lights.push(lightDef);\n      nodeDef.extensions = nodeDef.extensions || {};\n      nodeDef.extensions[this.name] = {\n        light: lights.length - 1\n      };\n    }\n  }]);\n  return GLTFLightExtension;\n}();\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nvar GLTFMaterialsUnlitExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsUnlitExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsUnlitExtension);\n    this.writer = writer;\n    this.name = 'KHR_materials_unlit';\n  }\n  _createClass(GLTFMaterialsUnlitExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshBasicMaterial) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = {};\n      extensionsUsed[this.name] = true;\n      materialDef.pbrMetallicRoughness.metallicFactor = 0.0;\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n    }\n  }]);\n  return GLTFMaterialsUnlitExtension;\n}();\n/**\n * Specular-Glossiness Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness\n */\nvar GLTFMaterialsPBRSpecularGlossiness = /*#__PURE__*/function () {\n  function GLTFMaterialsPBRSpecularGlossiness(writer) {\n    _classCallCheck(this, GLTFMaterialsPBRSpecularGlossiness);\n    this.writer = writer;\n    this.name = 'KHR_materials_pbrSpecularGlossiness';\n  }\n  _createClass(GLTFMaterialsPBRSpecularGlossiness, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isGLTFSpecularGlossinessMaterial) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      if (materialDef.pbrMetallicRoughness.baseColorFactor) {\n        extensionDef.diffuseFactor = materialDef.pbrMetallicRoughness.baseColorFactor;\n      }\n      var specularFactor = [1, 1, 1];\n      material.specular.toArray(specularFactor, 0);\n      extensionDef.specularFactor = specularFactor;\n      extensionDef.glossinessFactor = material.glossiness;\n      if (materialDef.pbrMetallicRoughness.baseColorTexture) {\n        extensionDef.diffuseTexture = materialDef.pbrMetallicRoughness.baseColorTexture;\n      }\n      if (material.specularMap) {\n        var specularMapDef = {\n          index: writer.processTexture(material.specularMap)\n        };\n        writer.applyTextureTransform(specularMapDef, material.specularMap);\n        extensionDef.specularGlossinessTexture = specularMapDef;\n      }\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsPBRSpecularGlossiness;\n}();\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\nvar GLTFMaterialsClearcoatExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsClearcoatExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsClearcoatExtension);\n    this.writer = writer;\n    this.name = 'KHR_materials_clearcoat';\n  }\n  _createClass(GLTFMaterialsClearcoatExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      extensionDef.clearcoatFactor = material.clearcoat;\n      if (material.clearcoatMap) {\n        var clearcoatMapDef = {\n          index: writer.processTexture(material.clearcoatMap)\n        };\n        writer.applyTextureTransform(clearcoatMapDef, material.clearcoatMap);\n        extensionDef.clearcoatTexture = clearcoatMapDef;\n      }\n      extensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;\n      if (material.clearcoatRoughnessMap) {\n        var clearcoatRoughnessMapDef = {\n          index: writer.processTexture(material.clearcoatRoughnessMap)\n        };\n        writer.applyTextureTransform(clearcoatRoughnessMapDef, material.clearcoatRoughnessMap);\n        extensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;\n      }\n      if (material.clearcoatNormalMap) {\n        var clearcoatNormalMapDef = {\n          index: writer.processTexture(material.clearcoatNormalMap)\n        };\n        writer.applyTextureTransform(clearcoatNormalMapDef, material.clearcoatNormalMap);\n        extensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;\n      }\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsClearcoatExtension;\n}();\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n */\nvar GLTFMaterialsIridescenceExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsIridescenceExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsIridescenceExtension);\n    this.writer = writer;\n    this.name = 'KHR_materials_iridescence';\n  }\n  _createClass(GLTFMaterialsIridescenceExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      extensionDef.iridescenceFactor = material.iridescence;\n      if (material.iridescenceMap) {\n        var iridescenceMapDef = {\n          index: writer.processTexture(material.iridescenceMap)\n        };\n        writer.applyTextureTransform(iridescenceMapDef, material.iridescenceMap);\n        extensionDef.iridescenceTexture = iridescenceMapDef;\n      }\n      extensionDef.iridescenceIor = material.iridescenceIOR;\n      extensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[0];\n      extensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[1];\n      if (material.iridescenceThicknessMap) {\n        var iridescenceThicknessMapDef = {\n          index: writer.processTexture(material.iridescenceThicknessMap)\n        };\n        writer.applyTextureTransform(iridescenceThicknessMapDef, material.iridescenceThicknessMap);\n        extensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef;\n      }\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsIridescenceExtension;\n}();\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n */\nvar GLTFMaterialsTransmissionExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsTransmissionExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsTransmissionExtension);\n    this.writer = writer;\n    this.name = 'KHR_materials_transmission';\n  }\n  _createClass(GLTFMaterialsTransmissionExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial || material.transmission === 0) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      extensionDef.transmissionFactor = material.transmission;\n      if (material.transmissionMap) {\n        var transmissionMapDef = {\n          index: writer.processTexture(material.transmissionMap)\n        };\n        writer.applyTextureTransform(transmissionMapDef, material.transmissionMap);\n        extensionDef.transmissionTexture = transmissionMapDef;\n      }\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsTransmissionExtension;\n}();\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\nvar GLTFMaterialsVolumeExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsVolumeExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsVolumeExtension);\n    this.writer = writer;\n    this.name = 'KHR_materials_volume';\n  }\n  _createClass(GLTFMaterialsVolumeExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial || material.transmission === 0) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      extensionDef.thicknessFactor = material.thickness;\n      if (material.thicknessMap) {\n        var thicknessMapDef = {\n          index: writer.processTexture(material.thicknessMap)\n        };\n        writer.applyTextureTransform(thicknessMapDef, material.thicknessMap);\n        extensionDef.thicknessTexture = thicknessMapDef;\n      }\n      extensionDef.attenuationDistance = material.attenuationDistance;\n      extensionDef.attenuationColor = material.attenuationColor.toArray();\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsVolumeExtension;\n}();\n/**\n * Static utility functions\n */\nGLTFExporter.Utils = {\n  insertKeyframe: function insertKeyframe(track, time) {\n    var tolerance = 0.001; // 1ms\n    var valueSize = track.getValueSize();\n    var times = new track.TimeBufferType(track.times.length + 1);\n    var values = new track.ValueBufferType(track.values.length + valueSize);\n    var interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));\n    var index;\n    if (track.times.length === 0) {\n      times[0] = time;\n      for (var i = 0; i < valueSize; i++) {\n        values[i] = 0;\n      }\n      index = 0;\n    } else if (time < track.times[0]) {\n      if (Math.abs(track.times[0] - time) < tolerance) return 0;\n      times[0] = time;\n      times.set(track.times, 1);\n      values.set(interpolant.evaluate(time), 0);\n      values.set(track.values, valueSize);\n      index = 0;\n    } else if (time > track.times[track.times.length - 1]) {\n      if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\n        return track.times.length - 1;\n      }\n      times[times.length - 1] = time;\n      times.set(track.times, 0);\n      values.set(track.values, 0);\n      values.set(interpolant.evaluate(time), track.values.length);\n      index = times.length - 1;\n    } else {\n      for (var _i6 = 0; _i6 < track.times.length; _i6++) {\n        if (Math.abs(track.times[_i6] - time) < tolerance) return _i6;\n        if (track.times[_i6] < time && track.times[_i6 + 1] > time) {\n          times.set(track.times.slice(0, _i6 + 1), 0);\n          times[_i6 + 1] = time;\n          times.set(track.times.slice(_i6 + 1), _i6 + 2);\n          values.set(track.values.slice(0, (_i6 + 1) * valueSize), 0);\n          values.set(interpolant.evaluate(time), (_i6 + 1) * valueSize);\n          values.set(track.values.slice((_i6 + 1) * valueSize), (_i6 + 2) * valueSize);\n          index = _i6 + 1;\n          break;\n        }\n      }\n    }\n    track.times = times;\n    track.values = values;\n    return index;\n  },\n  mergeMorphTargetTracks: function mergeMorphTargetTracks(clip, root) {\n    var tracks = [];\n    var mergedTracks = {};\n    var sourceTracks = clip.tracks;\n    for (var i = 0; i < sourceTracks.length; ++i) {\n      var sourceTrack = sourceTracks[i];\n      var sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);\n      var sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);\n      if (sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined) {\n        // Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n        tracks.push(sourceTrack);\n        continue;\n      }\n      if (sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {\n        if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n          // This should never happen, because glTF morph target animations\n          // affect all targets already.\n          throw new Error('THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.');\n        }\n        console.warn('THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.');\n        sourceTrack = sourceTrack.clone();\n        sourceTrack.setInterpolation(InterpolateLinear);\n      }\n      var targetCount = sourceTrackNode.morphTargetInfluences.length;\n      var targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\n      if (targetIndex === undefined) {\n        throw new Error('THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex);\n      }\n      var mergedTrack = void 0;\n\n      // If this is the first time we've seen this object, create a new\n      // track to store merged keyframe data for each morph target.\n      if (mergedTracks[sourceTrackNode.uuid] === undefined) {\n        mergedTrack = sourceTrack.clone();\n        var values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);\n        for (var j = 0; j < mergedTrack.times.length; j++) {\n          values[j * targetCount + targetIndex] = mergedTrack.values[j];\n        }\n\n        // We need to take into consideration the intended target node\n        // of our original un-merged morphTarget animation.\n        mergedTrack.name = (sourceTrackBinding.nodeName || '') + '.morphTargetInfluences';\n        mergedTrack.values = values;\n        mergedTracks[sourceTrackNode.uuid] = mergedTrack;\n        tracks.push(mergedTrack);\n        continue;\n      }\n      var sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));\n      mergedTrack = mergedTracks[sourceTrackNode.uuid];\n\n      // For every existing keyframe of the merged track, write a (possibly\n      // interpolated) value from the source track.\n      for (var _j = 0; _j < mergedTrack.times.length; _j++) {\n        mergedTrack.values[_j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[_j]);\n      }\n\n      // For every existing keyframe of the source track, write a (possibly\n      // new) keyframe to the merged track. Values from the previous loop may\n      // be written again, but keyframes are de-duplicated.\n      for (var _j2 = 0; _j2 < sourceTrack.times.length; _j2++) {\n        var keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[_j2]);\n        mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[_j2];\n      }\n    }\n    clip.tracks = tracks;\n    return clip;\n  }\n};\nexport { GLTFExporter };","map":{"version":3,"names":["BufferAttribute","ClampToEdgeWrapping","DoubleSide","InterpolateDiscrete","InterpolateLinear","LinearEncoding","LinearFilter","LinearMipmapLinearFilter","LinearMipmapNearestFilter","MathUtils","Matrix4","MirroredRepeatWrapping","NearestFilter","NearestMipmapLinearFilter","NearestMipmapNearestFilter","PropertyBinding","RGBAFormat","RepeatWrapping","Scene","Source","sRGBEncoding","Vector3","GLTFExporter","pluginCallbacks","register","writer","GLTFLightExtension","GLTFMaterialsUnlitExtension","GLTFMaterialsPBRSpecularGlossiness","GLTFMaterialsTransmissionExtension","GLTFMaterialsVolumeExtension","GLTFMaterialsClearcoatExtension","GLTFMaterialsIridescenceExtension","callback","indexOf","push","splice","input","onDone","onError","options","console","warn","GLTFWriter","plugins","i","il","length","setPlugins","write","catch","scope","Promise","resolve","reject","parse","WEBGL_CONSTANTS","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","UNSIGNED_BYTE","UNSIGNED_SHORT","FLOAT","UNSIGNED_INT","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","NEAREST","LINEAR","NEAREST_MIPMAP_NEAREST","LINEAR_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_LINEAR","CLAMP_TO_EDGE","MIRRORED_REPEAT","REPEAT","THREE_TO_WEBGL","PATH_PROPERTIES","scale","position","quaternion","morphTargetInfluences","GLB_HEADER_BYTES","GLB_HEADER_MAGIC","GLB_VERSION","GLB_CHUNK_PREFIX_BYTES","GLB_CHUNK_TYPE_JSON","GLB_CHUNK_TYPE_BIN","equalArray","array1","array2","every","element","index","stringToArrayBuffer","text","TextEncoder","encode","buffer","isIdentityMatrix","matrix","elements","getMinMax","attribute","start","count","output","min","Array","itemSize","fill","Number","POSITIVE_INFINITY","max","NEGATIVE_INFINITY","a","value","array","getX","getY","getZ","getW","Math","getPaddedBufferSize","bufferSize","ceil","getPaddedArrayBuffer","arrayBuffer","paddingByte","paddedLength","byteLength","Uint8Array","set","getCanvas","document","OffscreenCanvas","createElement","getToBlobPromise","canvas","mimeType","toBlob","undefined","quality","convertToBlob","type","pending","buffers","byteOffset","nodeMap","Map","skins","extensionsUsed","uids","uid","json","asset","version","generator","cache","meshes","attributes","attributesNormalized","materials","textures","images","Object","assign","binary","trs","onlyVisible","truncateDrawRange","maxTextureSize","Infinity","animations","includeCustomExtensions","processInput","all","blob","Blob","extensionsUsedList","keys","size","reader","FileReader","readAsArrayBuffer","onloadend","binaryChunk","result","binaryChunkPrefix","DataView","ArrayBuffer","setUint32","jsonChunk","JSON","stringify","jsonChunkPrefix","header","headerView","totalByteLength","glbBlob","glbReader","readAsDataURL","base64data","uri","object","objectDef","userData","gltfExtensions","extensions","extensionName","extras","error","name","message","isRelativeCopy","has","get","normal","v","abs","fromBufferAttribute","clone","x","y","z","setX","normalize","setXYZ","mapDef","texture","didTransform","transformDef","offset","toArray","rotation","repeat","metalnessMap","roughnessMap","getEncodingConversion","map","encoding","SRGBToLinear","c","pow","LinearToLinear","metalness","image","roughness","width","height","context","getContext","fillStyle","fillRect","composite","getImageData","drawImage","convert","data","putImageData","reference","source","componentType","target","bufferViews","componentSize","dataView","setFloat32","setUint16","setUint8","bufferViewDef","processBuffer","byteStride","id","geometry","types","constructor","Float32Array","Uint32Array","Uint16Array","Error","end","end2","drawRange","minMax","bufferViewTarget","bufferView","processBufferView","accessorDef","normalized","accessors","format","flipY","cachedImages","key","toString","imageDef","ctx","translate","Uint8ClampedArray","ImageData","then","processBufferViewImage","bufferViewIndex","toDataURL","dataURL","samplers","samplerDef","magFilter","minFilter","wrapS","wrapT","textureDef","sampler","processSampler","processImage","_invokeAll","ext","writeTexture","material","isShaderMaterial","materialDef","pbrMetallicRoughness","isMeshStandardMaterial","isMeshBasicMaterial","color","concat","opacity","baseColorFactor","metallicFactor","roughnessFactor","metalRoughTexture","buildMetalRoughTexture","metalRoughMapDef","processTexture","applyTextureTransform","metallicRoughnessTexture","baseColorMapDef","baseColorTexture","emissive","multiplyScalar","emissiveIntensity","maxEmissiveComponent","r","g","b","emissiveFactor","emissiveMap","emissiveMapDef","emissiveTexture","normalMap","normalMapDef","normalScale","normalTexture","aoMap","occlusionMapDef","texCoord","aoMapIntensity","strength","occlusionTexture","transparent","alphaMode","alphaTest","alphaCutoff","side","doubleSided","serializeUserData","writeMaterial","mesh","meshCacheKeyParts","uuid","isArray","l","meshCacheKey","join","mode","isLineSegments","isLineLoop","isLine","isPoints","wireframe","isBufferGeometry","meshDef","primitives","targets","nameConversion","uv","uv2","skinWeight","skinIndex","originalNormal","getAttribute","isNormalizedNormalAttribute","setAttribute","createNormalizedNormalAttribute","modifiedAttribute","attributeName","slice","toUpperCase","validVertexAttributes","test","getUID","accessor","processAccessor","weights","targetNames","reverseDictionary","morphTargetDictionary","warned","morphAttributes","gltfAttributeName","baseAttribute","relativeAttribute","morphTargetsRelative","j","jl","isMultiMaterial","groups","materialIndex","primitive","cacheKey","indices","processMaterial","writeMesh","camera","cameras","isOrtho","isOrthographicCamera","cameraDef","orthographic","xmag","right","ymag","top","zfar","far","znear","near","perspective","aspectRatio","aspect","yfov","degToRad","fov","clip","root","Utils","mergeMorphTargetTracks","tracks","channels","track","trackBinding","parseTrackName","trackNode","findNode","nodeName","trackProperty","propertyName","objectName","isSkinnedMesh","skeleton","getBoneByName","objectIndex","inputItemSize","outputItemSize","values","times","interpolation","createInterpolant","isInterpolantFactoryMethodGLTFCubicSpline","getInterpolation","node","path","nodes","rootJoint","bones","joints","inverseBindMatrices","temporaryBoneInverse","copy","boneInverses","multiply","bindMatrix","skin","nodeDef","translation","matrixAutoUpdate","updateMatrix","String","isMesh","meshIndex","processMesh","isCamera","processCamera","children","child","visible","nodeIndex","processNode","writeNode","scene","scenes","sceneDef","objects","processScene","beforeParse","objectsWithoutScene","processObjects","processSkin","processAnimation","afterParse","func","light","isLight","isDirectionalLight","isPointLight","isSpotLight","lightDef","intensity","distance","range","spot","innerConeAngle","penumbra","angle","outerConeAngle","decay","parent","lights","isGLTFSpecularGlossinessMaterial","extensionDef","diffuseFactor","specularFactor","specular","glossinessFactor","glossiness","diffuseTexture","specularMap","specularMapDef","specularGlossinessTexture","isMeshPhysicalMaterial","clearcoatFactor","clearcoat","clearcoatMap","clearcoatMapDef","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughness","clearcoatRoughnessMap","clearcoatRoughnessMapDef","clearcoatRoughnessTexture","clearcoatNormalMap","clearcoatNormalMapDef","clearcoatNormalTexture","iridescenceFactor","iridescence","iridescenceMap","iridescenceMapDef","iridescenceTexture","iridescenceIor","iridescenceIOR","iridescenceThicknessMinimum","iridescenceThicknessRange","iridescenceThicknessMaximum","iridescenceThicknessMap","iridescenceThicknessMapDef","iridescenceThicknessTexture","transmission","transmissionFactor","transmissionMap","transmissionMapDef","transmissionTexture","thicknessFactor","thickness","thicknessMap","thicknessMapDef","thicknessTexture","attenuationDistance","attenuationColor","insertKeyframe","time","tolerance","valueSize","getValueSize","TimeBufferType","ValueBufferType","interpolant","evaluate","mergedTracks","sourceTracks","sourceTrack","sourceTrackBinding","sourceTrackNode","propertyIndex","InterpolantFactoryMethodDiscrete","InterpolantFactoryMethodLinear","setInterpolation","targetCount","targetIndex","mergedTrack","sourceInterpolant","keyframeIndex"],"sources":["/home/xkruzel/node_modules/three/examples/jsm/exporters/GLTFExporter.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tClampToEdgeWrapping,\n\tDoubleSide,\n\tInterpolateDiscrete,\n\tInterpolateLinear,\n\tLinearEncoding,\n\tLinearFilter,\n\tLinearMipmapLinearFilter,\n\tLinearMipmapNearestFilter,\n\tMathUtils,\n\tMatrix4,\n\tMirroredRepeatWrapping,\n\tNearestFilter,\n\tNearestMipmapLinearFilter,\n\tNearestMipmapNearestFilter,\n\tPropertyBinding,\n\tRGBAFormat,\n\tRepeatWrapping,\n\tScene,\n\tSource,\n\tsRGBEncoding,\n\tVector3\n} from 'three';\n\n\nclass GLTFExporter {\n\n\tconstructor() {\n\n\t\tthis.pluginCallbacks = [];\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFLightExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsUnlitExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsPBRSpecularGlossiness( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsTransmissionExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsVolumeExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsClearcoatExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsIridescenceExtension( writer );\n\n\t\t} );\n\n\t}\n\n\tregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {\n\n\t\t\tthis.pluginCallbacks.push( callback );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tunregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {\n\n\t\t\tthis.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Parse scenes and generate GLTF output\n\t * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n\t * @param  {Function} onDone  Callback on completed\n\t * @param  {Function} onError  Callback on errors\n\t * @param  {Object} options options\n\t */\n\tparse( input, onDone, onError, options ) {\n\n\t\tif ( typeof onError === 'object' ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: parse() expects options as the fourth argument now.' );\n\n\t\t\toptions = onError;\n\n\t\t}\n\n\t\tconst writer = new GLTFWriter();\n\t\tconst plugins = [];\n\n\t\tfor ( let i = 0, il = this.pluginCallbacks.length; i < il; i ++ ) {\n\n\t\t\tplugins.push( this.pluginCallbacks[ i ]( writer ) );\n\n\t\t}\n\n\t\twriter.setPlugins( plugins );\n\t\twriter.write( input, onDone, options ).catch( onError );\n\n\t}\n\n\tparseAsync( input, options ) {\n\n\t\tconst scope = this;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tscope.parse( input, resolve, reject, options );\n\n\t\t} );\n\n\t}\n\n}\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst WEBGL_CONSTANTS = {\n\tPOINTS: 0x0000,\n\tLINES: 0x0001,\n\tLINE_LOOP: 0x0002,\n\tLINE_STRIP: 0x0003,\n\tTRIANGLES: 0x0004,\n\tTRIANGLE_STRIP: 0x0005,\n\tTRIANGLE_FAN: 0x0006,\n\n\tUNSIGNED_BYTE: 0x1401,\n\tUNSIGNED_SHORT: 0x1403,\n\tFLOAT: 0x1406,\n\tUNSIGNED_INT: 0x1405,\n\tARRAY_BUFFER: 0x8892,\n\tELEMENT_ARRAY_BUFFER: 0x8893,\n\n\tNEAREST: 0x2600,\n\tLINEAR: 0x2601,\n\tNEAREST_MIPMAP_NEAREST: 0x2700,\n\tLINEAR_MIPMAP_NEAREST: 0x2701,\n\tNEAREST_MIPMAP_LINEAR: 0x2702,\n\tLINEAR_MIPMAP_LINEAR: 0x2703,\n\n\tCLAMP_TO_EDGE: 33071,\n\tMIRRORED_REPEAT: 33648,\n\tREPEAT: 10497\n};\n\nconst THREE_TO_WEBGL = {};\n\nTHREE_TO_WEBGL[ NearestFilter ] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[ NearestMipmapNearestFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[ NearestMipmapLinearFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ LinearFilter ] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[ LinearMipmapNearestFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[ LinearMipmapLinearFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\n\nTHREE_TO_WEBGL[ ClampToEdgeWrapping ] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[ RepeatWrapping ] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[ MirroredRepeatWrapping ] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\n\nconst PATH_PROPERTIES = {\n\tscale: 'scale',\n\tposition: 'translation',\n\tquaternion: 'rotation',\n\tmorphTargetInfluences: 'weights'\n};\n\n// GLB constants\n// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\nconst GLB_HEADER_BYTES = 12;\nconst GLB_HEADER_MAGIC = 0x46546C67;\nconst GLB_VERSION = 2;\n\nconst GLB_CHUNK_PREFIX_BYTES = 8;\nconst GLB_CHUNK_TYPE_JSON = 0x4E4F534A;\nconst GLB_CHUNK_TYPE_BIN = 0x004E4942;\n\n//------------------------------------------------------------------------------\n// Utility functions\n//------------------------------------------------------------------------------\n\n/**\n * Compare two arrays\n * @param  {Array} array1 Array 1 to compare\n * @param  {Array} array2 Array 2 to compare\n * @return {Boolean}        Returns true if both arrays are equal\n */\nfunction equalArray( array1, array2 ) {\n\n\treturn ( array1.length === array2.length ) && array1.every( function ( element, index ) {\n\n\t\treturn element === array2[ index ];\n\n\t} );\n\n}\n\n/**\n * Converts a string to an ArrayBuffer.\n * @param  {string} text\n * @return {ArrayBuffer}\n */\nfunction stringToArrayBuffer( text ) {\n\n\treturn new TextEncoder().encode( text ).buffer;\n\n}\n\n/**\n * Is identity matrix\n *\n * @param {Matrix4} matrix\n * @returns {Boolean} Returns true, if parameter is identity matrix\n */\nfunction isIdentityMatrix( matrix ) {\n\n\treturn equalArray( matrix.elements, [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ] );\n\n}\n\n/**\n * Get the min and max vectors from the given attribute\n * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\n * @param  {Integer} start\n * @param  {Integer} count\n * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\n */\nfunction getMinMax( attribute, start, count ) {\n\n\tconst output = {\n\n\t\tmin: new Array( attribute.itemSize ).fill( Number.POSITIVE_INFINITY ),\n\t\tmax: new Array( attribute.itemSize ).fill( Number.NEGATIVE_INFINITY )\n\n\t};\n\n\tfor ( let i = start; i < start + count; i ++ ) {\n\n\t\tfor ( let a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\tlet value;\n\n\t\t\tif ( attribute.itemSize > 4 ) {\n\n\t\t\t\t // no support for interleaved data for itemSize > 4\n\n\t\t\t\tvalue = attribute.array[ i * attribute.itemSize + a ];\n\n\t\t\t} else {\n\n\t\t\t\tif ( a === 0 ) value = attribute.getX( i );\n\t\t\t\telse if ( a === 1 ) value = attribute.getY( i );\n\t\t\t\telse if ( a === 2 ) value = attribute.getZ( i );\n\t\t\t\telse if ( a === 3 ) value = attribute.getW( i );\n\n\t\t\t}\n\n\t\t\toutput.min[ a ] = Math.min( output.min[ a ], value );\n\t\t\toutput.max[ a ] = Math.max( output.max[ a ], value );\n\n\t\t}\n\n\t}\n\n\treturn output;\n\n}\n\n/**\n * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n *\n * @param {Integer} bufferSize The size the original buffer.\n * @returns {Integer} new buffer size with required padding.\n *\n */\nfunction getPaddedBufferSize( bufferSize ) {\n\n\treturn Math.ceil( bufferSize / 4 ) * 4;\n\n}\n\n/**\n * Returns a buffer aligned to 4-byte boundary.\n *\n * @param {ArrayBuffer} arrayBuffer Buffer to pad\n * @param {Integer} paddingByte (Optional)\n * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n */\nfunction getPaddedArrayBuffer( arrayBuffer, paddingByte = 0 ) {\n\n\tconst paddedLength = getPaddedBufferSize( arrayBuffer.byteLength );\n\n\tif ( paddedLength !== arrayBuffer.byteLength ) {\n\n\t\tconst array = new Uint8Array( paddedLength );\n\t\tarray.set( new Uint8Array( arrayBuffer ) );\n\n\t\tif ( paddingByte !== 0 ) {\n\n\t\t\tfor ( let i = arrayBuffer.byteLength; i < paddedLength; i ++ ) {\n\n\t\t\t\tarray[ i ] = paddingByte;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn array.buffer;\n\n\t}\n\n\treturn arrayBuffer;\n\n}\n\nfunction getCanvas() {\n\n\tif ( typeof document === 'undefined' && typeof OffscreenCanvas !== 'undefined' ) {\n\n\t\treturn new OffscreenCanvas( 1, 1 );\n\n\t}\n\n\treturn document.createElement( 'canvas' );\n\n}\n\nfunction getToBlobPromise( canvas, mimeType ) {\n\n\tif ( canvas.toBlob !== undefined ) {\n\n\t\treturn new Promise( ( resolve ) => canvas.toBlob( resolve, mimeType ) );\n\n\t}\n\n\tlet quality;\n\n\t// Blink's implementation of convertToBlob seems to default to a quality level of 100%\n\t// Use the Blink default quality levels of toBlob instead so that file sizes are comparable.\n\tif ( mimeType === 'image/jpeg' ) {\n\n\t\tquality = 0.92;\n\n\t} else if ( mimeType === 'image/webp' ) {\n\n\t\tquality = 0.8;\n\n\t}\n\n\treturn canvas.convertToBlob( {\n\n\t\ttype: mimeType,\n\t\tquality: quality\n\n\t} );\n\n}\n\n/**\n * Writer\n */\nclass GLTFWriter {\n\n\tconstructor() {\n\n\t\tthis.plugins = [];\n\n\t\tthis.options = {};\n\t\tthis.pending = [];\n\t\tthis.buffers = [];\n\n\t\tthis.byteOffset = 0;\n\t\tthis.buffers = [];\n\t\tthis.nodeMap = new Map();\n\t\tthis.skins = [];\n\t\tthis.extensionsUsed = {};\n\n\t\tthis.uids = new Map();\n\t\tthis.uid = 0;\n\n\t\tthis.json = {\n\t\t\tasset: {\n\t\t\t\tversion: '2.0',\n\t\t\t\tgenerator: 'THREE.GLTFExporter'\n\t\t\t}\n\t\t};\n\n\t\tthis.cache = {\n\t\t\tmeshes: new Map(),\n\t\t\tattributes: new Map(),\n\t\t\tattributesNormalized: new Map(),\n\t\t\tmaterials: new Map(),\n\t\t\ttextures: new Map(),\n\t\t\timages: new Map()\n\t\t};\n\n\t}\n\n\tsetPlugins( plugins ) {\n\n\t\tthis.plugins = plugins;\n\n\t}\n\n\t/**\n\t * Parse scenes and generate GLTF output\n\t * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n\t * @param  {Function} onDone  Callback on completed\n\t * @param  {Object} options options\n\t */\n\tasync write( input, onDone, options ) {\n\n\t\tthis.options = Object.assign( {}, {\n\t\t\t// default options\n\t\t\tbinary: false,\n\t\t\ttrs: false,\n\t\t\tonlyVisible: true,\n\t\t\ttruncateDrawRange: true,\n\t\t\tmaxTextureSize: Infinity,\n\t\t\tanimations: [],\n\t\t\tincludeCustomExtensions: false\n\t\t}, options );\n\n\t\tif ( this.options.animations.length > 0 ) {\n\n\t\t\t// Only TRS properties, and not matrices, may be targeted by animation.\n\t\t\tthis.options.trs = true;\n\n\t\t}\n\n\t\tthis.processInput( input );\n\n\t\tawait Promise.all( this.pending );\n\n\t\tconst writer = this;\n\t\tconst buffers = writer.buffers;\n\t\tconst json = writer.json;\n\t\toptions = writer.options;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\t// Merge buffers.\n\t\tconst blob = new Blob( buffers, { type: 'application/octet-stream' } );\n\n\t\t// Declare extensions.\n\t\tconst extensionsUsedList = Object.keys( extensionsUsed );\n\n\t\tif ( extensionsUsedList.length > 0 ) json.extensionsUsed = extensionsUsedList;\n\n\t\t// Update bytelength of the single buffer.\n\t\tif ( json.buffers && json.buffers.length > 0 ) json.buffers[ 0 ].byteLength = blob.size;\n\n\t\tif ( options.binary === true ) {\n\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\n\t\t\tconst reader = new FileReader();\n\t\t\treader.readAsArrayBuffer( blob );\n\t\t\treader.onloadend = function () {\n\n\t\t\t\t// Binary chunk.\n\t\t\t\tconst binaryChunk = getPaddedArrayBuffer( reader.result );\n\t\t\t\tconst binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\n\t\t\t\tbinaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );\n\t\t\t\tbinaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true );\n\n\t\t\t\t// JSON chunk.\n\t\t\t\tconst jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( json ) ), 0x20 );\n\t\t\t\tconst jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\n\t\t\t\tjsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );\n\t\t\t\tjsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true );\n\n\t\t\t\t// GLB header.\n\t\t\t\tconst header = new ArrayBuffer( GLB_HEADER_BYTES );\n\t\t\t\tconst headerView = new DataView( header );\n\t\t\t\theaderView.setUint32( 0, GLB_HEADER_MAGIC, true );\n\t\t\t\theaderView.setUint32( 4, GLB_VERSION, true );\n\t\t\t\tconst totalByteLength = GLB_HEADER_BYTES\n\t\t\t\t\t+ jsonChunkPrefix.byteLength + jsonChunk.byteLength\n\t\t\t\t\t+ binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n\t\t\t\theaderView.setUint32( 8, totalByteLength, true );\n\n\t\t\t\tconst glbBlob = new Blob( [\n\t\t\t\t\theader,\n\t\t\t\t\tjsonChunkPrefix,\n\t\t\t\t\tjsonChunk,\n\t\t\t\t\tbinaryChunkPrefix,\n\t\t\t\t\tbinaryChunk\n\t\t\t\t], { type: 'application/octet-stream' } );\n\n\t\t\t\tconst glbReader = new FileReader();\n\t\t\t\tglbReader.readAsArrayBuffer( glbBlob );\n\t\t\t\tglbReader.onloadend = function () {\n\n\t\t\t\t\tonDone( glbReader.result );\n\n\t\t\t\t};\n\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tif ( json.buffers && json.buffers.length > 0 ) {\n\n\t\t\t\tconst reader = new FileReader();\n\t\t\t\treader.readAsDataURL( blob );\n\t\t\t\treader.onloadend = function () {\n\n\t\t\t\t\tconst base64data = reader.result;\n\t\t\t\t\tjson.buffers[ 0 ].uri = base64data;\n\t\t\t\t\tonDone( json );\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tonDone( json );\n\n\t\t\t}\n\n\t\t}\n\n\n\t}\n\n\t/**\n\t * Serializes a userData.\n\t *\n\t * @param {THREE.Object3D|THREE.Material} object\n\t * @param {Object} objectDef\n\t */\n\tserializeUserData( object, objectDef ) {\n\n\t\tif ( Object.keys( object.userData ).length === 0 ) return;\n\n\t\tconst options = this.options;\n\t\tconst extensionsUsed = this.extensionsUsed;\n\n\t\ttry {\n\n\t\t\tconst json = JSON.parse( JSON.stringify( object.userData ) );\n\n\t\t\tif ( options.includeCustomExtensions && json.gltfExtensions ) {\n\n\t\t\t\tif ( objectDef.extensions === undefined ) objectDef.extensions = {};\n\n\t\t\t\tfor ( const extensionName in json.gltfExtensions ) {\n\n\t\t\t\t\tobjectDef.extensions[ extensionName ] = json.gltfExtensions[ extensionName ];\n\t\t\t\t\textensionsUsed[ extensionName ] = true;\n\n\t\t\t\t}\n\n\t\t\t\tdelete json.gltfExtensions;\n\n\t\t\t}\n\n\t\t\tif ( Object.keys( json ).length > 0 ) objectDef.extras = json;\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: userData of \\'' + object.name + '\\' ' +\n\t\t\t\t'won\\'t be serialized because of JSON.stringify error - ' + error.message );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns ids for buffer attributes.\n\t * @param  {Object} object\n\t * @return {Integer}\n\t */\n\tgetUID( attribute, isRelativeCopy = false ) {\n\n\t\tif ( this.uids.has( attribute ) === false ) {\n\n\t\t\tconst uids = new Map();\n\n\t\t\tuids.set( true, this.uid ++ );\n\t\t\tuids.set( false, this.uid ++ );\n\n\t\t\tthis.uids.set( attribute, uids );\n\n\t\t}\n\n\t\tconst uids = this.uids.get( attribute );\n\n\t\treturn uids.get( isRelativeCopy );\n\n\t}\n\n\t/**\n\t * Checks if normal attribute values are normalized.\n\t *\n\t * @param {BufferAttribute} normal\n\t * @returns {Boolean}\n\t */\n\tisNormalizedNormalAttribute( normal ) {\n\n\t\tconst cache = this.cache;\n\n\t\tif ( cache.attributesNormalized.has( normal ) ) return false;\n\n\t\tconst v = new Vector3();\n\n\t\tfor ( let i = 0, il = normal.count; i < il; i ++ ) {\n\n\t\t\t// 0.0005 is from glTF-validator\n\t\t\tif ( Math.abs( v.fromBufferAttribute( normal, i ).length() - 1.0 ) > 0.0005 ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Creates normalized normal buffer attribute.\n\t *\n\t * @param {BufferAttribute} normal\n\t * @returns {BufferAttribute}\n\t *\n\t */\n\tcreateNormalizedNormalAttribute( normal ) {\n\n\t\tconst cache = this.cache;\n\n\t\tif ( cache.attributesNormalized.has( normal ) )\treturn cache.attributesNormalized.get( normal );\n\n\t\tconst attribute = normal.clone();\n\t\tconst v = new Vector3();\n\n\t\tfor ( let i = 0, il = attribute.count; i < il; i ++ ) {\n\n\t\t\tv.fromBufferAttribute( attribute, i );\n\n\t\t\tif ( v.x === 0 && v.y === 0 && v.z === 0 ) {\n\n\t\t\t\t// if values can't be normalized set (1, 0, 0)\n\t\t\t\tv.setX( 1.0 );\n\n\t\t\t} else {\n\n\t\t\t\tv.normalize();\n\n\t\t\t}\n\n\t\t\tattribute.setXYZ( i, v.x, v.y, v.z );\n\n\t\t}\n\n\t\tcache.attributesNormalized.set( normal, attribute );\n\n\t\treturn attribute;\n\n\t}\n\n\t/**\n\t * Applies a texture transform, if present, to the map definition. Requires\n\t * the KHR_texture_transform extension.\n\t *\n\t * @param {Object} mapDef\n\t * @param {THREE.Texture} texture\n\t */\n\tapplyTextureTransform( mapDef, texture ) {\n\n\t\tlet didTransform = false;\n\t\tconst transformDef = {};\n\n\t\tif ( texture.offset.x !== 0 || texture.offset.y !== 0 ) {\n\n\t\t\ttransformDef.offset = texture.offset.toArray();\n\t\t\tdidTransform = true;\n\n\t\t}\n\n\t\tif ( texture.rotation !== 0 ) {\n\n\t\t\ttransformDef.rotation = texture.rotation;\n\t\t\tdidTransform = true;\n\n\t\t}\n\n\t\tif ( texture.repeat.x !== 1 || texture.repeat.y !== 1 ) {\n\n\t\t\ttransformDef.scale = texture.repeat.toArray();\n\t\t\tdidTransform = true;\n\n\t\t}\n\n\t\tif ( didTransform ) {\n\n\t\t\tmapDef.extensions = mapDef.extensions || {};\n\t\t\tmapDef.extensions[ 'KHR_texture_transform' ] = transformDef;\n\t\t\tthis.extensionsUsed[ 'KHR_texture_transform' ] = true;\n\n\t\t}\n\n\t}\n\n\tbuildMetalRoughTexture( metalnessMap, roughnessMap ) {\n\n\t\tif ( metalnessMap === roughnessMap ) return metalnessMap;\n\n\t\tfunction getEncodingConversion( map ) {\n\n\t\t\tif ( map.encoding === sRGBEncoding ) {\n\n\t\t\t\treturn function SRGBToLinear( c ) {\n\n\t\t\t\t\treturn ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn function LinearToLinear( c ) {\n\n\t\t\t\treturn c;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconsole.warn( 'THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.' );\n\n\t\tconst metalness = metalnessMap?.image;\n\t\tconst roughness = roughnessMap?.image;\n\n\t\tconst width = Math.max( metalness?.width || 0, roughness?.width || 0 );\n\t\tconst height = Math.max( metalness?.height || 0, roughness?.height || 0 );\n\n\t\tconst canvas = getCanvas();\n\t\tcanvas.width = width;\n\t\tcanvas.height = height;\n\n\t\tconst context = canvas.getContext( '2d' );\n\t\tcontext.fillStyle = '#00ffff';\n\t\tcontext.fillRect( 0, 0, width, height );\n\n\t\tconst composite = context.getImageData( 0, 0, width, height );\n\n\t\tif ( metalness ) {\n\n\t\t\tcontext.drawImage( metalness, 0, 0, width, height );\n\n\t\t\tconst convert = getEncodingConversion( metalnessMap );\n\t\t\tconst data = context.getImageData( 0, 0, width, height ).data;\n\n\t\t\tfor ( let i = 2; i < data.length; i += 4 ) {\n\n\t\t\t\tcomposite.data[ i ] = convert( data[ i ] / 256 ) * 256;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( roughness ) {\n\n\t\t\tcontext.drawImage( roughness, 0, 0, width, height );\n\n\t\t\tconst convert = getEncodingConversion( roughnessMap );\n\t\t\tconst data = context.getImageData( 0, 0, width, height ).data;\n\n\t\t\tfor ( let i = 1; i < data.length; i += 4 ) {\n\n\t\t\t\tcomposite.data[ i ] = convert( data[ i ] / 256 ) * 256;\n\n\t\t\t}\n\n\t\t}\n\n\t\tcontext.putImageData( composite, 0, 0 );\n\n\t\t//\n\n\t\tconst reference = metalnessMap || roughnessMap;\n\n\t\tconst texture = reference.clone();\n\n\t\ttexture.source = new Source( canvas );\n\t\ttexture.encoding = LinearEncoding;\n\n\t\treturn texture;\n\n\t}\n\n\t/**\n\t * Process a buffer to append to the default one.\n\t * @param  {ArrayBuffer} buffer\n\t * @return {Integer}\n\t */\n\tprocessBuffer( buffer ) {\n\n\t\tconst json = this.json;\n\t\tconst buffers = this.buffers;\n\n\t\tif ( ! json.buffers ) json.buffers = [ { byteLength: 0 } ];\n\n\t\t// All buffers are merged before export.\n\t\tbuffers.push( buffer );\n\n\t\treturn 0;\n\n\t}\n\n\t/**\n\t * Process and generate a BufferView\n\t * @param  {BufferAttribute} attribute\n\t * @param  {number} componentType\n\t * @param  {number} start\n\t * @param  {number} count\n\t * @param  {number} target (Optional) Target usage of the BufferView\n\t * @return {Object}\n\t */\n\tprocessBufferView( attribute, componentType, start, count, target ) {\n\n\t\tconst json = this.json;\n\n\t\tif ( ! json.bufferViews ) json.bufferViews = [];\n\n\t\t// Create a new dataview and dump the attribute's array into it\n\n\t\tlet componentSize;\n\n\t\tif ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {\n\n\t\t\tcomponentSize = 1;\n\n\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {\n\n\t\t\tcomponentSize = 2;\n\n\t\t} else {\n\n\t\t\tcomponentSize = 4;\n\n\t\t}\n\n\t\tconst byteLength = getPaddedBufferSize( count * attribute.itemSize * componentSize );\n\t\tconst dataView = new DataView( new ArrayBuffer( byteLength ) );\n\t\tlet offset = 0;\n\n\t\tfor ( let i = start; i < start + count; i ++ ) {\n\n\t\t\tfor ( let a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\t\tlet value;\n\n\t\t\t\tif ( attribute.itemSize > 4 ) {\n\n\t\t\t\t\t // no support for interleaved data for itemSize > 4\n\n\t\t\t\t\tvalue = attribute.array[ i * attribute.itemSize + a ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( a === 0 ) value = attribute.getX( i );\n\t\t\t\t\telse if ( a === 1 ) value = attribute.getY( i );\n\t\t\t\t\telse if ( a === 2 ) value = attribute.getZ( i );\n\t\t\t\t\telse if ( a === 3 ) value = attribute.getW( i );\n\n\t\t\t\t}\n\n\t\t\t\tif ( componentType === WEBGL_CONSTANTS.FLOAT ) {\n\n\t\t\t\t\tdataView.setFloat32( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_INT ) {\n\n\t\t\t\t\tdataView.setUint32( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {\n\n\t\t\t\t\tdataView.setUint16( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {\n\n\t\t\t\t\tdataView.setUint8( offset, value );\n\n\t\t\t\t}\n\n\t\t\t\toffset += componentSize;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst bufferViewDef = {\n\n\t\t\tbuffer: this.processBuffer( dataView.buffer ),\n\t\t\tbyteOffset: this.byteOffset,\n\t\t\tbyteLength: byteLength\n\n\t\t};\n\n\t\tif ( target !== undefined ) bufferViewDef.target = target;\n\n\t\tif ( target === WEBGL_CONSTANTS.ARRAY_BUFFER ) {\n\n\t\t\t// Only define byteStride for vertex attributes.\n\t\t\tbufferViewDef.byteStride = attribute.itemSize * componentSize;\n\n\t\t}\n\n\t\tthis.byteOffset += byteLength;\n\n\t\tjson.bufferViews.push( bufferViewDef );\n\n\t\t// @TODO Merge bufferViews where possible.\n\t\tconst output = {\n\n\t\t\tid: json.bufferViews.length - 1,\n\t\t\tbyteLength: 0\n\n\t\t};\n\n\t\treturn output;\n\n\t}\n\n\t/**\n\t * Process and generate a BufferView from an image Blob.\n\t * @param {Blob} blob\n\t * @return {Promise<Integer>}\n\t */\n\tprocessBufferViewImage( blob ) {\n\n\t\tconst writer = this;\n\t\tconst json = writer.json;\n\n\t\tif ( ! json.bufferViews ) json.bufferViews = [];\n\n\t\treturn new Promise( function ( resolve ) {\n\n\t\t\tconst reader = new FileReader();\n\t\t\treader.readAsArrayBuffer( blob );\n\t\t\treader.onloadend = function () {\n\n\t\t\t\tconst buffer = getPaddedArrayBuffer( reader.result );\n\n\t\t\t\tconst bufferViewDef = {\n\t\t\t\t\tbuffer: writer.processBuffer( buffer ),\n\t\t\t\t\tbyteOffset: writer.byteOffset,\n\t\t\t\t\tbyteLength: buffer.byteLength\n\t\t\t\t};\n\n\t\t\t\twriter.byteOffset += buffer.byteLength;\n\t\t\t\tresolve( json.bufferViews.push( bufferViewDef ) - 1 );\n\n\t\t\t};\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Process attribute to generate an accessor\n\t * @param  {BufferAttribute} attribute Attribute to process\n\t * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n\t * @param  {Integer} start (Optional)\n\t * @param  {Integer} count (Optional)\n\t * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n\t */\n\tprocessAccessor( attribute, geometry, start, count ) {\n\n\t\tconst options = this.options;\n\t\tconst json = this.json;\n\n\t\tconst types = {\n\n\t\t\t1: 'SCALAR',\n\t\t\t2: 'VEC2',\n\t\t\t3: 'VEC3',\n\t\t\t4: 'VEC4',\n\t\t\t16: 'MAT4'\n\n\t\t};\n\n\t\tlet componentType;\n\n\t\t// Detect the component type of the attribute array (float, uint or ushort)\n\t\tif ( attribute.array.constructor === Float32Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.FLOAT;\n\n\t\t} else if ( attribute.array.constructor === Uint32Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n\n\t\t} else if ( attribute.array.constructor === Uint16Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n\n\t\t} else if ( attribute.array.constructor === Uint8Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.GLTFExporter: Unsupported bufferAttribute component type.' );\n\n\t\t}\n\n\t\tif ( start === undefined ) start = 0;\n\t\tif ( count === undefined ) count = attribute.count;\n\n\t\t// @TODO Indexed buffer geometry with drawRange not supported yet\n\t\tif ( options.truncateDrawRange && geometry !== undefined && geometry.index === null ) {\n\n\t\t\tconst end = start + count;\n\t\t\tconst end2 = geometry.drawRange.count === Infinity\n\t\t\t\t? attribute.count\n\t\t\t\t: geometry.drawRange.start + geometry.drawRange.count;\n\n\t\t\tstart = Math.max( start, geometry.drawRange.start );\n\t\t\tcount = Math.min( end, end2 ) - start;\n\n\t\t\tif ( count < 0 ) count = 0;\n\n\t\t}\n\n\t\t// Skip creating an accessor if the attribute doesn't have data to export\n\t\tif ( count === 0 ) return null;\n\n\t\tconst minMax = getMinMax( attribute, start, count );\n\t\tlet bufferViewTarget;\n\n\t\t// If geometry isn't provided, don't infer the target usage of the bufferView. For\n\t\t// animation samplers, target must not be set.\n\t\tif ( geometry !== undefined ) {\n\n\t\t\tbufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n\n\t\t}\n\n\t\tconst bufferView = this.processBufferView( attribute, componentType, start, count, bufferViewTarget );\n\n\t\tconst accessorDef = {\n\n\t\t\tbufferView: bufferView.id,\n\t\t\tbyteOffset: bufferView.byteOffset,\n\t\t\tcomponentType: componentType,\n\t\t\tcount: count,\n\t\t\tmax: minMax.max,\n\t\t\tmin: minMax.min,\n\t\t\ttype: types[ attribute.itemSize ]\n\n\t\t};\n\n\t\tif ( attribute.normalized === true ) accessorDef.normalized = true;\n\t\tif ( ! json.accessors ) json.accessors = [];\n\n\t\treturn json.accessors.push( accessorDef ) - 1;\n\n\t}\n\n\t/**\n\t * Process image\n\t * @param  {Image} image to process\n\t * @param  {Integer} format of the image (RGBAFormat)\n\t * @param  {Boolean} flipY before writing out the image\n\t * @param  {String} mimeType export format\n\t * @return {Integer}     Index of the processed texture in the \"images\" array\n\t */\n\tprocessImage( image, format, flipY, mimeType = 'image/png' ) {\n\n\t\tconst writer = this;\n\t\tconst cache = writer.cache;\n\t\tconst json = writer.json;\n\t\tconst options = writer.options;\n\t\tconst pending = writer.pending;\n\n\t\tif ( ! cache.images.has( image ) ) cache.images.set( image, {} );\n\n\t\tconst cachedImages = cache.images.get( image );\n\n\t\tconst key = mimeType + ':flipY/' + flipY.toString();\n\n\t\tif ( cachedImages[ key ] !== undefined ) return cachedImages[ key ];\n\n\t\tif ( ! json.images ) json.images = [];\n\n\t\tconst imageDef = { mimeType: mimeType };\n\n\t\tconst canvas = getCanvas();\n\n\t\tcanvas.width = Math.min( image.width, options.maxTextureSize );\n\t\tcanvas.height = Math.min( image.height, options.maxTextureSize );\n\n\t\tconst ctx = canvas.getContext( '2d' );\n\n\t\tif ( flipY === true ) {\n\n\t\t\tctx.translate( 0, canvas.height );\n\t\t\tctx.scale( 1, - 1 );\n\n\t\t}\n\n\t\tif ( image.data !== undefined ) { // THREE.DataTexture\n\n\t\t\tif ( format !== RGBAFormat ) {\n\n\t\t\t\tconsole.error( 'GLTFExporter: Only RGBAFormat is supported.' );\n\n\t\t\t}\n\n\t\t\tif ( image.width > options.maxTextureSize || image.height > options.maxTextureSize ) {\n\n\t\t\t\tconsole.warn( 'GLTFExporter: Image size is bigger than maxTextureSize', image );\n\n\t\t\t}\n\n\t\t\tconst data = new Uint8ClampedArray( image.height * image.width * 4 );\n\n\t\t\tfor ( let i = 0; i < data.length; i += 4 ) {\n\n\t\t\t\tdata[ i + 0 ] = image.data[ i + 0 ];\n\t\t\t\tdata[ i + 1 ] = image.data[ i + 1 ];\n\t\t\t\tdata[ i + 2 ] = image.data[ i + 2 ];\n\t\t\t\tdata[ i + 3 ] = image.data[ i + 3 ];\n\n\t\t\t}\n\n\t\t\tctx.putImageData( new ImageData( data, image.width, image.height ), 0, 0 );\n\n\t\t} else {\n\n\t\t\tctx.drawImage( image, 0, 0, canvas.width, canvas.height );\n\n\t\t}\n\n\t\tif ( options.binary === true ) {\n\n\t\t\tpending.push(\n\n\t\t\t\tgetToBlobPromise( canvas, mimeType )\n\t\t\t\t\t.then( blob => writer.processBufferViewImage( blob ) )\n\t\t\t\t\t.then( bufferViewIndex => {\n\n\t\t\t\t\t\timageDef.bufferView = bufferViewIndex;\n\n\t\t\t\t\t} )\n\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tif ( canvas.toDataURL !== undefined ) {\n\n\t\t\t\timageDef.uri = canvas.toDataURL( mimeType );\n\n\t\t\t} else {\n\n\t\t\t\tpending.push(\n\n\t\t\t\t\tgetToBlobPromise( canvas, mimeType )\n\t\t\t\t\t\t.then( blob => new FileReader().readAsDataURL( blob ) )\n\t\t\t\t\t\t.then( dataURL => {\n\n\t\t\t\t\t\t\timageDef.uri = dataURL;\n\n\t\t\t\t\t\t} )\n\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst index = json.images.push( imageDef ) - 1;\n\t\tcachedImages[ key ] = index;\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * Process sampler\n\t * @param  {Texture} map Texture to process\n\t * @return {Integer}     Index of the processed texture in the \"samplers\" array\n\t */\n\tprocessSampler( map ) {\n\n\t\tconst json = this.json;\n\n\t\tif ( ! json.samplers ) json.samplers = [];\n\n\t\tconst samplerDef = {\n\t\t\tmagFilter: THREE_TO_WEBGL[ map.magFilter ],\n\t\t\tminFilter: THREE_TO_WEBGL[ map.minFilter ],\n\t\t\twrapS: THREE_TO_WEBGL[ map.wrapS ],\n\t\t\twrapT: THREE_TO_WEBGL[ map.wrapT ]\n\t\t};\n\n\t\treturn json.samplers.push( samplerDef ) - 1;\n\n\t}\n\n\t/**\n\t * Process texture\n\t * @param  {Texture} map Map to process\n\t * @return {Integer} Index of the processed texture in the \"textures\" array\n\t */\n\tprocessTexture( map ) {\n\n\t\tconst cache = this.cache;\n\t\tconst json = this.json;\n\n\t\tif ( cache.textures.has( map ) ) return cache.textures.get( map );\n\n\t\tif ( ! json.textures ) json.textures = [];\n\n\t\tlet mimeType = map.userData.mimeType;\n\n\t\tif ( mimeType === 'image/webp' ) mimeType = 'image/png';\n\n\t\tconst textureDef = {\n\t\t\tsampler: this.processSampler( map ),\n\t\t\tsource: this.processImage( map.image, map.format, map.flipY, mimeType )\n\t\t};\n\n\t\tif ( map.name ) textureDef.name = map.name;\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.writeTexture && ext.writeTexture( map, textureDef );\n\n\t\t} );\n\n\t\tconst index = json.textures.push( textureDef ) - 1;\n\t\tcache.textures.set( map, index );\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * Process material\n\t * @param  {THREE.Material} material Material to process\n\t * @return {Integer|null} Index of the processed material in the \"materials\" array\n\t */\n\tprocessMaterial( material ) {\n\n\t\tconst cache = this.cache;\n\t\tconst json = this.json;\n\n\t\tif ( cache.materials.has( material ) ) return cache.materials.get( material );\n\n\t\tif ( material.isShaderMaterial ) {\n\n\t\t\tconsole.warn( 'GLTFExporter: THREE.ShaderMaterial not supported.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( ! json.materials ) json.materials = [];\n\n\t\t// @QUESTION Should we avoid including any attribute that has the default value?\n\t\tconst materialDef = {\tpbrMetallicRoughness: {} };\n\n\t\tif ( material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true ) {\n\n\t\t\tconsole.warn( 'GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.' );\n\n\t\t}\n\n\t\t// pbrMetallicRoughness.baseColorFactor\n\t\tconst color = material.color.toArray().concat( [ material.opacity ] );\n\n\t\tif ( ! equalArray( color, [ 1, 1, 1, 1 ] ) ) {\n\n\t\t\tmaterialDef.pbrMetallicRoughness.baseColorFactor = color;\n\n\t\t}\n\n\t\tif ( material.isMeshStandardMaterial ) {\n\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n\t\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n\n\t\t} else {\n\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n\t\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n\n\t\t}\n\n\t\t// pbrMetallicRoughness.metallicRoughnessTexture\n\t\tif ( material.metalnessMap || material.roughnessMap ) {\n\n\t\t\tconst metalRoughTexture = this.buildMetalRoughTexture( material.metalnessMap, material.roughnessMap );\n\n\t\t\tconst metalRoughMapDef = { index: this.processTexture( metalRoughTexture ) };\n\t\t\tthis.applyTextureTransform( metalRoughMapDef, metalRoughTexture );\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n\n\t\t}\n\n\t\t// pbrMetallicRoughness.baseColorTexture or pbrSpecularGlossiness diffuseTexture\n\t\tif ( material.map ) {\n\n\t\t\tconst baseColorMapDef = { index: this.processTexture( material.map ) };\n\t\t\tthis.applyTextureTransform( baseColorMapDef, material.map );\n\t\t\tmaterialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n\n\t\t}\n\n\t\tif ( material.emissive ) {\n\n\t\t\t// note: emissive components are limited to stay within the 0 - 1 range to accommodate glTF spec. see #21849 and #22000.\n\t\t\tconst emissive = material.emissive.clone().multiplyScalar( material.emissiveIntensity );\n\t\t\tconst maxEmissiveComponent = Math.max( emissive.r, emissive.g, emissive.b );\n\n\t\t\tif ( maxEmissiveComponent > 1 ) {\n\n\t\t\t\temissive.multiplyScalar( 1 / maxEmissiveComponent );\n\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited' );\n\n\t\t\t}\n\n\t\t\tif ( maxEmissiveComponent > 0 ) {\n\n\t\t\t\tmaterialDef.emissiveFactor = emissive.toArray();\n\n\t\t\t}\n\n\t\t\t// emissiveTexture\n\t\t\tif ( material.emissiveMap ) {\n\n\t\t\t\tconst emissiveMapDef = { index: this.processTexture( material.emissiveMap ) };\n\t\t\t\tthis.applyTextureTransform( emissiveMapDef, material.emissiveMap );\n\t\t\t\tmaterialDef.emissiveTexture = emissiveMapDef;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// normalTexture\n\t\tif ( material.normalMap ) {\n\n\t\t\tconst normalMapDef = { index: this.processTexture( material.normalMap ) };\n\n\t\t\tif ( material.normalScale && material.normalScale.x !== 1 ) {\n\n\t\t\t\t// glTF normal scale is univariate. Ignore `y`, which may be flipped.\n\t\t\t\t// Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\t\tnormalMapDef.scale = material.normalScale.x;\n\n\t\t\t}\n\n\t\t\tthis.applyTextureTransform( normalMapDef, material.normalMap );\n\t\t\tmaterialDef.normalTexture = normalMapDef;\n\n\t\t}\n\n\t\t// occlusionTexture\n\t\tif ( material.aoMap ) {\n\n\t\t\tconst occlusionMapDef = {\n\t\t\t\tindex: this.processTexture( material.aoMap ),\n\t\t\t\ttexCoord: 1\n\t\t\t};\n\n\t\t\tif ( material.aoMapIntensity !== 1.0 ) {\n\n\t\t\t\tocclusionMapDef.strength = material.aoMapIntensity;\n\n\t\t\t}\n\n\t\t\tthis.applyTextureTransform( occlusionMapDef, material.aoMap );\n\t\t\tmaterialDef.occlusionTexture = occlusionMapDef;\n\n\t\t}\n\n\t\t// alphaMode\n\t\tif ( material.transparent ) {\n\n\t\t\tmaterialDef.alphaMode = 'BLEND';\n\n\t\t} else {\n\n\t\t\tif ( material.alphaTest > 0.0 ) {\n\n\t\t\t\tmaterialDef.alphaMode = 'MASK';\n\t\t\t\tmaterialDef.alphaCutoff = material.alphaTest;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// doubleSided\n\t\tif ( material.side === DoubleSide ) materialDef.doubleSided = true;\n\t\tif ( material.name !== '' ) materialDef.name = material.name;\n\n\t\tthis.serializeUserData( material, materialDef );\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.writeMaterial && ext.writeMaterial( material, materialDef );\n\n\t\t} );\n\n\t\tconst index = json.materials.push( materialDef ) - 1;\n\t\tcache.materials.set( material, index );\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * Process mesh\n\t * @param  {THREE.Mesh} mesh Mesh to process\n\t * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n\t */\n\tprocessMesh( mesh ) {\n\n\t\tconst cache = this.cache;\n\t\tconst json = this.json;\n\n\t\tconst meshCacheKeyParts = [ mesh.geometry.uuid ];\n\n\t\tif ( Array.isArray( mesh.material ) ) {\n\n\t\t\tfor ( let i = 0, l = mesh.material.length; i < l; i ++ ) {\n\n\t\t\t\tmeshCacheKeyParts.push( mesh.material[ i ].uuid\t);\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tmeshCacheKeyParts.push( mesh.material.uuid );\n\n\t\t}\n\n\t\tconst meshCacheKey = meshCacheKeyParts.join( ':' );\n\n\t\tif ( cache.meshes.has( meshCacheKey ) ) return cache.meshes.get( meshCacheKey );\n\n\t\tconst geometry = mesh.geometry;\n\n\t\tlet mode;\n\n\t\t// Use the correct mode\n\t\tif ( mesh.isLineSegments ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.LINES;\n\n\t\t} else if ( mesh.isLineLoop ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.LINE_LOOP;\n\n\t\t} else if ( mesh.isLine ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.LINE_STRIP;\n\n\t\t} else if ( mesh.isPoints ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.POINTS;\n\n\t\t} else {\n\n\t\t\tmode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n\n\t\t}\n\n\t\tif ( geometry.isBufferGeometry !== true ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.' );\n\n\t\t}\n\n\t\tconst meshDef = {};\n\t\tconst attributes = {};\n\t\tconst primitives = [];\n\t\tconst targets = [];\n\n\t\t// Conversion between attributes names in threejs and gltf spec\n\t\tconst nameConversion = {\n\t\t\tuv: 'TEXCOORD_0',\n\t\t\tuv2: 'TEXCOORD_1',\n\t\t\tcolor: 'COLOR_0',\n\t\t\tskinWeight: 'WEIGHTS_0',\n\t\t\tskinIndex: 'JOINTS_0'\n\t\t};\n\n\t\tconst originalNormal = geometry.getAttribute( 'normal' );\n\n\t\tif ( originalNormal !== undefined && ! this.isNormalizedNormalAttribute( originalNormal ) ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.' );\n\n\t\t\tgeometry.setAttribute( 'normal', this.createNormalizedNormalAttribute( originalNormal ) );\n\n\t\t}\n\n\t\t// @QUESTION Detect if .vertexColors = true?\n\t\t// For every attribute create an accessor\n\t\tlet modifiedAttribute = null;\n\n\t\tfor ( let attributeName in geometry.attributes ) {\n\n\t\t\t// Ignore morph target attributes, which are exported later.\n\t\t\tif ( attributeName.slice( 0, 5 ) === 'morph' ) continue;\n\n\t\t\tconst attribute = geometry.attributes[ attributeName ];\n\t\t\tattributeName = nameConversion[ attributeName ] || attributeName.toUpperCase();\n\n\t\t\t// Prefix all geometry attributes except the ones specifically\n\t\t\t// listed in the spec; non-spec attributes are considered custom.\n\t\t\tconst validVertexAttributes =\n\t\t\t\t\t/^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n\n\t\t\tif ( ! validVertexAttributes.test( attributeName ) ) attributeName = '_' + attributeName;\n\n\t\t\tif ( cache.attributes.has( this.getUID( attribute ) ) ) {\n\n\t\t\t\tattributes[ attributeName ] = cache.attributes.get( this.getUID( attribute ) );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n\t\t\tmodifiedAttribute = null;\n\t\t\tconst array = attribute.array;\n\n\t\t\tif ( attributeName === 'JOINTS_0' &&\n\t\t\t\t! ( array instanceof Uint16Array ) &&\n\t\t\t\t! ( array instanceof Uint8Array ) ) {\n\n\t\t\t\tconsole.warn( 'GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.' );\n\t\t\t\tmodifiedAttribute = new BufferAttribute( new Uint16Array( array ), attribute.itemSize, attribute.normalized );\n\n\t\t\t}\n\n\t\t\tconst accessor = this.processAccessor( modifiedAttribute || attribute, geometry );\n\n\t\t\tif ( accessor !== null ) {\n\n\t\t\t\tattributes[ attributeName ] = accessor;\n\t\t\t\tcache.attributes.set( this.getUID( attribute ), accessor );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( originalNormal !== undefined ) geometry.setAttribute( 'normal', originalNormal );\n\n\t\t// Skip if no exportable attributes found\n\t\tif ( Object.keys( attributes ).length === 0 ) return null;\n\n\t\t// Morph targets\n\t\tif ( mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0 ) {\n\n\t\t\tconst weights = [];\n\t\t\tconst targetNames = [];\n\t\t\tconst reverseDictionary = {};\n\n\t\t\tif ( mesh.morphTargetDictionary !== undefined ) {\n\n\t\t\t\tfor ( const key in mesh.morphTargetDictionary ) {\n\n\t\t\t\t\treverseDictionary[ mesh.morphTargetDictionary[ key ] ] = key;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < mesh.morphTargetInfluences.length; ++ i ) {\n\n\t\t\t\tconst target = {};\n\t\t\t\tlet warned = false;\n\n\t\t\t\tfor ( const attributeName in geometry.morphAttributes ) {\n\n\t\t\t\t\t// glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n\t\t\t\t\t// Three.js doesn't support TANGENT yet.\n\n\t\t\t\t\tif ( attributeName !== 'position' && attributeName !== 'normal' ) {\n\n\t\t\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'GLTFExporter: Only POSITION and NORMAL morph are supported.' );\n\t\t\t\t\t\t\twarned = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst attribute = geometry.morphAttributes[ attributeName ][ i ];\n\t\t\t\t\tconst gltfAttributeName = attributeName.toUpperCase();\n\n\t\t\t\t\t// Three.js morph attribute has absolute values while the one of glTF has relative values.\n\t\t\t\t\t//\n\t\t\t\t\t// glTF 2.0 Specification:\n\t\t\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n\t\t\t\t\tconst baseAttribute = geometry.attributes[ attributeName ];\n\n\t\t\t\t\tif ( cache.attributes.has( this.getUID( attribute, true ) ) ) {\n\n\t\t\t\t\t\ttarget[ gltfAttributeName ] = cache.attributes.get( this.getUID( attribute, true ) );\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Clones attribute not to override\n\t\t\t\t\tconst relativeAttribute = attribute.clone();\n\n\t\t\t\t\tif ( ! geometry.morphTargetsRelative ) {\n\n\t\t\t\t\t\tfor ( let j = 0, jl = attribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\trelativeAttribute.setXYZ(\n\t\t\t\t\t\t\t\tj,\n\t\t\t\t\t\t\t\tattribute.getX( j ) - baseAttribute.getX( j ),\n\t\t\t\t\t\t\t\tattribute.getY( j ) - baseAttribute.getY( j ),\n\t\t\t\t\t\t\t\tattribute.getZ( j ) - baseAttribute.getZ( j )\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttarget[ gltfAttributeName ] = this.processAccessor( relativeAttribute, geometry );\n\t\t\t\t\tcache.attributes.set( this.getUID( baseAttribute, true ), target[ gltfAttributeName ] );\n\n\t\t\t\t}\n\n\t\t\t\ttargets.push( target );\n\n\t\t\t\tweights.push( mesh.morphTargetInfluences[ i ] );\n\n\t\t\t\tif ( mesh.morphTargetDictionary !== undefined ) targetNames.push( reverseDictionary[ i ] );\n\n\t\t\t}\n\n\t\t\tmeshDef.weights = weights;\n\n\t\t\tif ( targetNames.length > 0 ) {\n\n\t\t\t\tmeshDef.extras = {};\n\t\t\t\tmeshDef.extras.targetNames = targetNames;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst isMultiMaterial = Array.isArray( mesh.material );\n\n\t\tif ( isMultiMaterial && geometry.groups.length === 0 ) return null;\n\n\t\tconst materials = isMultiMaterial ? mesh.material : [ mesh.material ];\n\t\tconst groups = isMultiMaterial ? geometry.groups : [ { materialIndex: 0, start: undefined, count: undefined } ];\n\n\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\tconst primitive = {\n\t\t\t\tmode: mode,\n\t\t\t\tattributes: attributes,\n\t\t\t};\n\n\t\t\tthis.serializeUserData( geometry, primitive );\n\n\t\t\tif ( targets.length > 0 ) primitive.targets = targets;\n\n\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\tlet cacheKey = this.getUID( geometry.index );\n\n\t\t\t\tif ( groups[ i ].start !== undefined || groups[ i ].count !== undefined ) {\n\n\t\t\t\t\tcacheKey += ':' + groups[ i ].start + ':' + groups[ i ].count;\n\n\t\t\t\t}\n\n\t\t\t\tif ( cache.attributes.has( cacheKey ) ) {\n\n\t\t\t\t\tprimitive.indices = cache.attributes.get( cacheKey );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tprimitive.indices = this.processAccessor( geometry.index, geometry, groups[ i ].start, groups[ i ].count );\n\t\t\t\t\tcache.attributes.set( cacheKey, primitive.indices );\n\n\t\t\t\t}\n\n\t\t\t\tif ( primitive.indices === null ) delete primitive.indices;\n\n\t\t\t}\n\n\t\t\tconst material = this.processMaterial( materials[ groups[ i ].materialIndex ] );\n\n\t\t\tif ( material !== null ) primitive.material = material;\n\n\t\t\tprimitives.push( primitive );\n\n\t\t}\n\n\t\tmeshDef.primitives = primitives;\n\n\t\tif ( ! json.meshes ) json.meshes = [];\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.writeMesh && ext.writeMesh( mesh, meshDef );\n\n\t\t} );\n\n\t\tconst index = json.meshes.push( meshDef ) - 1;\n\t\tcache.meshes.set( meshCacheKey, index );\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * Process camera\n\t * @param  {THREE.Camera} camera Camera to process\n\t * @return {Integer}      Index of the processed mesh in the \"camera\" array\n\t */\n\tprocessCamera( camera ) {\n\n\t\tconst json = this.json;\n\n\t\tif ( ! json.cameras ) json.cameras = [];\n\n\t\tconst isOrtho = camera.isOrthographicCamera;\n\n\t\tconst cameraDef = {\n\t\t\ttype: isOrtho ? 'orthographic' : 'perspective'\n\t\t};\n\n\t\tif ( isOrtho ) {\n\n\t\t\tcameraDef.orthographic = {\n\t\t\t\txmag: camera.right * 2,\n\t\t\t\tymag: camera.top * 2,\n\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tcameraDef.perspective = {\n\t\t\t\taspectRatio: camera.aspect,\n\t\t\t\tyfov: MathUtils.degToRad( camera.fov ),\n\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\t\t\t};\n\n\t\t}\n\n\t\t// Question: Is saving \"type\" as name intentional?\n\t\tif ( camera.name !== '' ) cameraDef.name = camera.type;\n\n\t\treturn json.cameras.push( cameraDef ) - 1;\n\n\t}\n\n\t/**\n\t * Creates glTF animation entry from AnimationClip object.\n\t *\n\t * Status:\n\t * - Only properties listed in PATH_PROPERTIES may be animated.\n\t *\n\t * @param {THREE.AnimationClip} clip\n\t * @param {THREE.Object3D} root\n\t * @return {number|null}\n\t */\n\tprocessAnimation( clip, root ) {\n\n\t\tconst json = this.json;\n\t\tconst nodeMap = this.nodeMap;\n\n\t\tif ( ! json.animations ) json.animations = [];\n\n\t\tclip = GLTFExporter.Utils.mergeMorphTargetTracks( clip.clone(), root );\n\n\t\tconst tracks = clip.tracks;\n\t\tconst channels = [];\n\t\tconst samplers = [];\n\n\t\tfor ( let i = 0; i < tracks.length; ++ i ) {\n\n\t\t\tconst track = tracks[ i ];\n\t\t\tconst trackBinding = PropertyBinding.parseTrackName( track.name );\n\t\t\tlet trackNode = PropertyBinding.findNode( root, trackBinding.nodeName );\n\t\t\tconst trackProperty = PATH_PROPERTIES[ trackBinding.propertyName ];\n\n\t\t\tif ( trackBinding.objectName === 'bones' ) {\n\n\t\t\t\tif ( trackNode.isSkinnedMesh === true ) {\n\n\t\t\t\t\ttrackNode = trackNode.skeleton.getBoneByName( trackBinding.objectIndex );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttrackNode = undefined;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! trackNode || ! trackProperty ) {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Could not export animation track \"%s\".', track.name );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tconst inputItemSize = 1;\n\t\t\tlet outputItemSize = track.values.length / track.times.length;\n\n\t\t\tif ( trackProperty === PATH_PROPERTIES.morphTargetInfluences ) {\n\n\t\t\t\toutputItemSize /= trackNode.morphTargetInfluences.length;\n\n\t\t\t}\n\n\t\t\tlet interpolation;\n\n\t\t\t// @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n\n\t\t\t// Detecting glTF cubic spline interpolant by checking factory method's special property\n\t\t\t// GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n\t\t\t// valid value from .getInterpolation().\n\t\t\tif ( track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true ) {\n\n\t\t\t\tinterpolation = 'CUBICSPLINE';\n\n\t\t\t\t// itemSize of CUBICSPLINE keyframe is 9\n\t\t\t\t// (VEC3 * 3: inTangent, splineVertex, and outTangent)\n\t\t\t\t// but needs to be stored as VEC3 so dividing by 3 here.\n\t\t\t\toutputItemSize /= 3;\n\n\t\t\t} else if ( track.getInterpolation() === InterpolateDiscrete ) {\n\n\t\t\t\tinterpolation = 'STEP';\n\n\t\t\t} else {\n\n\t\t\t\tinterpolation = 'LINEAR';\n\n\t\t\t}\n\n\t\t\tsamplers.push( {\n\t\t\t\tinput: this.processAccessor( new BufferAttribute( track.times, inputItemSize ) ),\n\t\t\t\toutput: this.processAccessor( new BufferAttribute( track.values, outputItemSize ) ),\n\t\t\t\tinterpolation: interpolation\n\t\t\t} );\n\n\t\t\tchannels.push( {\n\t\t\t\tsampler: samplers.length - 1,\n\t\t\t\ttarget: {\n\t\t\t\t\tnode: nodeMap.get( trackNode ),\n\t\t\t\t\tpath: trackProperty\n\t\t\t\t}\n\t\t\t} );\n\n\t\t}\n\n\t\tjson.animations.push( {\n\t\t\tname: clip.name || 'clip_' + json.animations.length,\n\t\t\tsamplers: samplers,\n\t\t\tchannels: channels\n\t\t} );\n\n\t\treturn json.animations.length - 1;\n\n\t}\n\n\t/**\n\t * @param {THREE.Object3D} object\n\t * @return {number|null}\n\t */\n\t processSkin( object ) {\n\n\t\tconst json = this.json;\n\t\tconst nodeMap = this.nodeMap;\n\n\t\tconst node = json.nodes[ nodeMap.get( object ) ];\n\n\t\tconst skeleton = object.skeleton;\n\n\t\tif ( skeleton === undefined ) return null;\n\n\t\tconst rootJoint = object.skeleton.bones[ 0 ];\n\n\t\tif ( rootJoint === undefined ) return null;\n\n\t\tconst joints = [];\n\t\tconst inverseBindMatrices = new Float32Array( skeleton.bones.length * 16 );\n\t\tconst temporaryBoneInverse = new Matrix4();\n\n\t\tfor ( let i = 0; i < skeleton.bones.length; ++ i ) {\n\n\t\t\tjoints.push( nodeMap.get( skeleton.bones[ i ] ) );\n\t\t\ttemporaryBoneInverse.copy( skeleton.boneInverses[ i ] );\n\t\t\ttemporaryBoneInverse.multiply( object.bindMatrix ).toArray( inverseBindMatrices, i * 16 );\n\n\t\t}\n\n\t\tif ( json.skins === undefined ) json.skins = [];\n\n\t\tjson.skins.push( {\n\t\t\tinverseBindMatrices: this.processAccessor( new BufferAttribute( inverseBindMatrices, 16 ) ),\n\t\t\tjoints: joints,\n\t\t\tskeleton: nodeMap.get( rootJoint )\n\t\t} );\n\n\t\tconst skinIndex = node.skin = json.skins.length - 1;\n\n\t\treturn skinIndex;\n\n\t}\n\n\t/**\n\t * Process Object3D node\n\t * @param  {THREE.Object3D} node Object3D to processNode\n\t * @return {Integer} Index of the node in the nodes list\n\t */\n\tprocessNode( object ) {\n\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\t\tconst nodeMap = this.nodeMap;\n\n\t\tif ( ! json.nodes ) json.nodes = [];\n\n\t\tconst nodeDef = {};\n\n\t\tif ( options.trs ) {\n\n\t\t\tconst rotation = object.quaternion.toArray();\n\t\t\tconst position = object.position.toArray();\n\t\t\tconst scale = object.scale.toArray();\n\n\t\t\tif ( ! equalArray( rotation, [ 0, 0, 0, 1 ] ) ) {\n\n\t\t\t\tnodeDef.rotation = rotation;\n\n\t\t\t}\n\n\t\t\tif ( ! equalArray( position, [ 0, 0, 0 ] ) ) {\n\n\t\t\t\tnodeDef.translation = position;\n\n\t\t\t}\n\n\t\t\tif ( ! equalArray( scale, [ 1, 1, 1 ] ) ) {\n\n\t\t\t\tnodeDef.scale = scale;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( object.matrixAutoUpdate ) {\n\n\t\t\t\tobject.updateMatrix();\n\n\t\t\t}\n\n\t\t\tif ( isIdentityMatrix( object.matrix ) === false ) {\n\n\t\t\t\tnodeDef.matrix = object.matrix.elements;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// We don't export empty strings name because it represents no-name in Three.js.\n\t\tif ( object.name !== '' ) nodeDef.name = String( object.name );\n\n\t\tthis.serializeUserData( object, nodeDef );\n\n\t\tif ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\tconst meshIndex = this.processMesh( object );\n\n\t\t\tif ( meshIndex !== null ) nodeDef.mesh = meshIndex;\n\n\t\t} else if ( object.isCamera ) {\n\n\t\t\tnodeDef.camera = this.processCamera( object );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) this.skins.push( object );\n\n\t\tif ( object.children.length > 0 ) {\n\n\t\t\tconst children = [];\n\n\t\t\tfor ( let i = 0, l = object.children.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = object.children[ i ];\n\n\t\t\t\tif ( child.visible || options.onlyVisible === false ) {\n\n\t\t\t\t\tconst nodeIndex = this.processNode( child );\n\n\t\t\t\t\tif ( nodeIndex !== null ) children.push( nodeIndex );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( children.length > 0 ) nodeDef.children = children;\n\n\t\t}\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.writeNode && ext.writeNode( object, nodeDef );\n\n\t\t} );\n\n\t\tconst nodeIndex = json.nodes.push( nodeDef ) - 1;\n\t\tnodeMap.set( object, nodeIndex );\n\t\treturn nodeIndex;\n\n\t}\n\n\t/**\n\t * Process Scene\n\t * @param  {Scene} node Scene to process\n\t */\n\tprocessScene( scene ) {\n\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\n\t\tif ( ! json.scenes ) {\n\n\t\t\tjson.scenes = [];\n\t\t\tjson.scene = 0;\n\n\t\t}\n\n\t\tconst sceneDef = {};\n\n\t\tif ( scene.name !== '' ) sceneDef.name = scene.name;\n\n\t\tjson.scenes.push( sceneDef );\n\n\t\tconst nodes = [];\n\n\t\tfor ( let i = 0, l = scene.children.length; i < l; i ++ ) {\n\n\t\t\tconst child = scene.children[ i ];\n\n\t\t\tif ( child.visible || options.onlyVisible === false ) {\n\n\t\t\t\tconst nodeIndex = this.processNode( child );\n\n\t\t\t\tif ( nodeIndex !== null ) nodes.push( nodeIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( nodes.length > 0 ) sceneDef.nodes = nodes;\n\n\t\tthis.serializeUserData( scene, sceneDef );\n\n\t}\n\n\t/**\n\t * Creates a Scene to hold a list of objects and parse it\n\t * @param  {Array} objects List of objects to process\n\t */\n\tprocessObjects( objects ) {\n\n\t\tconst scene = new Scene();\n\t\tscene.name = 'AuxScene';\n\n\t\tfor ( let i = 0; i < objects.length; i ++ ) {\n\n\t\t\t// We push directly to children instead of calling `add` to prevent\n\t\t\t// modify the .parent and break its original scene and hierarchy\n\t\t\tscene.children.push( objects[ i ] );\n\n\t\t}\n\n\t\tthis.processScene( scene );\n\n\t}\n\n\t/**\n\t * @param {THREE.Object3D|Array<THREE.Object3D>} input\n\t */\n\tprocessInput( input ) {\n\n\t\tconst options = this.options;\n\n\t\tinput = input instanceof Array ? input : [ input ];\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.beforeParse && ext.beforeParse( input );\n\n\t\t} );\n\n\t\tconst objectsWithoutScene = [];\n\n\t\tfor ( let i = 0; i < input.length; i ++ ) {\n\n\t\t\tif ( input[ i ] instanceof Scene ) {\n\n\t\t\t\tthis.processScene( input[ i ] );\n\n\t\t\t} else {\n\n\t\t\t\tobjectsWithoutScene.push( input[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( objectsWithoutScene.length > 0 ) this.processObjects( objectsWithoutScene );\n\n\t\tfor ( let i = 0; i < this.skins.length; ++ i ) {\n\n\t\t\tthis.processSkin( this.skins[ i ] );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < options.animations.length; ++ i ) {\n\n\t\t\tthis.processAnimation( options.animations[ i ], input[ 0 ] );\n\n\t\t}\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.afterParse && ext.afterParse( input );\n\n\t\t} );\n\n\t}\n\n\t_invokeAll( func ) {\n\n\t\tfor ( let i = 0, il = this.plugins.length; i < il; i ++ ) {\n\n\t\t\tfunc( this.plugins[ i ] );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nclass GLTFLightExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_lights_punctual';\n\n\t}\n\n\twriteNode( light, nodeDef ) {\n\n\t\tif ( ! light.isLight ) return;\n\n\t\tif ( ! light.isDirectionalLight && ! light.isPointLight && ! light.isSpotLight ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst writer = this.writer;\n\t\tconst json = writer.json;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst lightDef = {};\n\n\t\tif ( light.name ) lightDef.name = light.name;\n\n\t\tlightDef.color = light.color.toArray();\n\n\t\tlightDef.intensity = light.intensity;\n\n\t\tif ( light.isDirectionalLight ) {\n\n\t\t\tlightDef.type = 'directional';\n\n\t\t} else if ( light.isPointLight ) {\n\n\t\t\tlightDef.type = 'point';\n\n\t\t\tif ( light.distance > 0 ) lightDef.range = light.distance;\n\n\t\t} else if ( light.isSpotLight ) {\n\n\t\t\tlightDef.type = 'spot';\n\n\t\t\tif ( light.distance > 0 ) lightDef.range = light.distance;\n\n\t\t\tlightDef.spot = {};\n\t\t\tlightDef.spot.innerConeAngle = ( light.penumbra - 1.0 ) * light.angle * - 1.0;\n\t\t\tlightDef.spot.outerConeAngle = light.angle;\n\n\t\t}\n\n\t\tif ( light.decay !== undefined && light.decay !== 2 ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, '\n\t\t\t\t+ 'and expects light.decay=2.' );\n\n\t\t}\n\n\t\tif ( light.target\n\t\t\t\t&& ( light.target.parent !== light\n\t\t\t\t|| light.target.position.x !== 0\n\t\t\t\t|| light.target.position.y !== 0\n\t\t\t\t|| light.target.position.z !== - 1 ) ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Light direction may be lost. For best results, '\n\t\t\t\t+ 'make light.target a child of the light with position 0,0,-1.' );\n\n\t\t}\n\n\t\tif ( ! extensionsUsed[ this.name ] ) {\n\n\t\t\tjson.extensions = json.extensions || {};\n\t\t\tjson.extensions[ this.name ] = { lights: [] };\n\t\t\textensionsUsed[ this.name ] = true;\n\n\t\t}\n\n\t\tconst lights = json.extensions[ this.name ].lights;\n\t\tlights.push( lightDef );\n\n\t\tnodeDef.extensions = nodeDef.extensions || {};\n\t\tnodeDef.extensions[ this.name ] = { light: lights.length - 1 };\n\n\t}\n\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nclass GLTFMaterialsUnlitExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_unlit';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshBasicMaterial ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = {};\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = 0.0;\n\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n\n\t}\n\n}\n\n/**\n * Specular-Glossiness Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness\n */\nclass GLTFMaterialsPBRSpecularGlossiness {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_pbrSpecularGlossiness';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isGLTFSpecularGlossinessMaterial ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\tif ( materialDef.pbrMetallicRoughness.baseColorFactor ) {\n\n\t\t\textensionDef.diffuseFactor = materialDef.pbrMetallicRoughness.baseColorFactor;\n\n\t\t}\n\n\t\tconst specularFactor = [ 1, 1, 1 ];\n\t\tmaterial.specular.toArray( specularFactor, 0 );\n\t\textensionDef.specularFactor = specularFactor;\n\t\textensionDef.glossinessFactor = material.glossiness;\n\n\t\tif ( materialDef.pbrMetallicRoughness.baseColorTexture ) {\n\n\t\t\textensionDef.diffuseTexture = materialDef.pbrMetallicRoughness.baseColorTexture;\n\n\t\t}\n\n\t\tif ( material.specularMap ) {\n\n\t\t\tconst specularMapDef = { index: writer.processTexture( material.specularMap ) };\n\t\t\twriter.applyTextureTransform( specularMapDef, material.specularMap );\n\t\t\textensionDef.specularGlossinessTexture = specularMapDef;\n\n\t\t}\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\nclass GLTFMaterialsClearcoatExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_clearcoat';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.clearcoatFactor = material.clearcoat;\n\n\t\tif ( material.clearcoatMap ) {\n\n\t\t\tconst clearcoatMapDef = { index: writer.processTexture( material.clearcoatMap ) };\n\t\t\twriter.applyTextureTransform( clearcoatMapDef, material.clearcoatMap );\n\t\t\textensionDef.clearcoatTexture = clearcoatMapDef;\n\n\t\t}\n\n\t\textensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;\n\n\t\tif ( material.clearcoatRoughnessMap ) {\n\n\t\t\tconst clearcoatRoughnessMapDef = { index: writer.processTexture( material.clearcoatRoughnessMap ) };\n\t\t\twriter.applyTextureTransform( clearcoatRoughnessMapDef, material.clearcoatRoughnessMap );\n\t\t\textensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;\n\n\t\t}\n\n\t\tif ( material.clearcoatNormalMap ) {\n\n\t\t\tconst clearcoatNormalMapDef = { index: writer.processTexture( material.clearcoatNormalMap ) };\n\t\t\twriter.applyTextureTransform( clearcoatNormalMapDef, material.clearcoatNormalMap );\n\t\t\textensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;\n\n\t\t}\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\n\t}\n\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n */\nclass GLTFMaterialsIridescenceExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_iridescence';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.iridescenceFactor = material.iridescence;\n\n\t\tif ( material.iridescenceMap ) {\n\n\t\t\tconst iridescenceMapDef = { index: writer.processTexture( material.iridescenceMap ) };\n\t\t\twriter.applyTextureTransform( iridescenceMapDef, material.iridescenceMap );\n\t\t\textensionDef.iridescenceTexture = iridescenceMapDef;\n\n\t\t}\n\n\t\textensionDef.iridescenceIor = material.iridescenceIOR;\n\t\textensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[ 0 ];\n\t\textensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[ 1 ];\n\n\t\tif ( material.iridescenceThicknessMap ) {\n\n\t\t\tconst iridescenceThicknessMapDef = { index: writer.processTexture( material.iridescenceThicknessMap ) };\n\t\t\twriter.applyTextureTransform( iridescenceThicknessMapDef, material.iridescenceThicknessMap );\n\t\t\textensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef;\n\n\t\t}\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n */\nclass GLTFMaterialsTransmissionExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_transmission';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.transmission === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.transmissionFactor = material.transmission;\n\n\t\tif ( material.transmissionMap ) {\n\n\t\t\tconst transmissionMapDef = { index: writer.processTexture( material.transmissionMap ) };\n\t\t\twriter.applyTextureTransform( transmissionMapDef, material.transmissionMap );\n\t\t\textensionDef.transmissionTexture = transmissionMapDef;\n\n\t\t}\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\nclass GLTFMaterialsVolumeExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_volume';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.transmission === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.thicknessFactor = material.thickness;\n\n\t\tif ( material.thicknessMap ) {\n\n\t\t\tconst thicknessMapDef = { index: writer.processTexture( material.thicknessMap ) };\n\t\t\twriter.applyTextureTransform( thicknessMapDef, material.thicknessMap );\n\t\t\textensionDef.thicknessTexture = thicknessMapDef;\n\n\t\t}\n\n\t\textensionDef.attenuationDistance = material.attenuationDistance;\n\t\textensionDef.attenuationColor = material.attenuationColor.toArray();\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Static utility functions\n */\nGLTFExporter.Utils = {\n\n\tinsertKeyframe: function ( track, time ) {\n\n\t\tconst tolerance = 0.001; // 1ms\n\t\tconst valueSize = track.getValueSize();\n\n\t\tconst times = new track.TimeBufferType( track.times.length + 1 );\n\t\tconst values = new track.ValueBufferType( track.values.length + valueSize );\n\t\tconst interpolant = track.createInterpolant( new track.ValueBufferType( valueSize ) );\n\n\t\tlet index;\n\n\t\tif ( track.times.length === 0 ) {\n\n\t\t\ttimes[ 0 ] = time;\n\n\t\t\tfor ( let i = 0; i < valueSize; i ++ ) {\n\n\t\t\t\tvalues[ i ] = 0;\n\n\t\t\t}\n\n\t\t\tindex = 0;\n\n\t\t} else if ( time < track.times[ 0 ] ) {\n\n\t\t\tif ( Math.abs( track.times[ 0 ] - time ) < tolerance ) return 0;\n\n\t\t\ttimes[ 0 ] = time;\n\t\t\ttimes.set( track.times, 1 );\n\n\t\t\tvalues.set( interpolant.evaluate( time ), 0 );\n\t\t\tvalues.set( track.values, valueSize );\n\n\t\t\tindex = 0;\n\n\t\t} else if ( time > track.times[ track.times.length - 1 ] ) {\n\n\t\t\tif ( Math.abs( track.times[ track.times.length - 1 ] - time ) < tolerance ) {\n\n\t\t\t\treturn track.times.length - 1;\n\n\t\t\t}\n\n\t\t\ttimes[ times.length - 1 ] = time;\n\t\t\ttimes.set( track.times, 0 );\n\n\t\t\tvalues.set( track.values, 0 );\n\t\t\tvalues.set( interpolant.evaluate( time ), track.values.length );\n\n\t\t\tindex = times.length - 1;\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0; i < track.times.length; i ++ ) {\n\n\t\t\t\tif ( Math.abs( track.times[ i ] - time ) < tolerance ) return i;\n\n\t\t\t\tif ( track.times[ i ] < time && track.times[ i + 1 ] > time ) {\n\n\t\t\t\t\ttimes.set( track.times.slice( 0, i + 1 ), 0 );\n\t\t\t\t\ttimes[ i + 1 ] = time;\n\t\t\t\t\ttimes.set( track.times.slice( i + 1 ), i + 2 );\n\n\t\t\t\t\tvalues.set( track.values.slice( 0, ( i + 1 ) * valueSize ), 0 );\n\t\t\t\t\tvalues.set( interpolant.evaluate( time ), ( i + 1 ) * valueSize );\n\t\t\t\t\tvalues.set( track.values.slice( ( i + 1 ) * valueSize ), ( i + 2 ) * valueSize );\n\n\t\t\t\t\tindex = i + 1;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\ttrack.times = times;\n\t\ttrack.values = values;\n\n\t\treturn index;\n\n\t},\n\n\tmergeMorphTargetTracks: function ( clip, root ) {\n\n\t\tconst tracks = [];\n\t\tconst mergedTracks = {};\n\t\tconst sourceTracks = clip.tracks;\n\n\t\tfor ( let i = 0; i < sourceTracks.length; ++ i ) {\n\n\t\t\tlet sourceTrack = sourceTracks[ i ];\n\t\t\tconst sourceTrackBinding = PropertyBinding.parseTrackName( sourceTrack.name );\n\t\t\tconst sourceTrackNode = PropertyBinding.findNode( root, sourceTrackBinding.nodeName );\n\n\t\t\tif ( sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined ) {\n\n\t\t\t\t// Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n\t\t\t\ttracks.push( sourceTrack );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete\n\t\t\t\t&& sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear ) {\n\n\t\t\t\tif ( sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\t\t\t// This should never happen, because glTF morph target animations\n\t\t\t\t\t// affect all targets already.\n\t\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.' );\n\n\t\t\t\t}\n\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.' );\n\n\t\t\t\tsourceTrack = sourceTrack.clone();\n\t\t\t\tsourceTrack.setInterpolation( InterpolateLinear );\n\n\t\t\t}\n\n\t\t\tconst targetCount = sourceTrackNode.morphTargetInfluences.length;\n\t\t\tconst targetIndex = sourceTrackNode.morphTargetDictionary[ sourceTrackBinding.propertyIndex ];\n\n\t\t\tif ( targetIndex === undefined ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex );\n\n\t\t\t}\n\n\t\t\tlet mergedTrack;\n\n\t\t\t// If this is the first time we've seen this object, create a new\n\t\t\t// track to store merged keyframe data for each morph target.\n\t\t\tif ( mergedTracks[ sourceTrackNode.uuid ] === undefined ) {\n\n\t\t\t\tmergedTrack = sourceTrack.clone();\n\n\t\t\t\tconst values = new mergedTrack.ValueBufferType( targetCount * mergedTrack.times.length );\n\n\t\t\t\tfor ( let j = 0; j < mergedTrack.times.length; j ++ ) {\n\n\t\t\t\t\tvalues[ j * targetCount + targetIndex ] = mergedTrack.values[ j ];\n\n\t\t\t\t}\n\n\t\t\t\t// We need to take into consideration the intended target node\n\t\t\t\t// of our original un-merged morphTarget animation.\n\t\t\t\tmergedTrack.name = ( sourceTrackBinding.nodeName || '' ) + '.morphTargetInfluences';\n\t\t\t\tmergedTrack.values = values;\n\n\t\t\t\tmergedTracks[ sourceTrackNode.uuid ] = mergedTrack;\n\t\t\t\ttracks.push( mergedTrack );\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst sourceInterpolant = sourceTrack.createInterpolant( new sourceTrack.ValueBufferType( 1 ) );\n\n\t\t\tmergedTrack = mergedTracks[ sourceTrackNode.uuid ];\n\n\t\t\t// For every existing keyframe of the merged track, write a (possibly\n\t\t\t// interpolated) value from the source track.\n\t\t\tfor ( let j = 0; j < mergedTrack.times.length; j ++ ) {\n\n\t\t\t\tmergedTrack.values[ j * targetCount + targetIndex ] = sourceInterpolant.evaluate( mergedTrack.times[ j ] );\n\n\t\t\t}\n\n\t\t\t// For every existing keyframe of the source track, write a (possibly\n\t\t\t// new) keyframe to the merged track. Values from the previous loop may\n\t\t\t// be written again, but keyframes are de-duplicated.\n\t\t\tfor ( let j = 0; j < sourceTrack.times.length; j ++ ) {\n\n\t\t\t\tconst keyframeIndex = this.insertKeyframe( mergedTrack, sourceTrack.times[ j ] );\n\t\t\t\tmergedTrack.values[ keyframeIndex * targetCount + targetIndex ] = sourceTrack.values[ j ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tclip.tracks = tracks;\n\n\t\treturn clip;\n\n\t}\n\n};\n\nexport { GLTFExporter };\n"],"mappings":";;;;AAAA,SACCA,eAAe,EACfC,mBAAmB,EACnBC,UAAU,EACVC,mBAAmB,EACnBC,iBAAiB,EACjBC,cAAc,EACdC,YAAY,EACZC,wBAAwB,EACxBC,yBAAyB,EACzBC,SAAS,EACTC,OAAO,EACPC,sBAAsB,EACtBC,aAAa,EACbC,yBAAyB,EACzBC,0BAA0B,EAC1BC,eAAe,EACfC,UAAU,EACVC,cAAc,EACdC,KAAK,EACLC,MAAM,EACNC,YAAY,EACZC,OAAO,QACD,OAAO;AAAC,IAGTC,YAAY;EAEjB,wBAAc;IAAA;IAEb,IAAI,CAACC,eAAe,GAAG,EAAE;IAEzB,IAAI,CAACC,QAAQ,CAAE,UAAWC,MAAM,EAAG;MAElC,OAAO,IAAIC,kBAAkB,CAAED,MAAM,CAAE;IAExC,CAAC,CAAE;IAEH,IAAI,CAACD,QAAQ,CAAE,UAAWC,MAAM,EAAG;MAElC,OAAO,IAAIE,2BAA2B,CAAEF,MAAM,CAAE;IAEjD,CAAC,CAAE;IAEH,IAAI,CAACD,QAAQ,CAAE,UAAWC,MAAM,EAAG;MAElC,OAAO,IAAIG,kCAAkC,CAAEH,MAAM,CAAE;IAExD,CAAC,CAAE;IAEH,IAAI,CAACD,QAAQ,CAAE,UAAWC,MAAM,EAAG;MAElC,OAAO,IAAII,kCAAkC,CAAEJ,MAAM,CAAE;IAExD,CAAC,CAAE;IAEH,IAAI,CAACD,QAAQ,CAAE,UAAWC,MAAM,EAAG;MAElC,OAAO,IAAIK,4BAA4B,CAAEL,MAAM,CAAE;IAElD,CAAC,CAAE;IAEH,IAAI,CAACD,QAAQ,CAAE,UAAWC,MAAM,EAAG;MAElC,OAAO,IAAIM,+BAA+B,CAAEN,MAAM,CAAE;IAErD,CAAC,CAAE;IAEH,IAAI,CAACD,QAAQ,CAAE,UAAWC,MAAM,EAAG;MAElC,OAAO,IAAIO,iCAAiC,CAAEP,MAAM,CAAE;IAEvD,CAAC,CAAE;EAEJ;EAAC;IAAA;IAAA,OAED,kBAAUQ,QAAQ,EAAG;MAEpB,IAAK,IAAI,CAACV,eAAe,CAACW,OAAO,CAAED,QAAQ,CAAE,KAAK,CAAE,CAAC,EAAG;QAEvD,IAAI,CAACV,eAAe,CAACY,IAAI,CAAEF,QAAQ,CAAE;MAEtC;MAEA,OAAO,IAAI;IAEZ;EAAC;IAAA;IAAA,OAED,oBAAYA,QAAQ,EAAG;MAEtB,IAAK,IAAI,CAACV,eAAe,CAACW,OAAO,CAAED,QAAQ,CAAE,KAAK,CAAE,CAAC,EAAG;QAEvD,IAAI,CAACV,eAAe,CAACa,MAAM,CAAE,IAAI,CAACb,eAAe,CAACW,OAAO,CAAED,QAAQ,CAAE,EAAE,CAAC,CAAE;MAE3E;MAEA,OAAO,IAAI;IAEZ;;IAEA;AACD;AACA;AACA;AACA;AACA;AACA;EANC;IAAA;IAAA,OAOA,eAAOI,KAAK,EAAEC,MAAM,EAAEC,OAAO,EAAEC,OAAO,EAAG;MAExC,IAAK,OAAOD,OAAO,KAAK,QAAQ,EAAG;QAElCE,OAAO,CAACC,IAAI,CAAE,yEAAyE,CAAE;QAEzFF,OAAO,GAAGD,OAAO;MAElB;MAEA,IAAMd,MAAM,GAAG,IAAIkB,UAAU,EAAE;MAC/B,IAAMC,OAAO,GAAG,EAAE;MAElB,KAAM,IAAIC,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAACvB,eAAe,CAACwB,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAG,EAAG;QAEjED,OAAO,CAACT,IAAI,CAAE,IAAI,CAACZ,eAAe,CAAEsB,CAAC,CAAE,CAAEpB,MAAM,CAAE,CAAE;MAEpD;MAEAA,MAAM,CAACuB,UAAU,CAAEJ,OAAO,CAAE;MAC5BnB,MAAM,CAACwB,KAAK,CAAEZ,KAAK,EAAEC,MAAM,EAAEE,OAAO,CAAE,CAACU,KAAK,CAAEX,OAAO,CAAE;IAExD;EAAC;IAAA;IAAA,OAED,oBAAYF,KAAK,EAAEG,OAAO,EAAG;MAE5B,IAAMW,KAAK,GAAG,IAAI;MAElB,OAAO,IAAIC,OAAO,CAAE,UAAWC,OAAO,EAAEC,MAAM,EAAG;QAEhDH,KAAK,CAACI,KAAK,CAAElB,KAAK,EAAEgB,OAAO,EAAEC,MAAM,EAAEd,OAAO,CAAE;MAE/C,CAAC,CAAE;IAEJ;EAAC;EAAA;AAAA,KAIF;AACA;AACA;AAEA,IAAMgB,eAAe,GAAG;EACvBC,MAAM,EAAE,MAAM;EACdC,KAAK,EAAE,MAAM;EACbC,SAAS,EAAE,MAAM;EACjBC,UAAU,EAAE,MAAM;EAClBC,SAAS,EAAE,MAAM;EACjBC,cAAc,EAAE,MAAM;EACtBC,YAAY,EAAE,MAAM;EAEpBC,aAAa,EAAE,MAAM;EACrBC,cAAc,EAAE,MAAM;EACtBC,KAAK,EAAE,MAAM;EACbC,YAAY,EAAE,MAAM;EACpBC,YAAY,EAAE,MAAM;EACpBC,oBAAoB,EAAE,MAAM;EAE5BC,OAAO,EAAE,MAAM;EACfC,MAAM,EAAE,MAAM;EACdC,sBAAsB,EAAE,MAAM;EAC9BC,qBAAqB,EAAE,MAAM;EAC7BC,qBAAqB,EAAE,MAAM;EAC7BC,oBAAoB,EAAE,MAAM;EAE5BC,aAAa,EAAE,KAAK;EACpBC,eAAe,EAAE,KAAK;EACtBC,MAAM,EAAE;AACT,CAAC;AAED,IAAMC,cAAc,GAAG,CAAC,CAAC;AAEzBA,cAAc,CAAEnE,aAAa,CAAE,GAAG4C,eAAe,CAACc,OAAO;AACzDS,cAAc,CAAEjE,0BAA0B,CAAE,GAAG0C,eAAe,CAACgB,sBAAsB;AACrFO,cAAc,CAAElE,yBAAyB,CAAE,GAAG2C,eAAe,CAACkB,qBAAqB;AACnFK,cAAc,CAAEzE,YAAY,CAAE,GAAGkD,eAAe,CAACe,MAAM;AACvDQ,cAAc,CAAEvE,yBAAyB,CAAE,GAAGgD,eAAe,CAACiB,qBAAqB;AACnFM,cAAc,CAAExE,wBAAwB,CAAE,GAAGiD,eAAe,CAACmB,oBAAoB;AAEjFI,cAAc,CAAE9E,mBAAmB,CAAE,GAAGuD,eAAe,CAACoB,aAAa;AACrEG,cAAc,CAAE9D,cAAc,CAAE,GAAGuC,eAAe,CAACsB,MAAM;AACzDC,cAAc,CAAEpE,sBAAsB,CAAE,GAAG6C,eAAe,CAACqB,eAAe;AAE1E,IAAMG,eAAe,GAAG;EACvBC,KAAK,EAAE,OAAO;EACdC,QAAQ,EAAE,aAAa;EACvBC,UAAU,EAAE,UAAU;EACtBC,qBAAqB,EAAE;AACxB,CAAC;;AAED;AACA;;AAEA,IAAMC,gBAAgB,GAAG,EAAE;AAC3B,IAAMC,gBAAgB,GAAG,UAAU;AACnC,IAAMC,WAAW,GAAG,CAAC;AAErB,IAAMC,sBAAsB,GAAG,CAAC;AAChC,IAAMC,mBAAmB,GAAG,UAAU;AACtC,IAAMC,kBAAkB,GAAG,UAAU;;AAErC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,UAAU,CAAEC,MAAM,EAAEC,MAAM,EAAG;EAErC,OAASD,MAAM,CAAC7C,MAAM,KAAK8C,MAAM,CAAC9C,MAAM,IAAM6C,MAAM,CAACE,KAAK,CAAE,UAAWC,OAAO,EAAEC,KAAK,EAAG;IAEvF,OAAOD,OAAO,KAAKF,MAAM,CAAEG,KAAK,CAAE;EAEnC,CAAC,CAAE;AAEJ;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASC,mBAAmB,CAAEC,IAAI,EAAG;EAEpC,OAAO,IAAIC,WAAW,EAAE,CAACC,MAAM,CAAEF,IAAI,CAAE,CAACG,MAAM;AAE/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,gBAAgB,CAAEC,MAAM,EAAG;EAEnC,OAAOZ,UAAU,CAAEY,MAAM,CAACC,QAAQ,EAAE,CAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAE,CAAE;AAEzF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,SAAS,CAAEC,SAAS,EAAEC,KAAK,EAAEC,KAAK,EAAG;EAE7C,IAAMC,MAAM,GAAG;IAEdC,GAAG,EAAE,IAAIC,KAAK,CAAEL,SAAS,CAACM,QAAQ,CAAE,CAACC,IAAI,CAAEC,MAAM,CAACC,iBAAiB,CAAE;IACrEC,GAAG,EAAE,IAAIL,KAAK,CAAEL,SAAS,CAACM,QAAQ,CAAE,CAACC,IAAI,CAAEC,MAAM,CAACG,iBAAiB;EAEpE,CAAC;EAED,KAAM,IAAIxE,CAAC,GAAG8D,KAAK,EAAE9D,CAAC,GAAG8D,KAAK,GAAGC,KAAK,EAAE/D,CAAC,EAAG,EAAG;IAE9C,KAAM,IAAIyE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,SAAS,CAACM,QAAQ,EAAEM,CAAC,EAAG,EAAG;MAE/C,IAAIC,KAAK;MAET,IAAKb,SAAS,CAACM,QAAQ,GAAG,CAAC,EAAG;QAE5B;;QAEDO,KAAK,GAAGb,SAAS,CAACc,KAAK,CAAE3E,CAAC,GAAG6D,SAAS,CAACM,QAAQ,GAAGM,CAAC,CAAE;MAEtD,CAAC,MAAM;QAEN,IAAKA,CAAC,KAAK,CAAC,EAAGC,KAAK,GAAGb,SAAS,CAACe,IAAI,CAAE5E,CAAC,CAAE,CAAC,KACtC,IAAKyE,CAAC,KAAK,CAAC,EAAGC,KAAK,GAAGb,SAAS,CAACgB,IAAI,CAAE7E,CAAC,CAAE,CAAC,KAC3C,IAAKyE,CAAC,KAAK,CAAC,EAAGC,KAAK,GAAGb,SAAS,CAACiB,IAAI,CAAE9E,CAAC,CAAE,CAAC,KAC3C,IAAKyE,CAAC,KAAK,CAAC,EAAGC,KAAK,GAAGb,SAAS,CAACkB,IAAI,CAAE/E,CAAC,CAAE;MAEhD;MAEAgE,MAAM,CAACC,GAAG,CAAEQ,CAAC,CAAE,GAAGO,IAAI,CAACf,GAAG,CAAED,MAAM,CAACC,GAAG,CAAEQ,CAAC,CAAE,EAAEC,KAAK,CAAE;MACpDV,MAAM,CAACO,GAAG,CAAEE,CAAC,CAAE,GAAGO,IAAI,CAACT,GAAG,CAAEP,MAAM,CAACO,GAAG,CAAEE,CAAC,CAAE,EAAEC,KAAK,CAAE;IAErD;EAED;EAEA,OAAOV,MAAM;AAEd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASiB,mBAAmB,CAAEC,UAAU,EAAG;EAE1C,OAAOF,IAAI,CAACG,IAAI,CAAED,UAAU,GAAG,CAAC,CAAE,GAAG,CAAC;AAEvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,oBAAoB,CAAEC,WAAW,EAAoB;EAAA,IAAlBC,WAAW,uEAAG,CAAC;EAE1D,IAAMC,YAAY,GAAGN,mBAAmB,CAAEI,WAAW,CAACG,UAAU,CAAE;EAElE,IAAKD,YAAY,KAAKF,WAAW,CAACG,UAAU,EAAG;IAE9C,IAAMb,KAAK,GAAG,IAAIc,UAAU,CAAEF,YAAY,CAAE;IAC5CZ,KAAK,CAACe,GAAG,CAAE,IAAID,UAAU,CAAEJ,WAAW,CAAE,CAAE;IAE1C,IAAKC,WAAW,KAAK,CAAC,EAAG;MAExB,KAAM,IAAItF,CAAC,GAAGqF,WAAW,CAACG,UAAU,EAAExF,CAAC,GAAGuF,YAAY,EAAEvF,CAAC,EAAG,EAAG;QAE9D2E,KAAK,CAAE3E,CAAC,CAAE,GAAGsF,WAAW;MAEzB;IAED;IAEA,OAAOX,KAAK,CAACnB,MAAM;EAEpB;EAEA,OAAO6B,WAAW;AAEnB;AAEA,SAASM,SAAS,GAAG;EAEpB,IAAK,OAAOC,QAAQ,KAAK,WAAW,IAAI,OAAOC,eAAe,KAAK,WAAW,EAAG;IAEhF,OAAO,IAAIA,eAAe,CAAE,CAAC,EAAE,CAAC,CAAE;EAEnC;EAEA,OAAOD,QAAQ,CAACE,aAAa,CAAE,QAAQ,CAAE;AAE1C;AAEA,SAASC,gBAAgB,CAAEC,MAAM,EAAEC,QAAQ,EAAG;EAE7C,IAAKD,MAAM,CAACE,MAAM,KAAKC,SAAS,EAAG;IAElC,OAAO,IAAI5F,OAAO,CAAE,UAAEC,OAAO;MAAA,OAAMwF,MAAM,CAACE,MAAM,CAAE1F,OAAO,EAAEyF,QAAQ,CAAE;IAAA,EAAE;EAExE;EAEA,IAAIG,OAAO;;EAEX;EACA;EACA,IAAKH,QAAQ,KAAK,YAAY,EAAG;IAEhCG,OAAO,GAAG,IAAI;EAEf,CAAC,MAAM,IAAKH,QAAQ,KAAK,YAAY,EAAG;IAEvCG,OAAO,GAAG,GAAG;EAEd;EAEA,OAAOJ,MAAM,CAACK,aAAa,CAAE;IAE5BC,IAAI,EAAEL,QAAQ;IACdG,OAAO,EAAEA;EAEV,CAAC,CAAE;AAEJ;;AAEA;AACA;AACA;AAFA,IAGMtG,UAAU;EAEf,sBAAc;IAAA;IAEb,IAAI,CAACC,OAAO,GAAG,EAAE;IAEjB,IAAI,CAACJ,OAAO,GAAG,CAAC,CAAC;IACjB,IAAI,CAAC4G,OAAO,GAAG,EAAE;IACjB,IAAI,CAACC,OAAO,GAAG,EAAE;IAEjB,IAAI,CAACC,UAAU,GAAG,CAAC;IACnB,IAAI,CAACD,OAAO,GAAG,EAAE;IACjB,IAAI,CAACE,OAAO,GAAG,IAAIC,GAAG,EAAE;IACxB,IAAI,CAACC,KAAK,GAAG,EAAE;IACf,IAAI,CAACC,cAAc,GAAG,CAAC,CAAC;IAExB,IAAI,CAACC,IAAI,GAAG,IAAIH,GAAG,EAAE;IACrB,IAAI,CAACI,GAAG,GAAG,CAAC;IAEZ,IAAI,CAACC,IAAI,GAAG;MACXC,KAAK,EAAE;QACNC,OAAO,EAAE,KAAK;QACdC,SAAS,EAAE;MACZ;IACD,CAAC;IAED,IAAI,CAACC,KAAK,GAAG;MACZC,MAAM,EAAE,IAAIV,GAAG,EAAE;MACjBW,UAAU,EAAE,IAAIX,GAAG,EAAE;MACrBY,oBAAoB,EAAE,IAAIZ,GAAG,EAAE;MAC/Ba,SAAS,EAAE,IAAIb,GAAG,EAAE;MACpBc,QAAQ,EAAE,IAAId,GAAG,EAAE;MACnBe,MAAM,EAAE,IAAIf,GAAG;IAChB,CAAC;EAEF;EAAC;IAAA;IAAA,OAED,oBAAY5G,OAAO,EAAG;MAErB,IAAI,CAACA,OAAO,GAAGA,OAAO;IAEvB;;IAEA;AACD;AACA;AACA;AACA;AACA;EALC;IAAA;IAAA;MAAA,wEAMA,iBAAaP,KAAK,EAAEC,MAAM,EAAEE,OAAO;QAAA;QAAA;UAAA;YAAA;cAAA;gBAElC,IAAI,CAACA,OAAO,GAAGgI,MAAM,CAACC,MAAM,CAAE,CAAC,CAAC,EAAE;kBACjC;kBACAC,MAAM,EAAE,KAAK;kBACbC,GAAG,EAAE,KAAK;kBACVC,WAAW,EAAE,IAAI;kBACjBC,iBAAiB,EAAE,IAAI;kBACvBC,cAAc,EAAEC,QAAQ;kBACxBC,UAAU,EAAE,EAAE;kBACdC,uBAAuB,EAAE;gBAC1B,CAAC,EAAEzI,OAAO,CAAE;gBAEZ,IAAK,IAAI,CAACA,OAAO,CAACwI,UAAU,CAACjI,MAAM,GAAG,CAAC,EAAG;kBAEzC;kBACA,IAAI,CAACP,OAAO,CAACmI,GAAG,GAAG,IAAI;gBAExB;gBAEA,IAAI,CAACO,YAAY,CAAE7I,KAAK,CAAE;gBAAC;gBAAA,OAErBe,OAAO,CAAC+H,GAAG,CAAE,IAAI,CAAC/B,OAAO,CAAE;cAAA;gBAE3B3H,MAAM,GAAG,IAAI;gBACb4H,OAAO,GAAG5H,MAAM,CAAC4H,OAAO;gBACxBQ,IAAI,GAAGpI,MAAM,CAACoI,IAAI;gBACxBrH,OAAO,GAAGf,MAAM,CAACe,OAAO;gBAClBkH,cAAc,GAAGjI,MAAM,CAACiI,cAAc,EAE5C;gBACM0B,IAAI,GAAG,IAAIC,IAAI,CAAEhC,OAAO,EAAE;kBAAEF,IAAI,EAAE;gBAA2B,CAAC,CAAE,EAEtE;gBACMmC,kBAAkB,GAAGd,MAAM,CAACe,IAAI,CAAE7B,cAAc,CAAE;gBAExD,IAAK4B,kBAAkB,CAACvI,MAAM,GAAG,CAAC,EAAG8G,IAAI,CAACH,cAAc,GAAG4B,kBAAkB;;gBAE7E;gBACA,IAAKzB,IAAI,CAACR,OAAO,IAAIQ,IAAI,CAACR,OAAO,CAACtG,MAAM,GAAG,CAAC,EAAG8G,IAAI,CAACR,OAAO,CAAE,CAAC,CAAE,CAAChB,UAAU,GAAG+C,IAAI,CAACI,IAAI;gBAEvF,IAAKhJ,OAAO,CAACkI,MAAM,KAAK,IAAI,EAAG;kBAE9B;kBAEMe,MAAM,GAAG,IAAIC,UAAU,EAAE;kBAC/BD,MAAM,CAACE,iBAAiB,CAAEP,IAAI,CAAE;kBAChCK,MAAM,CAACG,SAAS,GAAG,YAAY;oBAE9B;oBACA,IAAMC,WAAW,GAAG5D,oBAAoB,CAAEwD,MAAM,CAACK,MAAM,CAAE;oBACzD,IAAMC,iBAAiB,GAAG,IAAIC,QAAQ,CAAE,IAAIC,WAAW,CAAEzG,sBAAsB,CAAE,CAAE;oBACnFuG,iBAAiB,CAACG,SAAS,CAAE,CAAC,EAAEL,WAAW,CAACxD,UAAU,EAAE,IAAI,CAAE;oBAC9D0D,iBAAiB,CAACG,SAAS,CAAE,CAAC,EAAExG,kBAAkB,EAAE,IAAI,CAAE;;oBAE1D;oBACA,IAAMyG,SAAS,GAAGlE,oBAAoB,CAAEhC,mBAAmB,CAAEmG,IAAI,CAACC,SAAS,CAAExC,IAAI,CAAE,CAAE,EAAE,IAAI,CAAE;oBAC7F,IAAMyC,eAAe,GAAG,IAAIN,QAAQ,CAAE,IAAIC,WAAW,CAAEzG,sBAAsB,CAAE,CAAE;oBACjF8G,eAAe,CAACJ,SAAS,CAAE,CAAC,EAAEC,SAAS,CAAC9D,UAAU,EAAE,IAAI,CAAE;oBAC1DiE,eAAe,CAACJ,SAAS,CAAE,CAAC,EAAEzG,mBAAmB,EAAE,IAAI,CAAE;;oBAEzD;oBACA,IAAM8G,MAAM,GAAG,IAAIN,WAAW,CAAE5G,gBAAgB,CAAE;oBAClD,IAAMmH,UAAU,GAAG,IAAIR,QAAQ,CAAEO,MAAM,CAAE;oBACzCC,UAAU,CAACN,SAAS,CAAE,CAAC,EAAE5G,gBAAgB,EAAE,IAAI,CAAE;oBACjDkH,UAAU,CAACN,SAAS,CAAE,CAAC,EAAE3G,WAAW,EAAE,IAAI,CAAE;oBAC5C,IAAMkH,eAAe,GAAGpH,gBAAgB,GACrCiH,eAAe,CAACjE,UAAU,GAAG8D,SAAS,CAAC9D,UAAU,GACjD0D,iBAAiB,CAAC1D,UAAU,GAAGwD,WAAW,CAACxD,UAAU;oBACxDmE,UAAU,CAACN,SAAS,CAAE,CAAC,EAAEO,eAAe,EAAE,IAAI,CAAE;oBAEhD,IAAMC,OAAO,GAAG,IAAIrB,IAAI,CAAE,CACzBkB,MAAM,EACND,eAAe,EACfH,SAAS,EACTJ,iBAAiB,EACjBF,WAAW,CACX,EAAE;sBAAE1C,IAAI,EAAE;oBAA2B,CAAC,CAAE;oBAEzC,IAAMwD,SAAS,GAAG,IAAIjB,UAAU,EAAE;oBAClCiB,SAAS,CAAChB,iBAAiB,CAAEe,OAAO,CAAE;oBACtCC,SAAS,CAACf,SAAS,GAAG,YAAY;sBAEjCtJ,MAAM,CAAEqK,SAAS,CAACb,MAAM,CAAE;oBAE3B,CAAC;kBAEF,CAAC;gBAEF,CAAC,MAAM;kBAEN,IAAKjC,IAAI,CAACR,OAAO,IAAIQ,IAAI,CAACR,OAAO,CAACtG,MAAM,GAAG,CAAC,EAAG;oBAExC0I,OAAM,GAAG,IAAIC,UAAU,EAAE;oBAC/BD,OAAM,CAACmB,aAAa,CAAExB,IAAI,CAAE;oBAC5BK,OAAM,CAACG,SAAS,GAAG,YAAY;sBAE9B,IAAMiB,UAAU,GAAGpB,OAAM,CAACK,MAAM;sBAChCjC,IAAI,CAACR,OAAO,CAAE,CAAC,CAAE,CAACyD,GAAG,GAAGD,UAAU;sBAClCvK,MAAM,CAAEuH,IAAI,CAAE;oBAEf,CAAC;kBAEF,CAAC,MAAM;oBAENvH,MAAM,CAAEuH,IAAI,CAAE;kBAEf;gBAED;cAAC;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAGD;MAAA;QAAA;MAAA;MAAA;IAAA;IAED;AACD;AACA;AACA;AACA;AACA;EALC;IAAA;IAAA,OAMA,2BAAmBkD,MAAM,EAAEC,SAAS,EAAG;MAEtC,IAAKxC,MAAM,CAACe,IAAI,CAAEwB,MAAM,CAACE,QAAQ,CAAE,CAAClK,MAAM,KAAK,CAAC,EAAG;MAEnD,IAAMP,OAAO,GAAG,IAAI,CAACA,OAAO;MAC5B,IAAMkH,cAAc,GAAG,IAAI,CAACA,cAAc;MAE1C,IAAI;QAEH,IAAMG,IAAI,GAAGuC,IAAI,CAAC7I,KAAK,CAAE6I,IAAI,CAACC,SAAS,CAAEU,MAAM,CAACE,QAAQ,CAAE,CAAE;QAE5D,IAAKzK,OAAO,CAACyI,uBAAuB,IAAIpB,IAAI,CAACqD,cAAc,EAAG;UAE7D,IAAKF,SAAS,CAACG,UAAU,KAAKnE,SAAS,EAAGgE,SAAS,CAACG,UAAU,GAAG,CAAC,CAAC;UAEnE,KAAM,IAAMC,aAAa,IAAIvD,IAAI,CAACqD,cAAc,EAAG;YAElDF,SAAS,CAACG,UAAU,CAAEC,aAAa,CAAE,GAAGvD,IAAI,CAACqD,cAAc,CAAEE,aAAa,CAAE;YAC5E1D,cAAc,CAAE0D,aAAa,CAAE,GAAG,IAAI;UAEvC;UAEA,OAAOvD,IAAI,CAACqD,cAAc;QAE3B;QAEA,IAAK1C,MAAM,CAACe,IAAI,CAAE1B,IAAI,CAAE,CAAC9G,MAAM,GAAG,CAAC,EAAGiK,SAAS,CAACK,MAAM,GAAGxD,IAAI;MAE9D,CAAC,CAAC,OAAQyD,KAAK,EAAG;QAEjB7K,OAAO,CAACC,IAAI,CAAE,oCAAoC,GAAGqK,MAAM,CAACQ,IAAI,GAAG,KAAK,GACvE,yDAAyD,GAAGD,KAAK,CAACE,OAAO,CAAE;MAE7E;IAED;;IAEA;AACD;AACA;AACA;AACA;EAJC;IAAA;IAAA,OAKA,gBAAQ9G,SAAS,EAA2B;MAAA,IAAzB+G,cAAc,uEAAG,KAAK;MAExC,IAAK,IAAI,CAAC9D,IAAI,CAAC+D,GAAG,CAAEhH,SAAS,CAAE,KAAK,KAAK,EAAG;QAE3C,IAAMiD,KAAI,GAAG,IAAIH,GAAG,EAAE;QAEtBG,KAAI,CAACpB,GAAG,CAAE,IAAI,EAAE,IAAI,CAACqB,GAAG,EAAG,CAAE;QAC7BD,KAAI,CAACpB,GAAG,CAAE,KAAK,EAAE,IAAI,CAACqB,GAAG,EAAG,CAAE;QAE9B,IAAI,CAACD,IAAI,CAACpB,GAAG,CAAE7B,SAAS,EAAEiD,KAAI,CAAE;MAEjC;MAEA,IAAMA,IAAI,GAAG,IAAI,CAACA,IAAI,CAACgE,GAAG,CAAEjH,SAAS,CAAE;MAEvC,OAAOiD,IAAI,CAACgE,GAAG,CAAEF,cAAc,CAAE;IAElC;;IAEA;AACD;AACA;AACA;AACA;AACA;EALC;IAAA;IAAA,OAMA,qCAA6BG,MAAM,EAAG;MAErC,IAAM3D,KAAK,GAAG,IAAI,CAACA,KAAK;MAExB,IAAKA,KAAK,CAACG,oBAAoB,CAACsD,GAAG,CAAEE,MAAM,CAAE,EAAG,OAAO,KAAK;MAE5D,IAAMC,CAAC,GAAG,IAAIxM,OAAO,EAAE;MAEvB,KAAM,IAAIwB,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG8K,MAAM,CAAChH,KAAK,EAAE/D,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAG,EAAG;QAElD;QACA,IAAKgF,IAAI,CAACiG,GAAG,CAAED,CAAC,CAACE,mBAAmB,CAAEH,MAAM,EAAE/K,CAAC,CAAE,CAACE,MAAM,EAAE,GAAG,GAAG,CAAE,GAAG,MAAM,EAAG,OAAO,KAAK;MAE3F;MAEA,OAAO,IAAI;IAEZ;;IAEA;AACD;AACA;AACA;AACA;AACA;AACA;EANC;IAAA;IAAA,OAOA,yCAAiC6K,MAAM,EAAG;MAEzC,IAAM3D,KAAK,GAAG,IAAI,CAACA,KAAK;MAExB,IAAKA,KAAK,CAACG,oBAAoB,CAACsD,GAAG,CAAEE,MAAM,CAAE,EAAG,OAAO3D,KAAK,CAACG,oBAAoB,CAACuD,GAAG,CAAEC,MAAM,CAAE;MAE/F,IAAMlH,SAAS,GAAGkH,MAAM,CAACI,KAAK,EAAE;MAChC,IAAMH,CAAC,GAAG,IAAIxM,OAAO,EAAE;MAEvB,KAAM,IAAIwB,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG4D,SAAS,CAACE,KAAK,EAAE/D,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAG,EAAG;QAErDgL,CAAC,CAACE,mBAAmB,CAAErH,SAAS,EAAE7D,CAAC,CAAE;QAErC,IAAKgL,CAAC,CAACI,CAAC,KAAK,CAAC,IAAIJ,CAAC,CAACK,CAAC,KAAK,CAAC,IAAIL,CAAC,CAACM,CAAC,KAAK,CAAC,EAAG;UAE1C;UACAN,CAAC,CAACO,IAAI,CAAE,GAAG,CAAE;QAEd,CAAC,MAAM;UAENP,CAAC,CAACQ,SAAS,EAAE;QAEd;QAEA3H,SAAS,CAAC4H,MAAM,CAAEzL,CAAC,EAAEgL,CAAC,CAACI,CAAC,EAAEJ,CAAC,CAACK,CAAC,EAAEL,CAAC,CAACM,CAAC,CAAE;MAErC;MAEAlE,KAAK,CAACG,oBAAoB,CAAC7B,GAAG,CAAEqF,MAAM,EAAElH,SAAS,CAAE;MAEnD,OAAOA,SAAS;IAEjB;;IAEA;AACD;AACA;AACA;AACA;AACA;AACA;EANC;IAAA;IAAA,OAOA,+BAAuB6H,MAAM,EAAEC,OAAO,EAAG;MAExC,IAAIC,YAAY,GAAG,KAAK;MACxB,IAAMC,YAAY,GAAG,CAAC,CAAC;MAEvB,IAAKF,OAAO,CAACG,MAAM,CAACV,CAAC,KAAK,CAAC,IAAIO,OAAO,CAACG,MAAM,CAACT,CAAC,KAAK,CAAC,EAAG;QAEvDQ,YAAY,CAACC,MAAM,GAAGH,OAAO,CAACG,MAAM,CAACC,OAAO,EAAE;QAC9CH,YAAY,GAAG,IAAI;MAEpB;MAEA,IAAKD,OAAO,CAACK,QAAQ,KAAK,CAAC,EAAG;QAE7BH,YAAY,CAACG,QAAQ,GAAGL,OAAO,CAACK,QAAQ;QACxCJ,YAAY,GAAG,IAAI;MAEpB;MAEA,IAAKD,OAAO,CAACM,MAAM,CAACb,CAAC,KAAK,CAAC,IAAIO,OAAO,CAACM,MAAM,CAACZ,CAAC,KAAK,CAAC,EAAG;QAEvDQ,YAAY,CAACzJ,KAAK,GAAGuJ,OAAO,CAACM,MAAM,CAACF,OAAO,EAAE;QAC7CH,YAAY,GAAG,IAAI;MAEpB;MAEA,IAAKA,YAAY,EAAG;QAEnBF,MAAM,CAACpB,UAAU,GAAGoB,MAAM,CAACpB,UAAU,IAAI,CAAC,CAAC;QAC3CoB,MAAM,CAACpB,UAAU,CAAE,uBAAuB,CAAE,GAAGuB,YAAY;QAC3D,IAAI,CAAChF,cAAc,CAAE,uBAAuB,CAAE,GAAG,IAAI;MAEtD;IAED;EAAC;IAAA;IAAA,OAED,gCAAwBqF,YAAY,EAAEC,YAAY,EAAG;MAEpD,IAAKD,YAAY,KAAKC,YAAY,EAAG,OAAOD,YAAY;MAExD,SAASE,qBAAqB,CAAEC,GAAG,EAAG;QAErC,IAAKA,GAAG,CAACC,QAAQ,KAAK/N,YAAY,EAAG;UAEpC,OAAO,SAASgO,YAAY,CAAEC,CAAC,EAAG;YAEjC,OAASA,CAAC,GAAG,OAAO,GAAKA,CAAC,GAAG,YAAY,GAAGxH,IAAI,CAACyH,GAAG,CAAED,CAAC,GAAG,YAAY,GAAG,YAAY,EAAE,GAAG,CAAE;UAE7F,CAAC;QAEF;QAEA,OAAO,SAASE,cAAc,CAAEF,CAAC,EAAG;UAEnC,OAAOA,CAAC;QAET,CAAC;MAEF;MAEA5M,OAAO,CAACC,IAAI,CAAE,oEAAoE,CAAE;MAEpF,IAAM8M,SAAS,GAAGT,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAEU,KAAK;MACrC,IAAMC,SAAS,GAAGV,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAES,KAAK;MAErC,IAAME,KAAK,GAAG9H,IAAI,CAACT,GAAG,CAAE,CAAAoI,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEG,KAAK,KAAI,CAAC,EAAE,CAAAD,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEC,KAAK,KAAI,CAAC,CAAE;MACtE,IAAMC,MAAM,GAAG/H,IAAI,CAACT,GAAG,CAAE,CAAAoI,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEI,MAAM,KAAI,CAAC,EAAE,CAAAF,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEE,MAAM,KAAI,CAAC,CAAE;MAEzE,IAAM/G,MAAM,GAAGL,SAAS,EAAE;MAC1BK,MAAM,CAAC8G,KAAK,GAAGA,KAAK;MACpB9G,MAAM,CAAC+G,MAAM,GAAGA,MAAM;MAEtB,IAAMC,OAAO,GAAGhH,MAAM,CAACiH,UAAU,CAAE,IAAI,CAAE;MACzCD,OAAO,CAACE,SAAS,GAAG,SAAS;MAC7BF,OAAO,CAACG,QAAQ,CAAE,CAAC,EAAE,CAAC,EAAEL,KAAK,EAAEC,MAAM,CAAE;MAEvC,IAAMK,SAAS,GAAGJ,OAAO,CAACK,YAAY,CAAE,CAAC,EAAE,CAAC,EAAEP,KAAK,EAAEC,MAAM,CAAE;MAE7D,IAAKJ,SAAS,EAAG;QAEhBK,OAAO,CAACM,SAAS,CAAEX,SAAS,EAAE,CAAC,EAAE,CAAC,EAAEG,KAAK,EAAEC,MAAM,CAAE;QAEnD,IAAMQ,OAAO,GAAGnB,qBAAqB,CAAEF,YAAY,CAAE;QACrD,IAAMsB,IAAI,GAAGR,OAAO,CAACK,YAAY,CAAE,CAAC,EAAE,CAAC,EAAEP,KAAK,EAAEC,MAAM,CAAE,CAACS,IAAI;QAE7D,KAAM,IAAIxN,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwN,IAAI,CAACtN,MAAM,EAAEF,CAAC,IAAI,CAAC,EAAG;UAE1CoN,SAAS,CAACI,IAAI,CAAExN,CAAC,CAAE,GAAGuN,OAAO,CAAEC,IAAI,CAAExN,CAAC,CAAE,GAAG,GAAG,CAAE,GAAG,GAAG;QAEvD;MAED;MAEA,IAAK6M,SAAS,EAAG;QAEhBG,OAAO,CAACM,SAAS,CAAET,SAAS,EAAE,CAAC,EAAE,CAAC,EAAEC,KAAK,EAAEC,MAAM,CAAE;QAEnD,IAAMQ,QAAO,GAAGnB,qBAAqB,CAAED,YAAY,CAAE;QACrD,IAAMqB,KAAI,GAAGR,OAAO,CAACK,YAAY,CAAE,CAAC,EAAE,CAAC,EAAEP,KAAK,EAAEC,MAAM,CAAE,CAACS,IAAI;QAE7D,KAAM,IAAIxN,EAAC,GAAG,CAAC,EAAEA,EAAC,GAAGwN,KAAI,CAACtN,MAAM,EAAEF,EAAC,IAAI,CAAC,EAAG;UAE1CoN,SAAS,CAACI,IAAI,CAAExN,EAAC,CAAE,GAAGuN,QAAO,CAAEC,KAAI,CAAExN,EAAC,CAAE,GAAG,GAAG,CAAE,GAAG,GAAG;QAEvD;MAED;MAEAgN,OAAO,CAACS,YAAY,CAAEL,SAAS,EAAE,CAAC,EAAE,CAAC,CAAE;;MAEvC;;MAEA,IAAMM,SAAS,GAAGxB,YAAY,IAAIC,YAAY;MAE9C,IAAMR,OAAO,GAAG+B,SAAS,CAACvC,KAAK,EAAE;MAEjCQ,OAAO,CAACgC,MAAM,GAAG,IAAIrP,MAAM,CAAE0H,MAAM,CAAE;MACrC2F,OAAO,CAACW,QAAQ,GAAG9O,cAAc;MAEjC,OAAOmO,OAAO;IAEf;;IAEA;AACD;AACA;AACA;AACA;EAJC;IAAA;IAAA,OAKA,uBAAenI,MAAM,EAAG;MAEvB,IAAMwD,IAAI,GAAG,IAAI,CAACA,IAAI;MACtB,IAAMR,OAAO,GAAG,IAAI,CAACA,OAAO;MAE5B,IAAK,CAAEQ,IAAI,CAACR,OAAO,EAAGQ,IAAI,CAACR,OAAO,GAAG,CAAE;QAAEhB,UAAU,EAAE;MAAE,CAAC,CAAE;;MAE1D;MACAgB,OAAO,CAAClH,IAAI,CAAEkE,MAAM,CAAE;MAEtB,OAAO,CAAC;IAET;;IAEA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EARC;IAAA;IAAA,OASA,2BAAmBK,SAAS,EAAE+J,aAAa,EAAE9J,KAAK,EAAEC,KAAK,EAAE8J,MAAM,EAAG;MAEnE,IAAM7G,IAAI,GAAG,IAAI,CAACA,IAAI;MAEtB,IAAK,CAAEA,IAAI,CAAC8G,WAAW,EAAG9G,IAAI,CAAC8G,WAAW,GAAG,EAAE;;MAE/C;;MAEA,IAAIC,aAAa;MAEjB,IAAKH,aAAa,KAAKjN,eAAe,CAACQ,aAAa,EAAG;QAEtD4M,aAAa,GAAG,CAAC;MAElB,CAAC,MAAM,IAAKH,aAAa,KAAKjN,eAAe,CAACS,cAAc,EAAG;QAE9D2M,aAAa,GAAG,CAAC;MAElB,CAAC,MAAM;QAENA,aAAa,GAAG,CAAC;MAElB;MAEA,IAAMvI,UAAU,GAAGP,mBAAmB,CAAElB,KAAK,GAAGF,SAAS,CAACM,QAAQ,GAAG4J,aAAa,CAAE;MACpF,IAAMC,QAAQ,GAAG,IAAI7E,QAAQ,CAAE,IAAIC,WAAW,CAAE5D,UAAU,CAAE,CAAE;MAC9D,IAAIsG,MAAM,GAAG,CAAC;MAEd,KAAM,IAAI9L,CAAC,GAAG8D,KAAK,EAAE9D,CAAC,GAAG8D,KAAK,GAAGC,KAAK,EAAE/D,CAAC,EAAG,EAAG;QAE9C,KAAM,IAAIyE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,SAAS,CAACM,QAAQ,EAAEM,CAAC,EAAG,EAAG;UAE/C,IAAIC,KAAK;UAET,IAAKb,SAAS,CAACM,QAAQ,GAAG,CAAC,EAAG;YAE5B;;YAEDO,KAAK,GAAGb,SAAS,CAACc,KAAK,CAAE3E,CAAC,GAAG6D,SAAS,CAACM,QAAQ,GAAGM,CAAC,CAAE;UAEtD,CAAC,MAAM;YAEN,IAAKA,CAAC,KAAK,CAAC,EAAGC,KAAK,GAAGb,SAAS,CAACe,IAAI,CAAE5E,CAAC,CAAE,CAAC,KACtC,IAAKyE,CAAC,KAAK,CAAC,EAAGC,KAAK,GAAGb,SAAS,CAACgB,IAAI,CAAE7E,CAAC,CAAE,CAAC,KAC3C,IAAKyE,CAAC,KAAK,CAAC,EAAGC,KAAK,GAAGb,SAAS,CAACiB,IAAI,CAAE9E,CAAC,CAAE,CAAC,KAC3C,IAAKyE,CAAC,KAAK,CAAC,EAAGC,KAAK,GAAGb,SAAS,CAACkB,IAAI,CAAE/E,CAAC,CAAE;UAEhD;UAEA,IAAK4N,aAAa,KAAKjN,eAAe,CAACU,KAAK,EAAG;YAE9C2M,QAAQ,CAACC,UAAU,CAAEnC,MAAM,EAAEpH,KAAK,EAAE,IAAI,CAAE;UAE3C,CAAC,MAAM,IAAKkJ,aAAa,KAAKjN,eAAe,CAACW,YAAY,EAAG;YAE5D0M,QAAQ,CAAC3E,SAAS,CAAEyC,MAAM,EAAEpH,KAAK,EAAE,IAAI,CAAE;UAE1C,CAAC,MAAM,IAAKkJ,aAAa,KAAKjN,eAAe,CAACS,cAAc,EAAG;YAE9D4M,QAAQ,CAACE,SAAS,CAAEpC,MAAM,EAAEpH,KAAK,EAAE,IAAI,CAAE;UAE1C,CAAC,MAAM,IAAKkJ,aAAa,KAAKjN,eAAe,CAACQ,aAAa,EAAG;YAE7D6M,QAAQ,CAACG,QAAQ,CAAErC,MAAM,EAAEpH,KAAK,CAAE;UAEnC;UAEAoH,MAAM,IAAIiC,aAAa;QAExB;MAED;MAEA,IAAMK,aAAa,GAAG;QAErB5K,MAAM,EAAE,IAAI,CAAC6K,aAAa,CAAEL,QAAQ,CAACxK,MAAM,CAAE;QAC7CiD,UAAU,EAAE,IAAI,CAACA,UAAU;QAC3BjB,UAAU,EAAEA;MAEb,CAAC;MAED,IAAKqI,MAAM,KAAK1H,SAAS,EAAGiI,aAAa,CAACP,MAAM,GAAGA,MAAM;MAEzD,IAAKA,MAAM,KAAKlN,eAAe,CAACY,YAAY,EAAG;QAE9C;QACA6M,aAAa,CAACE,UAAU,GAAGzK,SAAS,CAACM,QAAQ,GAAG4J,aAAa;MAE9D;MAEA,IAAI,CAACtH,UAAU,IAAIjB,UAAU;MAE7BwB,IAAI,CAAC8G,WAAW,CAACxO,IAAI,CAAE8O,aAAa,CAAE;;MAEtC;MACA,IAAMpK,MAAM,GAAG;QAEduK,EAAE,EAAEvH,IAAI,CAAC8G,WAAW,CAAC5N,MAAM,GAAG,CAAC;QAC/BsF,UAAU,EAAE;MAEb,CAAC;MAED,OAAOxB,MAAM;IAEd;;IAEA;AACD;AACA;AACA;AACA;EAJC;IAAA;IAAA,OAKA,gCAAwBuE,IAAI,EAAG;MAE9B,IAAM3J,MAAM,GAAG,IAAI;MACnB,IAAMoI,IAAI,GAAGpI,MAAM,CAACoI,IAAI;MAExB,IAAK,CAAEA,IAAI,CAAC8G,WAAW,EAAG9G,IAAI,CAAC8G,WAAW,GAAG,EAAE;MAE/C,OAAO,IAAIvN,OAAO,CAAE,UAAWC,OAAO,EAAG;QAExC,IAAMoI,MAAM,GAAG,IAAIC,UAAU,EAAE;QAC/BD,MAAM,CAACE,iBAAiB,CAAEP,IAAI,CAAE;QAChCK,MAAM,CAACG,SAAS,GAAG,YAAY;UAE9B,IAAMvF,MAAM,GAAG4B,oBAAoB,CAAEwD,MAAM,CAACK,MAAM,CAAE;UAEpD,IAAMmF,aAAa,GAAG;YACrB5K,MAAM,EAAE5E,MAAM,CAACyP,aAAa,CAAE7K,MAAM,CAAE;YACtCiD,UAAU,EAAE7H,MAAM,CAAC6H,UAAU;YAC7BjB,UAAU,EAAEhC,MAAM,CAACgC;UACpB,CAAC;UAED5G,MAAM,CAAC6H,UAAU,IAAIjD,MAAM,CAACgC,UAAU;UACtChF,OAAO,CAAEwG,IAAI,CAAC8G,WAAW,CAACxO,IAAI,CAAE8O,aAAa,CAAE,GAAG,CAAC,CAAE;QAEtD,CAAC;MAEF,CAAC,CAAE;IAEJ;;IAEA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;EAPC;IAAA;IAAA,OAQA,yBAAiBvK,SAAS,EAAE2K,QAAQ,EAAE1K,KAAK,EAAEC,KAAK,EAAG;MAEpD,IAAMpE,OAAO,GAAG,IAAI,CAACA,OAAO;MAC5B,IAAMqH,IAAI,GAAG,IAAI,CAACA,IAAI;MAEtB,IAAMyH,KAAK,GAAG;QAEb,CAAC,EAAE,QAAQ;QACX,CAAC,EAAE,MAAM;QACT,CAAC,EAAE,MAAM;QACT,CAAC,EAAE,MAAM;QACT,EAAE,EAAE;MAEL,CAAC;MAED,IAAIb,aAAa;;MAEjB;MACA,IAAK/J,SAAS,CAACc,KAAK,CAAC+J,WAAW,KAAKC,YAAY,EAAG;QAEnDf,aAAa,GAAGjN,eAAe,CAACU,KAAK;MAEtC,CAAC,MAAM,IAAKwC,SAAS,CAACc,KAAK,CAAC+J,WAAW,KAAKE,WAAW,EAAG;QAEzDhB,aAAa,GAAGjN,eAAe,CAACW,YAAY;MAE7C,CAAC,MAAM,IAAKuC,SAAS,CAACc,KAAK,CAAC+J,WAAW,KAAKG,WAAW,EAAG;QAEzDjB,aAAa,GAAGjN,eAAe,CAACS,cAAc;MAE/C,CAAC,MAAM,IAAKyC,SAAS,CAACc,KAAK,CAAC+J,WAAW,KAAKjJ,UAAU,EAAG;QAExDmI,aAAa,GAAGjN,eAAe,CAACQ,aAAa;MAE9C,CAAC,MAAM;QAEN,MAAM,IAAI2N,KAAK,CAAE,iEAAiE,CAAE;MAErF;MAEA,IAAKhL,KAAK,KAAKqC,SAAS,EAAGrC,KAAK,GAAG,CAAC;MACpC,IAAKC,KAAK,KAAKoC,SAAS,EAAGpC,KAAK,GAAGF,SAAS,CAACE,KAAK;;MAElD;MACA,IAAKpE,OAAO,CAACqI,iBAAiB,IAAIwG,QAAQ,KAAKrI,SAAS,IAAIqI,QAAQ,CAACrL,KAAK,KAAK,IAAI,EAAG;QAErF,IAAM4L,GAAG,GAAGjL,KAAK,GAAGC,KAAK;QACzB,IAAMiL,IAAI,GAAGR,QAAQ,CAACS,SAAS,CAAClL,KAAK,KAAKmE,QAAQ,GAC/CrE,SAAS,CAACE,KAAK,GACfyK,QAAQ,CAACS,SAAS,CAACnL,KAAK,GAAG0K,QAAQ,CAACS,SAAS,CAAClL,KAAK;QAEtDD,KAAK,GAAGkB,IAAI,CAACT,GAAG,CAAET,KAAK,EAAE0K,QAAQ,CAACS,SAAS,CAACnL,KAAK,CAAE;QACnDC,KAAK,GAAGiB,IAAI,CAACf,GAAG,CAAE8K,GAAG,EAAEC,IAAI,CAAE,GAAGlL,KAAK;QAErC,IAAKC,KAAK,GAAG,CAAC,EAAGA,KAAK,GAAG,CAAC;MAE3B;;MAEA;MACA,IAAKA,KAAK,KAAK,CAAC,EAAG,OAAO,IAAI;MAE9B,IAAMmL,MAAM,GAAGtL,SAAS,CAAEC,SAAS,EAAEC,KAAK,EAAEC,KAAK,CAAE;MACnD,IAAIoL,gBAAgB;;MAEpB;MACA;MACA,IAAKX,QAAQ,KAAKrI,SAAS,EAAG;QAE7BgJ,gBAAgB,GAAGtL,SAAS,KAAK2K,QAAQ,CAACrL,KAAK,GAAGxC,eAAe,CAACa,oBAAoB,GAAGb,eAAe,CAACY,YAAY;MAEtH;MAEA,IAAM6N,UAAU,GAAG,IAAI,CAACC,iBAAiB,CAAExL,SAAS,EAAE+J,aAAa,EAAE9J,KAAK,EAAEC,KAAK,EAAEoL,gBAAgB,CAAE;MAErG,IAAMG,WAAW,GAAG;QAEnBF,UAAU,EAAEA,UAAU,CAACb,EAAE;QACzB9H,UAAU,EAAE2I,UAAU,CAAC3I,UAAU;QACjCmH,aAAa,EAAEA,aAAa;QAC5B7J,KAAK,EAAEA,KAAK;QACZQ,GAAG,EAAE2K,MAAM,CAAC3K,GAAG;QACfN,GAAG,EAAEiL,MAAM,CAACjL,GAAG;QACfqC,IAAI,EAAEmI,KAAK,CAAE5K,SAAS,CAACM,QAAQ;MAEhC,CAAC;MAED,IAAKN,SAAS,CAAC0L,UAAU,KAAK,IAAI,EAAGD,WAAW,CAACC,UAAU,GAAG,IAAI;MAClE,IAAK,CAAEvI,IAAI,CAACwI,SAAS,EAAGxI,IAAI,CAACwI,SAAS,GAAG,EAAE;MAE3C,OAAOxI,IAAI,CAACwI,SAAS,CAAClQ,IAAI,CAAEgQ,WAAW,CAAE,GAAG,CAAC;IAE9C;;IAEA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;EAPC;IAAA;IAAA,OAQA,sBAAc1C,KAAK,EAAE6C,MAAM,EAAEC,KAAK,EAA2B;MAAA,IAAzBzJ,QAAQ,uEAAG,WAAW;MAEzD,IAAMrH,MAAM,GAAG,IAAI;MACnB,IAAMwI,KAAK,GAAGxI,MAAM,CAACwI,KAAK;MAC1B,IAAMJ,IAAI,GAAGpI,MAAM,CAACoI,IAAI;MACxB,IAAMrH,OAAO,GAAGf,MAAM,CAACe,OAAO;MAC9B,IAAM4G,OAAO,GAAG3H,MAAM,CAAC2H,OAAO;MAE9B,IAAK,CAAEa,KAAK,CAACM,MAAM,CAACmD,GAAG,CAAE+B,KAAK,CAAE,EAAGxF,KAAK,CAACM,MAAM,CAAChC,GAAG,CAAEkH,KAAK,EAAE,CAAC,CAAC,CAAE;MAEhE,IAAM+C,YAAY,GAAGvI,KAAK,CAACM,MAAM,CAACoD,GAAG,CAAE8B,KAAK,CAAE;MAE9C,IAAMgD,GAAG,GAAG3J,QAAQ,GAAG,SAAS,GAAGyJ,KAAK,CAACG,QAAQ,EAAE;MAEnD,IAAKF,YAAY,CAAEC,GAAG,CAAE,KAAKzJ,SAAS,EAAG,OAAOwJ,YAAY,CAAEC,GAAG,CAAE;MAEnE,IAAK,CAAE5I,IAAI,CAACU,MAAM,EAAGV,IAAI,CAACU,MAAM,GAAG,EAAE;MAErC,IAAMoI,QAAQ,GAAG;QAAE7J,QAAQ,EAAEA;MAAS,CAAC;MAEvC,IAAMD,MAAM,GAAGL,SAAS,EAAE;MAE1BK,MAAM,CAAC8G,KAAK,GAAG9H,IAAI,CAACf,GAAG,CAAE2I,KAAK,CAACE,KAAK,EAAEnN,OAAO,CAACsI,cAAc,CAAE;MAC9DjC,MAAM,CAAC+G,MAAM,GAAG/H,IAAI,CAACf,GAAG,CAAE2I,KAAK,CAACG,MAAM,EAAEpN,OAAO,CAACsI,cAAc,CAAE;MAEhE,IAAM8H,GAAG,GAAG/J,MAAM,CAACiH,UAAU,CAAE,IAAI,CAAE;MAErC,IAAKyC,KAAK,KAAK,IAAI,EAAG;QAErBK,GAAG,CAACC,SAAS,CAAE,CAAC,EAAEhK,MAAM,CAAC+G,MAAM,CAAE;QACjCgD,GAAG,CAAC3N,KAAK,CAAE,CAAC,EAAE,CAAE,CAAC,CAAE;MAEpB;MAEA,IAAKwK,KAAK,CAACY,IAAI,KAAKrH,SAAS,EAAG;QAAE;;QAEjC,IAAKsJ,MAAM,KAAKtR,UAAU,EAAG;UAE5ByB,OAAO,CAAC6K,KAAK,CAAE,6CAA6C,CAAE;QAE/D;QAEA,IAAKmC,KAAK,CAACE,KAAK,GAAGnN,OAAO,CAACsI,cAAc,IAAI2E,KAAK,CAACG,MAAM,GAAGpN,OAAO,CAACsI,cAAc,EAAG;UAEpFrI,OAAO,CAACC,IAAI,CAAE,wDAAwD,EAAE+M,KAAK,CAAE;QAEhF;QAEA,IAAMY,IAAI,GAAG,IAAIyC,iBAAiB,CAAErD,KAAK,CAACG,MAAM,GAAGH,KAAK,CAACE,KAAK,GAAG,CAAC,CAAE;QAEpE,KAAM,IAAI9M,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwN,IAAI,CAACtN,MAAM,EAAEF,CAAC,IAAI,CAAC,EAAG;UAE1CwN,IAAI,CAAExN,CAAC,GAAG,CAAC,CAAE,GAAG4M,KAAK,CAACY,IAAI,CAAExN,CAAC,GAAG,CAAC,CAAE;UACnCwN,IAAI,CAAExN,CAAC,GAAG,CAAC,CAAE,GAAG4M,KAAK,CAACY,IAAI,CAAExN,CAAC,GAAG,CAAC,CAAE;UACnCwN,IAAI,CAAExN,CAAC,GAAG,CAAC,CAAE,GAAG4M,KAAK,CAACY,IAAI,CAAExN,CAAC,GAAG,CAAC,CAAE;UACnCwN,IAAI,CAAExN,CAAC,GAAG,CAAC,CAAE,GAAG4M,KAAK,CAACY,IAAI,CAAExN,CAAC,GAAG,CAAC,CAAE;QAEpC;QAEA+P,GAAG,CAACtC,YAAY,CAAE,IAAIyC,SAAS,CAAE1C,IAAI,EAAEZ,KAAK,CAACE,KAAK,EAAEF,KAAK,CAACG,MAAM,CAAE,EAAE,CAAC,EAAE,CAAC,CAAE;MAE3E,CAAC,MAAM;QAENgD,GAAG,CAACzC,SAAS,CAAEV,KAAK,EAAE,CAAC,EAAE,CAAC,EAAE5G,MAAM,CAAC8G,KAAK,EAAE9G,MAAM,CAAC+G,MAAM,CAAE;MAE1D;MAEA,IAAKpN,OAAO,CAACkI,MAAM,KAAK,IAAI,EAAG;QAE9BtB,OAAO,CAACjH,IAAI,CAEXyG,gBAAgB,CAAEC,MAAM,EAAEC,QAAQ,CAAE,CAClCkK,IAAI,CAAE,UAAA5H,IAAI;UAAA,OAAI3J,MAAM,CAACwR,sBAAsB,CAAE7H,IAAI,CAAE;QAAA,EAAE,CACrD4H,IAAI,CAAE,UAAAE,eAAe,EAAI;UAEzBP,QAAQ,CAACV,UAAU,GAAGiB,eAAe;QAEtC,CAAC,CAAE,CAEJ;MAEF,CAAC,MAAM;QAEN,IAAKrK,MAAM,CAACsK,SAAS,KAAKnK,SAAS,EAAG;UAErC2J,QAAQ,CAAC7F,GAAG,GAAGjE,MAAM,CAACsK,SAAS,CAAErK,QAAQ,CAAE;QAE5C,CAAC,MAAM;UAENM,OAAO,CAACjH,IAAI,CAEXyG,gBAAgB,CAAEC,MAAM,EAAEC,QAAQ,CAAE,CAClCkK,IAAI,CAAE,UAAA5H,IAAI;YAAA,OAAI,IAAIM,UAAU,EAAE,CAACkB,aAAa,CAAExB,IAAI,CAAE;UAAA,EAAE,CACtD4H,IAAI,CAAE,UAAAI,OAAO,EAAI;YAEjBT,QAAQ,CAAC7F,GAAG,GAAGsG,OAAO;UAEvB,CAAC,CAAE,CAEJ;QAEF;MAED;MAEA,IAAMpN,KAAK,GAAG6D,IAAI,CAACU,MAAM,CAACpI,IAAI,CAAEwQ,QAAQ,CAAE,GAAG,CAAC;MAC9CH,YAAY,CAAEC,GAAG,CAAE,GAAGzM,KAAK;MAC3B,OAAOA,KAAK;IAEb;;IAEA;AACD;AACA;AACA;AACA;EAJC;IAAA;IAAA,OAKA,wBAAgBkJ,GAAG,EAAG;MAErB,IAAMrF,IAAI,GAAG,IAAI,CAACA,IAAI;MAEtB,IAAK,CAAEA,IAAI,CAACwJ,QAAQ,EAAGxJ,IAAI,CAACwJ,QAAQ,GAAG,EAAE;MAEzC,IAAMC,UAAU,GAAG;QAClBC,SAAS,EAAExO,cAAc,CAAEmK,GAAG,CAACqE,SAAS,CAAE;QAC1CC,SAAS,EAAEzO,cAAc,CAAEmK,GAAG,CAACsE,SAAS,CAAE;QAC1CC,KAAK,EAAE1O,cAAc,CAAEmK,GAAG,CAACuE,KAAK,CAAE;QAClCC,KAAK,EAAE3O,cAAc,CAAEmK,GAAG,CAACwE,KAAK;MACjC,CAAC;MAED,OAAO7J,IAAI,CAACwJ,QAAQ,CAAClR,IAAI,CAAEmR,UAAU,CAAE,GAAG,CAAC;IAE5C;;IAEA;AACD;AACA;AACA;AACA;EAJC;IAAA;IAAA,OAKA,wBAAgBpE,GAAG,EAAG;MAErB,IAAMjF,KAAK,GAAG,IAAI,CAACA,KAAK;MACxB,IAAMJ,IAAI,GAAG,IAAI,CAACA,IAAI;MAEtB,IAAKI,KAAK,CAACK,QAAQ,CAACoD,GAAG,CAAEwB,GAAG,CAAE,EAAG,OAAOjF,KAAK,CAACK,QAAQ,CAACqD,GAAG,CAAEuB,GAAG,CAAE;MAEjE,IAAK,CAAErF,IAAI,CAACS,QAAQ,EAAGT,IAAI,CAACS,QAAQ,GAAG,EAAE;MAEzC,IAAIxB,QAAQ,GAAGoG,GAAG,CAACjC,QAAQ,CAACnE,QAAQ;MAEpC,IAAKA,QAAQ,KAAK,YAAY,EAAGA,QAAQ,GAAG,WAAW;MAEvD,IAAM6K,UAAU,GAAG;QAClBC,OAAO,EAAE,IAAI,CAACC,cAAc,CAAE3E,GAAG,CAAE;QACnCsB,MAAM,EAAE,IAAI,CAACsD,YAAY,CAAE5E,GAAG,CAACO,KAAK,EAAEP,GAAG,CAACoD,MAAM,EAAEpD,GAAG,CAACqD,KAAK,EAAEzJ,QAAQ;MACtE,CAAC;MAED,IAAKoG,GAAG,CAAC3B,IAAI,EAAGoG,UAAU,CAACpG,IAAI,GAAG2B,GAAG,CAAC3B,IAAI;MAE1C,IAAI,CAACwG,UAAU,CAAE,UAAWC,GAAG,EAAG;QAEjCA,GAAG,CAACC,YAAY,IAAID,GAAG,CAACC,YAAY,CAAE/E,GAAG,EAAEyE,UAAU,CAAE;MAExD,CAAC,CAAE;MAEH,IAAM3N,KAAK,GAAG6D,IAAI,CAACS,QAAQ,CAACnI,IAAI,CAAEwR,UAAU,CAAE,GAAG,CAAC;MAClD1J,KAAK,CAACK,QAAQ,CAAC/B,GAAG,CAAE2G,GAAG,EAAElJ,KAAK,CAAE;MAChC,OAAOA,KAAK;IAEb;;IAEA;AACD;AACA;AACA;AACA;EAJC;IAAA;IAAA,OAKA,yBAAiBkO,QAAQ,EAAG;MAE3B,IAAMjK,KAAK,GAAG,IAAI,CAACA,KAAK;MACxB,IAAMJ,IAAI,GAAG,IAAI,CAACA,IAAI;MAEtB,IAAKI,KAAK,CAACI,SAAS,CAACqD,GAAG,CAAEwG,QAAQ,CAAE,EAAG,OAAOjK,KAAK,CAACI,SAAS,CAACsD,GAAG,CAAEuG,QAAQ,CAAE;MAE7E,IAAKA,QAAQ,CAACC,gBAAgB,EAAG;QAEhC1R,OAAO,CAACC,IAAI,CAAE,mDAAmD,CAAE;QACnE,OAAO,IAAI;MAEZ;MAEA,IAAK,CAAEmH,IAAI,CAACQ,SAAS,EAAGR,IAAI,CAACQ,SAAS,GAAG,EAAE;;MAE3C;MACA,IAAM+J,WAAW,GAAG;QAAEC,oBAAoB,EAAE,CAAC;MAAE,CAAC;MAEhD,IAAKH,QAAQ,CAACI,sBAAsB,KAAK,IAAI,IAAIJ,QAAQ,CAACK,mBAAmB,KAAK,IAAI,EAAG;QAExF9R,OAAO,CAACC,IAAI,CAAE,+EAA+E,CAAE;MAEhG;;MAEA;MACA,IAAM8R,KAAK,GAAGN,QAAQ,CAACM,KAAK,CAAC5F,OAAO,EAAE,CAAC6F,MAAM,CAAE,CAAEP,QAAQ,CAACQ,OAAO,CAAE,CAAE;MAErE,IAAK,CAAE/O,UAAU,CAAE6O,KAAK,EAAE,CAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAE,CAAE,EAAG;QAE5CJ,WAAW,CAACC,oBAAoB,CAACM,eAAe,GAAGH,KAAK;MAEzD;MAEA,IAAKN,QAAQ,CAACI,sBAAsB,EAAG;QAEtCF,WAAW,CAACC,oBAAoB,CAACO,cAAc,GAAGV,QAAQ,CAAC1E,SAAS;QACpE4E,WAAW,CAACC,oBAAoB,CAACQ,eAAe,GAAGX,QAAQ,CAACxE,SAAS;MAEtE,CAAC,MAAM;QAEN0E,WAAW,CAACC,oBAAoB,CAACO,cAAc,GAAG,GAAG;QACrDR,WAAW,CAACC,oBAAoB,CAACQ,eAAe,GAAG,GAAG;MAEvD;;MAEA;MACA,IAAKX,QAAQ,CAACnF,YAAY,IAAImF,QAAQ,CAAClF,YAAY,EAAG;QAErD,IAAM8F,iBAAiB,GAAG,IAAI,CAACC,sBAAsB,CAAEb,QAAQ,CAACnF,YAAY,EAAEmF,QAAQ,CAAClF,YAAY,CAAE;QAErG,IAAMgG,gBAAgB,GAAG;UAAEhP,KAAK,EAAE,IAAI,CAACiP,cAAc,CAAEH,iBAAiB;QAAG,CAAC;QAC5E,IAAI,CAACI,qBAAqB,CAAEF,gBAAgB,EAAEF,iBAAiB,CAAE;QACjEV,WAAW,CAACC,oBAAoB,CAACc,wBAAwB,GAAGH,gBAAgB;MAE7E;;MAEA;MACA,IAAKd,QAAQ,CAAChF,GAAG,EAAG;QAEnB,IAAMkG,eAAe,GAAG;UAAEpP,KAAK,EAAE,IAAI,CAACiP,cAAc,CAAEf,QAAQ,CAAChF,GAAG;QAAG,CAAC;QACtE,IAAI,CAACgG,qBAAqB,CAAEE,eAAe,EAAElB,QAAQ,CAAChF,GAAG,CAAE;QAC3DkF,WAAW,CAACC,oBAAoB,CAACgB,gBAAgB,GAAGD,eAAe;MAEpE;MAEA,IAAKlB,QAAQ,CAACoB,QAAQ,EAAG;QAExB;QACA,IAAMA,QAAQ,GAAGpB,QAAQ,CAACoB,QAAQ,CAACtH,KAAK,EAAE,CAACuH,cAAc,CAAErB,QAAQ,CAACsB,iBAAiB,CAAE;QACvF,IAAMC,oBAAoB,GAAG5N,IAAI,CAACT,GAAG,CAAEkO,QAAQ,CAACI,CAAC,EAAEJ,QAAQ,CAACK,CAAC,EAAEL,QAAQ,CAACM,CAAC,CAAE;QAE3E,IAAKH,oBAAoB,GAAG,CAAC,EAAG;UAE/BH,QAAQ,CAACC,cAAc,CAAE,CAAC,GAAGE,oBAAoB,CAAE;UAEnDhT,OAAO,CAACC,IAAI,CAAE,kFAAkF,CAAE;QAEnG;QAEA,IAAK+S,oBAAoB,GAAG,CAAC,EAAG;UAE/BrB,WAAW,CAACyB,cAAc,GAAGP,QAAQ,CAAC1G,OAAO,EAAE;QAEhD;;QAEA;QACA,IAAKsF,QAAQ,CAAC4B,WAAW,EAAG;UAE3B,IAAMC,cAAc,GAAG;YAAE/P,KAAK,EAAE,IAAI,CAACiP,cAAc,CAAEf,QAAQ,CAAC4B,WAAW;UAAG,CAAC;UAC7E,IAAI,CAACZ,qBAAqB,CAAEa,cAAc,EAAE7B,QAAQ,CAAC4B,WAAW,CAAE;UAClE1B,WAAW,CAAC4B,eAAe,GAAGD,cAAc;QAE7C;MAED;;MAEA;MACA,IAAK7B,QAAQ,CAAC+B,SAAS,EAAG;QAEzB,IAAMC,YAAY,GAAG;UAAElQ,KAAK,EAAE,IAAI,CAACiP,cAAc,CAAEf,QAAQ,CAAC+B,SAAS;QAAG,CAAC;QAEzE,IAAK/B,QAAQ,CAACiC,WAAW,IAAIjC,QAAQ,CAACiC,WAAW,CAAClI,CAAC,KAAK,CAAC,EAAG;UAE3D;UACA;UACAiI,YAAY,CAACjR,KAAK,GAAGiP,QAAQ,CAACiC,WAAW,CAAClI,CAAC;QAE5C;QAEA,IAAI,CAACiH,qBAAqB,CAAEgB,YAAY,EAAEhC,QAAQ,CAAC+B,SAAS,CAAE;QAC9D7B,WAAW,CAACgC,aAAa,GAAGF,YAAY;MAEzC;;MAEA;MACA,IAAKhC,QAAQ,CAACmC,KAAK,EAAG;QAErB,IAAMC,eAAe,GAAG;UACvBtQ,KAAK,EAAE,IAAI,CAACiP,cAAc,CAAEf,QAAQ,CAACmC,KAAK,CAAE;UAC5CE,QAAQ,EAAE;QACX,CAAC;QAED,IAAKrC,QAAQ,CAACsC,cAAc,KAAK,GAAG,EAAG;UAEtCF,eAAe,CAACG,QAAQ,GAAGvC,QAAQ,CAACsC,cAAc;QAEnD;QAEA,IAAI,CAACtB,qBAAqB,CAAEoB,eAAe,EAAEpC,QAAQ,CAACmC,KAAK,CAAE;QAC7DjC,WAAW,CAACsC,gBAAgB,GAAGJ,eAAe;MAE/C;;MAEA;MACA,IAAKpC,QAAQ,CAACyC,WAAW,EAAG;QAE3BvC,WAAW,CAACwC,SAAS,GAAG,OAAO;MAEhC,CAAC,MAAM;QAEN,IAAK1C,QAAQ,CAAC2C,SAAS,GAAG,GAAG,EAAG;UAE/BzC,WAAW,CAACwC,SAAS,GAAG,MAAM;UAC9BxC,WAAW,CAAC0C,WAAW,GAAG5C,QAAQ,CAAC2C,SAAS;QAE7C;MAED;;MAEA;MACA,IAAK3C,QAAQ,CAAC6C,IAAI,KAAK7W,UAAU,EAAGkU,WAAW,CAAC4C,WAAW,GAAG,IAAI;MAClE,IAAK9C,QAAQ,CAAC3G,IAAI,KAAK,EAAE,EAAG6G,WAAW,CAAC7G,IAAI,GAAG2G,QAAQ,CAAC3G,IAAI;MAE5D,IAAI,CAAC0J,iBAAiB,CAAE/C,QAAQ,EAAEE,WAAW,CAAE;MAE/C,IAAI,CAACL,UAAU,CAAE,UAAWC,GAAG,EAAG;QAEjCA,GAAG,CAACkD,aAAa,IAAIlD,GAAG,CAACkD,aAAa,CAAEhD,QAAQ,EAAEE,WAAW,CAAE;MAEhE,CAAC,CAAE;MAEH,IAAMpO,KAAK,GAAG6D,IAAI,CAACQ,SAAS,CAAClI,IAAI,CAAEiS,WAAW,CAAE,GAAG,CAAC;MACpDnK,KAAK,CAACI,SAAS,CAAC9B,GAAG,CAAE2L,QAAQ,EAAElO,KAAK,CAAE;MACtC,OAAOA,KAAK;IAEb;;IAEA;AACD;AACA;AACA;AACA;EAJC;IAAA;IAAA,OAKA,qBAAamR,IAAI,EAAG;MAEnB,IAAMlN,KAAK,GAAG,IAAI,CAACA,KAAK;MACxB,IAAMJ,IAAI,GAAG,IAAI,CAACA,IAAI;MAEtB,IAAMuN,iBAAiB,GAAG,CAAED,IAAI,CAAC9F,QAAQ,CAACgG,IAAI,CAAE;MAEhD,IAAKtQ,KAAK,CAACuQ,OAAO,CAAEH,IAAI,CAACjD,QAAQ,CAAE,EAAG;QAErC,KAAM,IAAIrR,CAAC,GAAG,CAAC,EAAE0U,CAAC,GAAGJ,IAAI,CAACjD,QAAQ,CAACnR,MAAM,EAAEF,CAAC,GAAG0U,CAAC,EAAE1U,CAAC,EAAG,EAAG;UAExDuU,iBAAiB,CAACjV,IAAI,CAAEgV,IAAI,CAACjD,QAAQ,CAAErR,CAAC,CAAE,CAACwU,IAAI,CAAE;QAElD;MAED,CAAC,MAAM;QAEND,iBAAiB,CAACjV,IAAI,CAAEgV,IAAI,CAACjD,QAAQ,CAACmD,IAAI,CAAE;MAE7C;MAEA,IAAMG,YAAY,GAAGJ,iBAAiB,CAACK,IAAI,CAAE,GAAG,CAAE;MAElD,IAAKxN,KAAK,CAACC,MAAM,CAACwD,GAAG,CAAE8J,YAAY,CAAE,EAAG,OAAOvN,KAAK,CAACC,MAAM,CAACyD,GAAG,CAAE6J,YAAY,CAAE;MAE/E,IAAMnG,QAAQ,GAAG8F,IAAI,CAAC9F,QAAQ;MAE9B,IAAIqG,IAAI;;MAER;MACA,IAAKP,IAAI,CAACQ,cAAc,EAAG;QAE1BD,IAAI,GAAGlU,eAAe,CAACE,KAAK;MAE7B,CAAC,MAAM,IAAKyT,IAAI,CAACS,UAAU,EAAG;QAE7BF,IAAI,GAAGlU,eAAe,CAACG,SAAS;MAEjC,CAAC,MAAM,IAAKwT,IAAI,CAACU,MAAM,EAAG;QAEzBH,IAAI,GAAGlU,eAAe,CAACI,UAAU;MAElC,CAAC,MAAM,IAAKuT,IAAI,CAACW,QAAQ,EAAG;QAE3BJ,IAAI,GAAGlU,eAAe,CAACC,MAAM;MAE9B,CAAC,MAAM;QAENiU,IAAI,GAAGP,IAAI,CAACjD,QAAQ,CAAC6D,SAAS,GAAGvU,eAAe,CAACE,KAAK,GAAGF,eAAe,CAACK,SAAS;MAEnF;MAEA,IAAKwN,QAAQ,CAAC2G,gBAAgB,KAAK,IAAI,EAAG;QAEzC,MAAM,IAAIrG,KAAK,CAAE,mEAAmE,CAAE;MAEvF;MAEA,IAAMsG,OAAO,GAAG,CAAC,CAAC;MAClB,IAAM9N,UAAU,GAAG,CAAC,CAAC;MACrB,IAAM+N,UAAU,GAAG,EAAE;MACrB,IAAMC,OAAO,GAAG,EAAE;;MAElB;MACA,IAAMC,cAAc,GAAG;QACtBC,EAAE,EAAE,YAAY;QAChBC,GAAG,EAAE,YAAY;QACjB9D,KAAK,EAAE,SAAS;QAChB+D,UAAU,EAAE,WAAW;QACvBC,SAAS,EAAE;MACZ,CAAC;MAED,IAAMC,cAAc,GAAGpH,QAAQ,CAACqH,YAAY,CAAE,QAAQ,CAAE;MAExD,IAAKD,cAAc,KAAKzP,SAAS,IAAI,CAAE,IAAI,CAAC2P,2BAA2B,CAAEF,cAAc,CAAE,EAAG;QAE3FhW,OAAO,CAACC,IAAI,CAAE,uFAAuF,CAAE;QAEvG2O,QAAQ,CAACuH,YAAY,CAAE,QAAQ,EAAE,IAAI,CAACC,+BAA+B,CAAEJ,cAAc,CAAE,CAAE;MAE1F;;MAEA;MACA;MACA,IAAIK,iBAAiB,GAAG,IAAI;MAE5B,KAAM,IAAIC,aAAa,IAAI1H,QAAQ,CAAClH,UAAU,EAAG;QAEhD;QACA,IAAK4O,aAAa,CAACC,KAAK,CAAE,CAAC,EAAE,CAAC,CAAE,KAAK,OAAO,EAAG;QAE/C,IAAMtS,SAAS,GAAG2K,QAAQ,CAAClH,UAAU,CAAE4O,aAAa,CAAE;QACtDA,aAAa,GAAGX,cAAc,CAAEW,aAAa,CAAE,IAAIA,aAAa,CAACE,WAAW,EAAE;;QAE9E;QACA;QACA,IAAMC,qBAAqB,GACzB,2EAA2E;QAE7E,IAAK,CAAEA,qBAAqB,CAACC,IAAI,CAAEJ,aAAa,CAAE,EAAGA,aAAa,GAAG,GAAG,GAAGA,aAAa;QAExF,IAAK9O,KAAK,CAACE,UAAU,CAACuD,GAAG,CAAE,IAAI,CAAC0L,MAAM,CAAE1S,SAAS,CAAE,CAAE,EAAG;UAEvDyD,UAAU,CAAE4O,aAAa,CAAE,GAAG9O,KAAK,CAACE,UAAU,CAACwD,GAAG,CAAE,IAAI,CAACyL,MAAM,CAAE1S,SAAS,CAAE,CAAE;UAC9E;QAED;;QAEA;QACAoS,iBAAiB,GAAG,IAAI;QACxB,IAAMtR,KAAK,GAAGd,SAAS,CAACc,KAAK;QAE7B,IAAKuR,aAAa,KAAK,UAAU,IAChC,EAAIvR,KAAK,YAAYkK,WAAW,CAAE,IAClC,EAAIlK,KAAK,YAAYc,UAAU,CAAE,EAAG;UAEpC7F,OAAO,CAACC,IAAI,CAAE,uEAAuE,CAAE;UACvFoW,iBAAiB,GAAG,IAAI9Y,eAAe,CAAE,IAAI0R,WAAW,CAAElK,KAAK,CAAE,EAAEd,SAAS,CAACM,QAAQ,EAAEN,SAAS,CAAC0L,UAAU,CAAE;QAE9G;QAEA,IAAMiH,QAAQ,GAAG,IAAI,CAACC,eAAe,CAAER,iBAAiB,IAAIpS,SAAS,EAAE2K,QAAQ,CAAE;QAEjF,IAAKgI,QAAQ,KAAK,IAAI,EAAG;UAExBlP,UAAU,CAAE4O,aAAa,CAAE,GAAGM,QAAQ;UACtCpP,KAAK,CAACE,UAAU,CAAC5B,GAAG,CAAE,IAAI,CAAC6Q,MAAM,CAAE1S,SAAS,CAAE,EAAE2S,QAAQ,CAAE;QAE3D;MAED;MAEA,IAAKZ,cAAc,KAAKzP,SAAS,EAAGqI,QAAQ,CAACuH,YAAY,CAAE,QAAQ,EAAEH,cAAc,CAAE;;MAErF;MACA,IAAKjO,MAAM,CAACe,IAAI,CAAEpB,UAAU,CAAE,CAACpH,MAAM,KAAK,CAAC,EAAG,OAAO,IAAI;;MAEzD;MACA,IAAKoU,IAAI,CAAC/R,qBAAqB,KAAK4D,SAAS,IAAImO,IAAI,CAAC/R,qBAAqB,CAACrC,MAAM,GAAG,CAAC,EAAG;QAExF,IAAMwW,OAAO,GAAG,EAAE;QAClB,IAAMC,WAAW,GAAG,EAAE;QACtB,IAAMC,iBAAiB,GAAG,CAAC,CAAC;QAE5B,IAAKtC,IAAI,CAACuC,qBAAqB,KAAK1Q,SAAS,EAAG;UAE/C,KAAM,IAAMyJ,GAAG,IAAI0E,IAAI,CAACuC,qBAAqB,EAAG;YAE/CD,iBAAiB,CAAEtC,IAAI,CAACuC,qBAAqB,CAAEjH,GAAG,CAAE,CAAE,GAAGA,GAAG;UAE7D;QAED;QAEA,KAAM,IAAI5P,GAAC,GAAG,CAAC,EAAEA,GAAC,GAAGsU,IAAI,CAAC/R,qBAAqB,CAACrC,MAAM,EAAE,EAAGF,GAAC,EAAG;UAE9D,IAAM6N,MAAM,GAAG,CAAC,CAAC;UACjB,IAAIiJ,MAAM,GAAG,KAAK;UAElB,KAAM,IAAMZ,cAAa,IAAI1H,QAAQ,CAACuI,eAAe,EAAG;YAEvD;YACA;;YAEA,IAAKb,cAAa,KAAK,UAAU,IAAIA,cAAa,KAAK,QAAQ,EAAG;cAEjE,IAAK,CAAEY,MAAM,EAAG;gBAEflX,OAAO,CAACC,IAAI,CAAE,6DAA6D,CAAE;gBAC7EiX,MAAM,GAAG,IAAI;cAEd;cAEA;YAED;YAEA,IAAMjT,UAAS,GAAG2K,QAAQ,CAACuI,eAAe,CAAEb,cAAa,CAAE,CAAElW,GAAC,CAAE;YAChE,IAAMgX,iBAAiB,GAAGd,cAAa,CAACE,WAAW,EAAE;;YAErD;YACA;YACA;YACA;;YAEA,IAAMa,aAAa,GAAGzI,QAAQ,CAAClH,UAAU,CAAE4O,cAAa,CAAE;YAE1D,IAAK9O,KAAK,CAACE,UAAU,CAACuD,GAAG,CAAE,IAAI,CAAC0L,MAAM,CAAE1S,UAAS,EAAE,IAAI,CAAE,CAAE,EAAG;cAE7DgK,MAAM,CAAEmJ,iBAAiB,CAAE,GAAG5P,KAAK,CAACE,UAAU,CAACwD,GAAG,CAAE,IAAI,CAACyL,MAAM,CAAE1S,UAAS,EAAE,IAAI,CAAE,CAAE;cACpF;YAED;;YAEA;YACA,IAAMqT,iBAAiB,GAAGrT,UAAS,CAACsH,KAAK,EAAE;YAE3C,IAAK,CAAEqD,QAAQ,CAAC2I,oBAAoB,EAAG;cAEtC,KAAM,IAAIC,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGxT,UAAS,CAACE,KAAK,EAAEqT,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAG,EAAG;gBAErDF,iBAAiB,CAACzL,MAAM,CACvB2L,CAAC,EACDvT,UAAS,CAACe,IAAI,CAAEwS,CAAC,CAAE,GAAGH,aAAa,CAACrS,IAAI,CAAEwS,CAAC,CAAE,EAC7CvT,UAAS,CAACgB,IAAI,CAAEuS,CAAC,CAAE,GAAGH,aAAa,CAACpS,IAAI,CAAEuS,CAAC,CAAE,EAC7CvT,UAAS,CAACiB,IAAI,CAAEsS,CAAC,CAAE,GAAGH,aAAa,CAACnS,IAAI,CAAEsS,CAAC,CAAE,CAC7C;cAEF;YAED;YAEAvJ,MAAM,CAAEmJ,iBAAiB,CAAE,GAAG,IAAI,CAACP,eAAe,CAAES,iBAAiB,EAAE1I,QAAQ,CAAE;YACjFpH,KAAK,CAACE,UAAU,CAAC5B,GAAG,CAAE,IAAI,CAAC6Q,MAAM,CAAEU,aAAa,EAAE,IAAI,CAAE,EAAEpJ,MAAM,CAAEmJ,iBAAiB,CAAE,CAAE;UAExF;UAEA1B,OAAO,CAAChW,IAAI,CAAEuO,MAAM,CAAE;UAEtB6I,OAAO,CAACpX,IAAI,CAAEgV,IAAI,CAAC/R,qBAAqB,CAAEvC,GAAC,CAAE,CAAE;UAE/C,IAAKsU,IAAI,CAACuC,qBAAqB,KAAK1Q,SAAS,EAAGwQ,WAAW,CAACrX,IAAI,CAAEsX,iBAAiB,CAAE5W,GAAC,CAAE,CAAE;QAE3F;QAEAoV,OAAO,CAACsB,OAAO,GAAGA,OAAO;QAEzB,IAAKC,WAAW,CAACzW,MAAM,GAAG,CAAC,EAAG;UAE7BkV,OAAO,CAAC5K,MAAM,GAAG,CAAC,CAAC;UACnB4K,OAAO,CAAC5K,MAAM,CAACmM,WAAW,GAAGA,WAAW;QAEzC;MAED;MAEA,IAAMW,eAAe,GAAGpT,KAAK,CAACuQ,OAAO,CAAEH,IAAI,CAACjD,QAAQ,CAAE;MAEtD,IAAKiG,eAAe,IAAI9I,QAAQ,CAAC+I,MAAM,CAACrX,MAAM,KAAK,CAAC,EAAG,OAAO,IAAI;MAElE,IAAMsH,SAAS,GAAG8P,eAAe,GAAGhD,IAAI,CAACjD,QAAQ,GAAG,CAAEiD,IAAI,CAACjD,QAAQ,CAAE;MACrE,IAAMkG,MAAM,GAAGD,eAAe,GAAG9I,QAAQ,CAAC+I,MAAM,GAAG,CAAE;QAAEC,aAAa,EAAE,CAAC;QAAE1T,KAAK,EAAEqC,SAAS;QAAEpC,KAAK,EAAEoC;MAAU,CAAC,CAAE;MAE/G,KAAM,IAAInG,GAAC,GAAG,CAAC,EAAEC,EAAE,GAAGsX,MAAM,CAACrX,MAAM,EAAEF,GAAC,GAAGC,EAAE,EAAED,GAAC,EAAG,EAAG;QAEnD,IAAMyX,SAAS,GAAG;UACjB5C,IAAI,EAAEA,IAAI;UACVvN,UAAU,EAAEA;QACb,CAAC;QAED,IAAI,CAAC8M,iBAAiB,CAAE5F,QAAQ,EAAEiJ,SAAS,CAAE;QAE7C,IAAKnC,OAAO,CAACpV,MAAM,GAAG,CAAC,EAAGuX,SAAS,CAACnC,OAAO,GAAGA,OAAO;QAErD,IAAK9G,QAAQ,CAACrL,KAAK,KAAK,IAAI,EAAG;UAE9B,IAAIuU,QAAQ,GAAG,IAAI,CAACnB,MAAM,CAAE/H,QAAQ,CAACrL,KAAK,CAAE;UAE5C,IAAKoU,MAAM,CAAEvX,GAAC,CAAE,CAAC8D,KAAK,KAAKqC,SAAS,IAAIoR,MAAM,CAAEvX,GAAC,CAAE,CAAC+D,KAAK,KAAKoC,SAAS,EAAG;YAEzEuR,QAAQ,IAAI,GAAG,GAAGH,MAAM,CAAEvX,GAAC,CAAE,CAAC8D,KAAK,GAAG,GAAG,GAAGyT,MAAM,CAAEvX,GAAC,CAAE,CAAC+D,KAAK;UAE9D;UAEA,IAAKqD,KAAK,CAACE,UAAU,CAACuD,GAAG,CAAE6M,QAAQ,CAAE,EAAG;YAEvCD,SAAS,CAACE,OAAO,GAAGvQ,KAAK,CAACE,UAAU,CAACwD,GAAG,CAAE4M,QAAQ,CAAE;UAErD,CAAC,MAAM;YAEND,SAAS,CAACE,OAAO,GAAG,IAAI,CAAClB,eAAe,CAAEjI,QAAQ,CAACrL,KAAK,EAAEqL,QAAQ,EAAE+I,MAAM,CAAEvX,GAAC,CAAE,CAAC8D,KAAK,EAAEyT,MAAM,CAAEvX,GAAC,CAAE,CAAC+D,KAAK,CAAE;YAC1GqD,KAAK,CAACE,UAAU,CAAC5B,GAAG,CAAEgS,QAAQ,EAAED,SAAS,CAACE,OAAO,CAAE;UAEpD;UAEA,IAAKF,SAAS,CAACE,OAAO,KAAK,IAAI,EAAG,OAAOF,SAAS,CAACE,OAAO;QAE3D;QAEA,IAAMtG,QAAQ,GAAG,IAAI,CAACuG,eAAe,CAAEpQ,SAAS,CAAE+P,MAAM,CAAEvX,GAAC,CAAE,CAACwX,aAAa,CAAE,CAAE;QAE/E,IAAKnG,QAAQ,KAAK,IAAI,EAAGoG,SAAS,CAACpG,QAAQ,GAAGA,QAAQ;QAEtDgE,UAAU,CAAC/V,IAAI,CAAEmY,SAAS,CAAE;MAE7B;MAEArC,OAAO,CAACC,UAAU,GAAGA,UAAU;MAE/B,IAAK,CAAErO,IAAI,CAACK,MAAM,EAAGL,IAAI,CAACK,MAAM,GAAG,EAAE;MAErC,IAAI,CAAC6J,UAAU,CAAE,UAAWC,GAAG,EAAG;QAEjCA,GAAG,CAAC0G,SAAS,IAAI1G,GAAG,CAAC0G,SAAS,CAAEvD,IAAI,EAAEc,OAAO,CAAE;MAEhD,CAAC,CAAE;MAEH,IAAMjS,KAAK,GAAG6D,IAAI,CAACK,MAAM,CAAC/H,IAAI,CAAE8V,OAAO,CAAE,GAAG,CAAC;MAC7ChO,KAAK,CAACC,MAAM,CAAC3B,GAAG,CAAEiP,YAAY,EAAExR,KAAK,CAAE;MACvC,OAAOA,KAAK;IAEb;;IAEA;AACD;AACA;AACA;AACA;EAJC;IAAA;IAAA,OAKA,uBAAe2U,MAAM,EAAG;MAEvB,IAAM9Q,IAAI,GAAG,IAAI,CAACA,IAAI;MAEtB,IAAK,CAAEA,IAAI,CAAC+Q,OAAO,EAAG/Q,IAAI,CAAC+Q,OAAO,GAAG,EAAE;MAEvC,IAAMC,OAAO,GAAGF,MAAM,CAACG,oBAAoB;MAE3C,IAAMC,SAAS,GAAG;QACjB5R,IAAI,EAAE0R,OAAO,GAAG,cAAc,GAAG;MAClC,CAAC;MAED,IAAKA,OAAO,EAAG;QAEdE,SAAS,CAACC,YAAY,GAAG;UACxBC,IAAI,EAAEN,MAAM,CAACO,KAAK,GAAG,CAAC;UACtBC,IAAI,EAAER,MAAM,CAACS,GAAG,GAAG,CAAC;UACpBC,IAAI,EAAEV,MAAM,CAACW,GAAG,IAAI,CAAC,GAAG,KAAK,GAAGX,MAAM,CAACW,GAAG;UAC1CC,KAAK,EAAEZ,MAAM,CAACa,IAAI,GAAG,CAAC,GAAG,CAAC,GAAGb,MAAM,CAACa;QACrC,CAAC;MAEF,CAAC,MAAM;QAENT,SAAS,CAACU,WAAW,GAAG;UACvBC,WAAW,EAAEf,MAAM,CAACgB,MAAM;UAC1BC,IAAI,EAAEnb,SAAS,CAACob,QAAQ,CAAElB,MAAM,CAACmB,GAAG,CAAE;UACtCT,IAAI,EAAEV,MAAM,CAACW,GAAG,IAAI,CAAC,GAAG,KAAK,GAAGX,MAAM,CAACW,GAAG;UAC1CC,KAAK,EAAEZ,MAAM,CAACa,IAAI,GAAG,CAAC,GAAG,CAAC,GAAGb,MAAM,CAACa;QACrC,CAAC;MAEF;;MAEA;MACA,IAAKb,MAAM,CAACpN,IAAI,KAAK,EAAE,EAAGwN,SAAS,CAACxN,IAAI,GAAGoN,MAAM,CAACxR,IAAI;MAEtD,OAAOU,IAAI,CAAC+Q,OAAO,CAACzY,IAAI,CAAE4Y,SAAS,CAAE,GAAG,CAAC;IAE1C;;IAEA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EATC;IAAA;IAAA,OAUA,0BAAkBgB,IAAI,EAAEC,IAAI,EAAG;MAE9B,IAAMnS,IAAI,GAAG,IAAI,CAACA,IAAI;MACtB,IAAMN,OAAO,GAAG,IAAI,CAACA,OAAO;MAE5B,IAAK,CAAEM,IAAI,CAACmB,UAAU,EAAGnB,IAAI,CAACmB,UAAU,GAAG,EAAE;MAE7C+Q,IAAI,GAAGza,YAAY,CAAC2a,KAAK,CAACC,sBAAsB,CAAEH,IAAI,CAAC/N,KAAK,EAAE,EAAEgO,IAAI,CAAE;MAEtE,IAAMG,MAAM,GAAGJ,IAAI,CAACI,MAAM;MAC1B,IAAMC,QAAQ,GAAG,EAAE;MACnB,IAAM/I,QAAQ,GAAG,EAAE;MAEnB,KAAM,IAAIxQ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsZ,MAAM,CAACpZ,MAAM,EAAE,EAAGF,CAAC,EAAG;QAE1C,IAAMwZ,KAAK,GAAGF,MAAM,CAAEtZ,CAAC,CAAE;QACzB,IAAMyZ,YAAY,GAAGvb,eAAe,CAACwb,cAAc,CAAEF,KAAK,CAAC9O,IAAI,CAAE;QACjE,IAAIiP,SAAS,GAAGzb,eAAe,CAAC0b,QAAQ,CAAET,IAAI,EAAEM,YAAY,CAACI,QAAQ,CAAE;QACvE,IAAMC,aAAa,GAAG3X,eAAe,CAAEsX,YAAY,CAACM,YAAY,CAAE;QAElE,IAAKN,YAAY,CAACO,UAAU,KAAK,OAAO,EAAG;UAE1C,IAAKL,SAAS,CAACM,aAAa,KAAK,IAAI,EAAG;YAEvCN,SAAS,GAAGA,SAAS,CAACO,QAAQ,CAACC,aAAa,CAAEV,YAAY,CAACW,WAAW,CAAE;UAEzE,CAAC,MAAM;YAENT,SAAS,GAAGxT,SAAS;UAEtB;QAED;QAEA,IAAK,CAAEwT,SAAS,IAAI,CAAEG,aAAa,EAAG;UAErCla,OAAO,CAACC,IAAI,CAAE,4DAA4D,EAAE2Z,KAAK,CAAC9O,IAAI,CAAE;UACxF,OAAO,IAAI;QAEZ;QAEA,IAAM2P,aAAa,GAAG,CAAC;QACvB,IAAIC,cAAc,GAAGd,KAAK,CAACe,MAAM,CAACra,MAAM,GAAGsZ,KAAK,CAACgB,KAAK,CAACta,MAAM;QAE7D,IAAK4Z,aAAa,KAAK3X,eAAe,CAACI,qBAAqB,EAAG;UAE9D+X,cAAc,IAAIX,SAAS,CAACpX,qBAAqB,CAACrC,MAAM;QAEzD;QAEA,IAAIua,aAAa;;QAEjB;;QAEA;QACA;QACA;QACA,IAAKjB,KAAK,CAACkB,iBAAiB,CAACC,yCAAyC,KAAK,IAAI,EAAG;UAEjFF,aAAa,GAAG,aAAa;;UAE7B;UACA;UACA;UACAH,cAAc,IAAI,CAAC;QAEpB,CAAC,MAAM,IAAKd,KAAK,CAACoB,gBAAgB,EAAE,KAAKtd,mBAAmB,EAAG;UAE9Dmd,aAAa,GAAG,MAAM;QAEvB,CAAC,MAAM;UAENA,aAAa,GAAG,QAAQ;QAEzB;QAEAjK,QAAQ,CAAClR,IAAI,CAAE;UACdE,KAAK,EAAE,IAAI,CAACiX,eAAe,CAAE,IAAItZ,eAAe,CAAEqc,KAAK,CAACgB,KAAK,EAAEH,aAAa,CAAE,CAAE;UAChFrW,MAAM,EAAE,IAAI,CAACyS,eAAe,CAAE,IAAItZ,eAAe,CAAEqc,KAAK,CAACe,MAAM,EAAED,cAAc,CAAE,CAAE;UACnFG,aAAa,EAAEA;QAChB,CAAC,CAAE;QAEHlB,QAAQ,CAACja,IAAI,CAAE;UACdyR,OAAO,EAAEP,QAAQ,CAACtQ,MAAM,GAAG,CAAC;UAC5B2N,MAAM,EAAE;YACPgN,IAAI,EAAEnU,OAAO,CAACoE,GAAG,CAAE6O,SAAS,CAAE;YAC9BmB,IAAI,EAAEhB;UACP;QACD,CAAC,CAAE;MAEJ;MAEA9S,IAAI,CAACmB,UAAU,CAAC7I,IAAI,CAAE;QACrBoL,IAAI,EAAEwO,IAAI,CAACxO,IAAI,IAAI,OAAO,GAAG1D,IAAI,CAACmB,UAAU,CAACjI,MAAM;QACnDsQ,QAAQ,EAAEA,QAAQ;QAClB+I,QAAQ,EAAEA;MACX,CAAC,CAAE;MAEH,OAAOvS,IAAI,CAACmB,UAAU,CAACjI,MAAM,GAAG,CAAC;IAElC;;IAEA;AACD;AACA;AACA;EAHC;IAAA;IAAA,OAIC,qBAAagK,MAAM,EAAG;MAEtB,IAAMlD,IAAI,GAAG,IAAI,CAACA,IAAI;MACtB,IAAMN,OAAO,GAAG,IAAI,CAACA,OAAO;MAE5B,IAAMmU,IAAI,GAAG7T,IAAI,CAAC+T,KAAK,CAAErU,OAAO,CAACoE,GAAG,CAAEZ,MAAM,CAAE,CAAE;MAEhD,IAAMgQ,QAAQ,GAAGhQ,MAAM,CAACgQ,QAAQ;MAEhC,IAAKA,QAAQ,KAAK/T,SAAS,EAAG,OAAO,IAAI;MAEzC,IAAM6U,SAAS,GAAG9Q,MAAM,CAACgQ,QAAQ,CAACe,KAAK,CAAE,CAAC,CAAE;MAE5C,IAAKD,SAAS,KAAK7U,SAAS,EAAG,OAAO,IAAI;MAE1C,IAAM+U,MAAM,GAAG,EAAE;MACjB,IAAMC,mBAAmB,GAAG,IAAIxM,YAAY,CAAEuL,QAAQ,CAACe,KAAK,CAAC/a,MAAM,GAAG,EAAE,CAAE;MAC1E,IAAMkb,oBAAoB,GAAG,IAAIvd,OAAO,EAAE;MAE1C,KAAM,IAAImC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGka,QAAQ,CAACe,KAAK,CAAC/a,MAAM,EAAE,EAAGF,CAAC,EAAG;QAElDkb,MAAM,CAAC5b,IAAI,CAAEoH,OAAO,CAACoE,GAAG,CAAEoP,QAAQ,CAACe,KAAK,CAAEjb,CAAC,CAAE,CAAE,CAAE;QACjDob,oBAAoB,CAACC,IAAI,CAAEnB,QAAQ,CAACoB,YAAY,CAAEtb,CAAC,CAAE,CAAE;QACvDob,oBAAoB,CAACG,QAAQ,CAAErR,MAAM,CAACsR,UAAU,CAAE,CAACzP,OAAO,CAAEoP,mBAAmB,EAAEnb,CAAC,GAAG,EAAE,CAAE;MAE1F;MAEA,IAAKgH,IAAI,CAACJ,KAAK,KAAKT,SAAS,EAAGa,IAAI,CAACJ,KAAK,GAAG,EAAE;MAE/CI,IAAI,CAACJ,KAAK,CAACtH,IAAI,CAAE;QAChB6b,mBAAmB,EAAE,IAAI,CAAC1E,eAAe,CAAE,IAAItZ,eAAe,CAAEge,mBAAmB,EAAE,EAAE,CAAE,CAAE;QAC3FD,MAAM,EAAEA,MAAM;QACdhB,QAAQ,EAAExT,OAAO,CAACoE,GAAG,CAAEkQ,SAAS;MACjC,CAAC,CAAE;MAEH,IAAMrF,SAAS,GAAGkF,IAAI,CAACY,IAAI,GAAGzU,IAAI,CAACJ,KAAK,CAAC1G,MAAM,GAAG,CAAC;MAEnD,OAAOyV,SAAS;IAEjB;;IAEA;AACD;AACA;AACA;AACA;EAJC;IAAA;IAAA,OAKA,qBAAazL,MAAM,EAAG;MAErB,IAAMlD,IAAI,GAAG,IAAI,CAACA,IAAI;MACtB,IAAMrH,OAAO,GAAG,IAAI,CAACA,OAAO;MAC5B,IAAM+G,OAAO,GAAG,IAAI,CAACA,OAAO;MAE5B,IAAK,CAAEM,IAAI,CAAC+T,KAAK,EAAG/T,IAAI,CAAC+T,KAAK,GAAG,EAAE;MAEnC,IAAMW,OAAO,GAAG,CAAC,CAAC;MAElB,IAAK/b,OAAO,CAACmI,GAAG,EAAG;QAElB,IAAMkE,QAAQ,GAAG9B,MAAM,CAAC5H,UAAU,CAACyJ,OAAO,EAAE;QAC5C,IAAM1J,QAAQ,GAAG6H,MAAM,CAAC7H,QAAQ,CAAC0J,OAAO,EAAE;QAC1C,IAAM3J,KAAK,GAAG8H,MAAM,CAAC9H,KAAK,CAAC2J,OAAO,EAAE;QAEpC,IAAK,CAAEjJ,UAAU,CAAEkJ,QAAQ,EAAE,CAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAE,CAAE,EAAG;UAE/C0P,OAAO,CAAC1P,QAAQ,GAAGA,QAAQ;QAE5B;QAEA,IAAK,CAAElJ,UAAU,CAAET,QAAQ,EAAE,CAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAE,CAAE,EAAG;UAE5CqZ,OAAO,CAACC,WAAW,GAAGtZ,QAAQ;QAE/B;QAEA,IAAK,CAAES,UAAU,CAAEV,KAAK,EAAE,CAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAE,CAAE,EAAG;UAEzCsZ,OAAO,CAACtZ,KAAK,GAAGA,KAAK;QAEtB;MAED,CAAC,MAAM;QAEN,IAAK8H,MAAM,CAAC0R,gBAAgB,EAAG;UAE9B1R,MAAM,CAAC2R,YAAY,EAAE;QAEtB;QAEA,IAAKpY,gBAAgB,CAAEyG,MAAM,CAACxG,MAAM,CAAE,KAAK,KAAK,EAAG;UAElDgY,OAAO,CAAChY,MAAM,GAAGwG,MAAM,CAACxG,MAAM,CAACC,QAAQ;QAExC;MAED;;MAEA;MACA,IAAKuG,MAAM,CAACQ,IAAI,KAAK,EAAE,EAAGgR,OAAO,CAAChR,IAAI,GAAGoR,MAAM,CAAE5R,MAAM,CAACQ,IAAI,CAAE;MAE9D,IAAI,CAAC0J,iBAAiB,CAAElK,MAAM,EAAEwR,OAAO,CAAE;MAEzC,IAAKxR,MAAM,CAAC6R,MAAM,IAAI7R,MAAM,CAAC8K,MAAM,IAAI9K,MAAM,CAAC+K,QAAQ,EAAG;QAExD,IAAM+G,SAAS,GAAG,IAAI,CAACC,WAAW,CAAE/R,MAAM,CAAE;QAE5C,IAAK8R,SAAS,KAAK,IAAI,EAAGN,OAAO,CAACpH,IAAI,GAAG0H,SAAS;MAEnD,CAAC,MAAM,IAAK9R,MAAM,CAACgS,QAAQ,EAAG;QAE7BR,OAAO,CAAC5D,MAAM,GAAG,IAAI,CAACqE,aAAa,CAAEjS,MAAM,CAAE;MAE9C;MAEA,IAAKA,MAAM,CAAC+P,aAAa,EAAG,IAAI,CAACrT,KAAK,CAACtH,IAAI,CAAE4K,MAAM,CAAE;MAErD,IAAKA,MAAM,CAACkS,QAAQ,CAAClc,MAAM,GAAG,CAAC,EAAG;QAEjC,IAAMkc,QAAQ,GAAG,EAAE;QAEnB,KAAM,IAAIpc,CAAC,GAAG,CAAC,EAAE0U,CAAC,GAAGxK,MAAM,CAACkS,QAAQ,CAAClc,MAAM,EAAEF,CAAC,GAAG0U,CAAC,EAAE1U,CAAC,EAAG,EAAG;UAE1D,IAAMqc,KAAK,GAAGnS,MAAM,CAACkS,QAAQ,CAAEpc,CAAC,CAAE;UAElC,IAAKqc,KAAK,CAACC,OAAO,IAAI3c,OAAO,CAACoI,WAAW,KAAK,KAAK,EAAG;YAErD,IAAMwU,UAAS,GAAG,IAAI,CAACC,WAAW,CAAEH,KAAK,CAAE;YAE3C,IAAKE,UAAS,KAAK,IAAI,EAAGH,QAAQ,CAAC9c,IAAI,CAAEid,UAAS,CAAE;UAErD;QAED;QAEA,IAAKH,QAAQ,CAAClc,MAAM,GAAG,CAAC,EAAGwb,OAAO,CAACU,QAAQ,GAAGA,QAAQ;MAEvD;MAEA,IAAI,CAAClL,UAAU,CAAE,UAAWC,GAAG,EAAG;QAEjCA,GAAG,CAACsL,SAAS,IAAItL,GAAG,CAACsL,SAAS,CAAEvS,MAAM,EAAEwR,OAAO,CAAE;MAElD,CAAC,CAAE;MAEH,IAAMa,SAAS,GAAGvV,IAAI,CAAC+T,KAAK,CAACzb,IAAI,CAAEoc,OAAO,CAAE,GAAG,CAAC;MAChDhV,OAAO,CAAChB,GAAG,CAAEwE,MAAM,EAAEqS,SAAS,CAAE;MAChC,OAAOA,SAAS;IAEjB;;IAEA;AACD;AACA;AACA;EAHC;IAAA;IAAA,OAIA,sBAAcG,KAAK,EAAG;MAErB,IAAM1V,IAAI,GAAG,IAAI,CAACA,IAAI;MACtB,IAAMrH,OAAO,GAAG,IAAI,CAACA,OAAO;MAE5B,IAAK,CAAEqH,IAAI,CAAC2V,MAAM,EAAG;QAEpB3V,IAAI,CAAC2V,MAAM,GAAG,EAAE;QAChB3V,IAAI,CAAC0V,KAAK,GAAG,CAAC;MAEf;MAEA,IAAME,QAAQ,GAAG,CAAC,CAAC;MAEnB,IAAKF,KAAK,CAAChS,IAAI,KAAK,EAAE,EAAGkS,QAAQ,CAAClS,IAAI,GAAGgS,KAAK,CAAChS,IAAI;MAEnD1D,IAAI,CAAC2V,MAAM,CAACrd,IAAI,CAAEsd,QAAQ,CAAE;MAE5B,IAAM7B,KAAK,GAAG,EAAE;MAEhB,KAAM,IAAI/a,CAAC,GAAG,CAAC,EAAE0U,CAAC,GAAGgI,KAAK,CAACN,QAAQ,CAAClc,MAAM,EAAEF,CAAC,GAAG0U,CAAC,EAAE1U,CAAC,EAAG,EAAG;QAEzD,IAAMqc,KAAK,GAAGK,KAAK,CAACN,QAAQ,CAAEpc,CAAC,CAAE;QAEjC,IAAKqc,KAAK,CAACC,OAAO,IAAI3c,OAAO,CAACoI,WAAW,KAAK,KAAK,EAAG;UAErD,IAAMwU,SAAS,GAAG,IAAI,CAACC,WAAW,CAAEH,KAAK,CAAE;UAE3C,IAAKE,SAAS,KAAK,IAAI,EAAGxB,KAAK,CAACzb,IAAI,CAAEid,SAAS,CAAE;QAElD;MAED;MAEA,IAAKxB,KAAK,CAAC7a,MAAM,GAAG,CAAC,EAAG0c,QAAQ,CAAC7B,KAAK,GAAGA,KAAK;MAE9C,IAAI,CAAC3G,iBAAiB,CAAEsI,KAAK,EAAEE,QAAQ,CAAE;IAE1C;;IAEA;AACD;AACA;AACA;EAHC;IAAA;IAAA,OAIA,wBAAgBC,OAAO,EAAG;MAEzB,IAAMH,KAAK,GAAG,IAAIre,KAAK,EAAE;MACzBqe,KAAK,CAAChS,IAAI,GAAG,UAAU;MAEvB,KAAM,IAAI1K,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6c,OAAO,CAAC3c,MAAM,EAAEF,CAAC,EAAG,EAAG;QAE3C;QACA;QACA0c,KAAK,CAACN,QAAQ,CAAC9c,IAAI,CAAEud,OAAO,CAAE7c,CAAC,CAAE,CAAE;MAEpC;MAEA,IAAI,CAAC8c,YAAY,CAAEJ,KAAK,CAAE;IAE3B;;IAEA;AACD;AACA;EAFC;IAAA;IAAA,OAGA,sBAAcld,KAAK,EAAG;MAErB,IAAMG,OAAO,GAAG,IAAI,CAACA,OAAO;MAE5BH,KAAK,GAAGA,KAAK,YAAY0E,KAAK,GAAG1E,KAAK,GAAG,CAAEA,KAAK,CAAE;MAElD,IAAI,CAAC0R,UAAU,CAAE,UAAWC,GAAG,EAAG;QAEjCA,GAAG,CAAC4L,WAAW,IAAI5L,GAAG,CAAC4L,WAAW,CAAEvd,KAAK,CAAE;MAE5C,CAAC,CAAE;MAEH,IAAMwd,mBAAmB,GAAG,EAAE;MAE9B,KAAM,IAAIhd,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,KAAK,CAACU,MAAM,EAAEF,CAAC,EAAG,EAAG;QAEzC,IAAKR,KAAK,CAAEQ,CAAC,CAAE,YAAY3B,KAAK,EAAG;UAElC,IAAI,CAACye,YAAY,CAAEtd,KAAK,CAAEQ,CAAC,CAAE,CAAE;QAEhC,CAAC,MAAM;UAENgd,mBAAmB,CAAC1d,IAAI,CAAEE,KAAK,CAAEQ,CAAC,CAAE,CAAE;QAEvC;MAED;MAEA,IAAKgd,mBAAmB,CAAC9c,MAAM,GAAG,CAAC,EAAG,IAAI,CAAC+c,cAAc,CAAED,mBAAmB,CAAE;MAEhF,KAAM,IAAIhd,GAAC,GAAG,CAAC,EAAEA,GAAC,GAAG,IAAI,CAAC4G,KAAK,CAAC1G,MAAM,EAAE,EAAGF,GAAC,EAAG;QAE9C,IAAI,CAACkd,WAAW,CAAE,IAAI,CAACtW,KAAK,CAAE5G,GAAC,CAAE,CAAE;MAEpC;MAEA,KAAM,IAAIA,GAAC,GAAG,CAAC,EAAEA,GAAC,GAAGL,OAAO,CAACwI,UAAU,CAACjI,MAAM,EAAE,EAAGF,GAAC,EAAG;QAEtD,IAAI,CAACmd,gBAAgB,CAAExd,OAAO,CAACwI,UAAU,CAAEnI,GAAC,CAAE,EAAER,KAAK,CAAE,CAAC,CAAE,CAAE;MAE7D;MAEA,IAAI,CAAC0R,UAAU,CAAE,UAAWC,GAAG,EAAG;QAEjCA,GAAG,CAACiM,UAAU,IAAIjM,GAAG,CAACiM,UAAU,CAAE5d,KAAK,CAAE;MAE1C,CAAC,CAAE;IAEJ;EAAC;IAAA;IAAA,OAED,oBAAY6d,IAAI,EAAG;MAElB,KAAM,IAAIrd,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAACF,OAAO,CAACG,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAG,EAAG;QAEzDqd,IAAI,CAAE,IAAI,CAACtd,OAAO,CAAEC,CAAC,CAAE,CAAE;MAE1B;IAED;EAAC;EAAA;AAAA;AAIF;AACA;AACA;AACA;AACA;AAJA,IAKMnB,kBAAkB;EAEvB,4BAAaD,MAAM,EAAG;IAAA;IAErB,IAAI,CAACA,MAAM,GAAGA,MAAM;IACpB,IAAI,CAAC8L,IAAI,GAAG,qBAAqB;EAElC;EAAC;IAAA;IAAA,OAED,mBAAW4S,KAAK,EAAE5B,OAAO,EAAG;MAE3B,IAAK,CAAE4B,KAAK,CAACC,OAAO,EAAG;MAEvB,IAAK,CAAED,KAAK,CAACE,kBAAkB,IAAI,CAAEF,KAAK,CAACG,YAAY,IAAI,CAAEH,KAAK,CAACI,WAAW,EAAG;QAEhF9d,OAAO,CAACC,IAAI,CAAE,6EAA6E,EAAEyd,KAAK,CAAE;QACpG;MAED;MAEA,IAAM1e,MAAM,GAAG,IAAI,CAACA,MAAM;MAC1B,IAAMoI,IAAI,GAAGpI,MAAM,CAACoI,IAAI;MACxB,IAAMH,cAAc,GAAGjI,MAAM,CAACiI,cAAc;MAE5C,IAAM8W,QAAQ,GAAG,CAAC,CAAC;MAEnB,IAAKL,KAAK,CAAC5S,IAAI,EAAGiT,QAAQ,CAACjT,IAAI,GAAG4S,KAAK,CAAC5S,IAAI;MAE5CiT,QAAQ,CAAChM,KAAK,GAAG2L,KAAK,CAAC3L,KAAK,CAAC5F,OAAO,EAAE;MAEtC4R,QAAQ,CAACC,SAAS,GAAGN,KAAK,CAACM,SAAS;MAEpC,IAAKN,KAAK,CAACE,kBAAkB,EAAG;QAE/BG,QAAQ,CAACrX,IAAI,GAAG,aAAa;MAE9B,CAAC,MAAM,IAAKgX,KAAK,CAACG,YAAY,EAAG;QAEhCE,QAAQ,CAACrX,IAAI,GAAG,OAAO;QAEvB,IAAKgX,KAAK,CAACO,QAAQ,GAAG,CAAC,EAAGF,QAAQ,CAACG,KAAK,GAAGR,KAAK,CAACO,QAAQ;MAE1D,CAAC,MAAM,IAAKP,KAAK,CAACI,WAAW,EAAG;QAE/BC,QAAQ,CAACrX,IAAI,GAAG,MAAM;QAEtB,IAAKgX,KAAK,CAACO,QAAQ,GAAG,CAAC,EAAGF,QAAQ,CAACG,KAAK,GAAGR,KAAK,CAACO,QAAQ;QAEzDF,QAAQ,CAACI,IAAI,GAAG,CAAC,CAAC;QAClBJ,QAAQ,CAACI,IAAI,CAACC,cAAc,GAAG,CAAEV,KAAK,CAACW,QAAQ,GAAG,GAAG,IAAKX,KAAK,CAACY,KAAK,GAAG,CAAE,GAAG;QAC7EP,QAAQ,CAACI,IAAI,CAACI,cAAc,GAAGb,KAAK,CAACY,KAAK;MAE3C;MAEA,IAAKZ,KAAK,CAACc,KAAK,KAAKjY,SAAS,IAAImX,KAAK,CAACc,KAAK,KAAK,CAAC,EAAG;QAErDxe,OAAO,CAACC,IAAI,CAAE,yEAAyE,GACpF,4BAA4B,CAAE;MAElC;MAEA,IAAKyd,KAAK,CAACzP,MAAM,KACVyP,KAAK,CAACzP,MAAM,CAACwQ,MAAM,KAAKf,KAAK,IAC/BA,KAAK,CAACzP,MAAM,CAACxL,QAAQ,CAAC+I,CAAC,KAAK,CAAC,IAC7BkS,KAAK,CAACzP,MAAM,CAACxL,QAAQ,CAACgJ,CAAC,KAAK,CAAC,IAC7BiS,KAAK,CAACzP,MAAM,CAACxL,QAAQ,CAACiJ,CAAC,KAAK,CAAE,CAAC,CAAE,EAAG;QAExC1L,OAAO,CAACC,IAAI,CAAE,qEAAqE,GAChF,8DAA8D,CAAE;MAEpE;MAEA,IAAK,CAAEgH,cAAc,CAAE,IAAI,CAAC6D,IAAI,CAAE,EAAG;QAEpC1D,IAAI,CAACsD,UAAU,GAAGtD,IAAI,CAACsD,UAAU,IAAI,CAAC,CAAC;QACvCtD,IAAI,CAACsD,UAAU,CAAE,IAAI,CAACI,IAAI,CAAE,GAAG;UAAE4T,MAAM,EAAE;QAAG,CAAC;QAC7CzX,cAAc,CAAE,IAAI,CAAC6D,IAAI,CAAE,GAAG,IAAI;MAEnC;MAEA,IAAM4T,MAAM,GAAGtX,IAAI,CAACsD,UAAU,CAAE,IAAI,CAACI,IAAI,CAAE,CAAC4T,MAAM;MAClDA,MAAM,CAAChf,IAAI,CAAEqe,QAAQ,CAAE;MAEvBjC,OAAO,CAACpR,UAAU,GAAGoR,OAAO,CAACpR,UAAU,IAAI,CAAC,CAAC;MAC7CoR,OAAO,CAACpR,UAAU,CAAE,IAAI,CAACI,IAAI,CAAE,GAAG;QAAE4S,KAAK,EAAEgB,MAAM,CAACpe,MAAM,GAAG;MAAE,CAAC;IAE/D;EAAC;EAAA;AAAA;AAIF;AACA;AACA;AACA;AACA;AAJA,IAKMpB,2BAA2B;EAEhC,qCAAaF,MAAM,EAAG;IAAA;IAErB,IAAI,CAACA,MAAM,GAAGA,MAAM;IACpB,IAAI,CAAC8L,IAAI,GAAG,qBAAqB;EAElC;EAAC;IAAA;IAAA,OAED,uBAAe2G,QAAQ,EAAEE,WAAW,EAAG;MAEtC,IAAK,CAAEF,QAAQ,CAACK,mBAAmB,EAAG;MAEtC,IAAM9S,MAAM,GAAG,IAAI,CAACA,MAAM;MAC1B,IAAMiI,cAAc,GAAGjI,MAAM,CAACiI,cAAc;MAE5C0K,WAAW,CAACjH,UAAU,GAAGiH,WAAW,CAACjH,UAAU,IAAI,CAAC,CAAC;MACrDiH,WAAW,CAACjH,UAAU,CAAE,IAAI,CAACI,IAAI,CAAE,GAAG,CAAC,CAAC;MAExC7D,cAAc,CAAE,IAAI,CAAC6D,IAAI,CAAE,GAAG,IAAI;MAElC6G,WAAW,CAACC,oBAAoB,CAACO,cAAc,GAAG,GAAG;MACrDR,WAAW,CAACC,oBAAoB,CAACQ,eAAe,GAAG,GAAG;IAEvD;EAAC;EAAA;AAAA;AAIF;AACA;AACA;AACA;AACA;AAJA,IAKMjT,kCAAkC;EAEvC,4CAAaH,MAAM,EAAG;IAAA;IAErB,IAAI,CAACA,MAAM,GAAGA,MAAM;IACpB,IAAI,CAAC8L,IAAI,GAAG,qCAAqC;EAElD;EAAC;IAAA;IAAA,OAED,uBAAe2G,QAAQ,EAAEE,WAAW,EAAG;MAEtC,IAAK,CAAEF,QAAQ,CAACkN,gCAAgC,EAAG;MAEnD,IAAM3f,MAAM,GAAG,IAAI,CAACA,MAAM;MAC1B,IAAMiI,cAAc,GAAGjI,MAAM,CAACiI,cAAc;MAE5C,IAAM2X,YAAY,GAAG,CAAC,CAAC;MAEvB,IAAKjN,WAAW,CAACC,oBAAoB,CAACM,eAAe,EAAG;QAEvD0M,YAAY,CAACC,aAAa,GAAGlN,WAAW,CAACC,oBAAoB,CAACM,eAAe;MAE9E;MAEA,IAAM4M,cAAc,GAAG,CAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAE;MAClCrN,QAAQ,CAACsN,QAAQ,CAAC5S,OAAO,CAAE2S,cAAc,EAAE,CAAC,CAAE;MAC9CF,YAAY,CAACE,cAAc,GAAGA,cAAc;MAC5CF,YAAY,CAACI,gBAAgB,GAAGvN,QAAQ,CAACwN,UAAU;MAEnD,IAAKtN,WAAW,CAACC,oBAAoB,CAACgB,gBAAgB,EAAG;QAExDgM,YAAY,CAACM,cAAc,GAAGvN,WAAW,CAACC,oBAAoB,CAACgB,gBAAgB;MAEhF;MAEA,IAAKnB,QAAQ,CAAC0N,WAAW,EAAG;QAE3B,IAAMC,cAAc,GAAG;UAAE7b,KAAK,EAAEvE,MAAM,CAACwT,cAAc,CAAEf,QAAQ,CAAC0N,WAAW;QAAG,CAAC;QAC/EngB,MAAM,CAACyT,qBAAqB,CAAE2M,cAAc,EAAE3N,QAAQ,CAAC0N,WAAW,CAAE;QACpEP,YAAY,CAACS,yBAAyB,GAAGD,cAAc;MAExD;MAEAzN,WAAW,CAACjH,UAAU,GAAGiH,WAAW,CAACjH,UAAU,IAAI,CAAC,CAAC;MACrDiH,WAAW,CAACjH,UAAU,CAAE,IAAI,CAACI,IAAI,CAAE,GAAG8T,YAAY;MAClD3X,cAAc,CAAE,IAAI,CAAC6D,IAAI,CAAE,GAAG,IAAI;IAEnC;EAAC;EAAA;AAAA;AAIF;AACA;AACA;AACA;AACA;AAJA,IAKMxL,+BAA+B;EAEpC,yCAAaN,MAAM,EAAG;IAAA;IAErB,IAAI,CAACA,MAAM,GAAGA,MAAM;IACpB,IAAI,CAAC8L,IAAI,GAAG,yBAAyB;EAEtC;EAAC;IAAA;IAAA,OAED,uBAAe2G,QAAQ,EAAEE,WAAW,EAAG;MAEtC,IAAK,CAAEF,QAAQ,CAAC6N,sBAAsB,EAAG;MAEzC,IAAMtgB,MAAM,GAAG,IAAI,CAACA,MAAM;MAC1B,IAAMiI,cAAc,GAAGjI,MAAM,CAACiI,cAAc;MAE5C,IAAM2X,YAAY,GAAG,CAAC,CAAC;MAEvBA,YAAY,CAACW,eAAe,GAAG9N,QAAQ,CAAC+N,SAAS;MAEjD,IAAK/N,QAAQ,CAACgO,YAAY,EAAG;QAE5B,IAAMC,eAAe,GAAG;UAAEnc,KAAK,EAAEvE,MAAM,CAACwT,cAAc,CAAEf,QAAQ,CAACgO,YAAY;QAAG,CAAC;QACjFzgB,MAAM,CAACyT,qBAAqB,CAAEiN,eAAe,EAAEjO,QAAQ,CAACgO,YAAY,CAAE;QACtEb,YAAY,CAACe,gBAAgB,GAAGD,eAAe;MAEhD;MAEAd,YAAY,CAACgB,wBAAwB,GAAGnO,QAAQ,CAACoO,kBAAkB;MAEnE,IAAKpO,QAAQ,CAACqO,qBAAqB,EAAG;QAErC,IAAMC,wBAAwB,GAAG;UAAExc,KAAK,EAAEvE,MAAM,CAACwT,cAAc,CAAEf,QAAQ,CAACqO,qBAAqB;QAAG,CAAC;QACnG9gB,MAAM,CAACyT,qBAAqB,CAAEsN,wBAAwB,EAAEtO,QAAQ,CAACqO,qBAAqB,CAAE;QACxFlB,YAAY,CAACoB,yBAAyB,GAAGD,wBAAwB;MAElE;MAEA,IAAKtO,QAAQ,CAACwO,kBAAkB,EAAG;QAElC,IAAMC,qBAAqB,GAAG;UAAE3c,KAAK,EAAEvE,MAAM,CAACwT,cAAc,CAAEf,QAAQ,CAACwO,kBAAkB;QAAG,CAAC;QAC7FjhB,MAAM,CAACyT,qBAAqB,CAAEyN,qBAAqB,EAAEzO,QAAQ,CAACwO,kBAAkB,CAAE;QAClFrB,YAAY,CAACuB,sBAAsB,GAAGD,qBAAqB;MAE5D;MAEAvO,WAAW,CAACjH,UAAU,GAAGiH,WAAW,CAACjH,UAAU,IAAI,CAAC,CAAC;MACrDiH,WAAW,CAACjH,UAAU,CAAE,IAAI,CAACI,IAAI,CAAE,GAAG8T,YAAY;MAElD3X,cAAc,CAAE,IAAI,CAAC6D,IAAI,CAAE,GAAG,IAAI;IAGnC;EAAC;EAAA;AAAA;AAIF;AACA;AACA;AACA;AACA;AAJA,IAKMvL,iCAAiC;EAEtC,2CAAaP,MAAM,EAAG;IAAA;IAErB,IAAI,CAACA,MAAM,GAAGA,MAAM;IACpB,IAAI,CAAC8L,IAAI,GAAG,2BAA2B;EAExC;EAAC;IAAA;IAAA,OAED,uBAAe2G,QAAQ,EAAEE,WAAW,EAAG;MAEtC,IAAK,CAAEF,QAAQ,CAAC6N,sBAAsB,EAAG;MAEzC,IAAMtgB,MAAM,GAAG,IAAI,CAACA,MAAM;MAC1B,IAAMiI,cAAc,GAAGjI,MAAM,CAACiI,cAAc;MAE5C,IAAM2X,YAAY,GAAG,CAAC,CAAC;MAEvBA,YAAY,CAACwB,iBAAiB,GAAG3O,QAAQ,CAAC4O,WAAW;MAErD,IAAK5O,QAAQ,CAAC6O,cAAc,EAAG;QAE9B,IAAMC,iBAAiB,GAAG;UAAEhd,KAAK,EAAEvE,MAAM,CAACwT,cAAc,CAAEf,QAAQ,CAAC6O,cAAc;QAAG,CAAC;QACrFthB,MAAM,CAACyT,qBAAqB,CAAE8N,iBAAiB,EAAE9O,QAAQ,CAAC6O,cAAc,CAAE;QAC1E1B,YAAY,CAAC4B,kBAAkB,GAAGD,iBAAiB;MAEpD;MAEA3B,YAAY,CAAC6B,cAAc,GAAGhP,QAAQ,CAACiP,cAAc;MACrD9B,YAAY,CAAC+B,2BAA2B,GAAGlP,QAAQ,CAACmP,yBAAyB,CAAE,CAAC,CAAE;MAClFhC,YAAY,CAACiC,2BAA2B,GAAGpP,QAAQ,CAACmP,yBAAyB,CAAE,CAAC,CAAE;MAElF,IAAKnP,QAAQ,CAACqP,uBAAuB,EAAG;QAEvC,IAAMC,0BAA0B,GAAG;UAAExd,KAAK,EAAEvE,MAAM,CAACwT,cAAc,CAAEf,QAAQ,CAACqP,uBAAuB;QAAG,CAAC;QACvG9hB,MAAM,CAACyT,qBAAqB,CAAEsO,0BAA0B,EAAEtP,QAAQ,CAACqP,uBAAuB,CAAE;QAC5FlC,YAAY,CAACoC,2BAA2B,GAAGD,0BAA0B;MAEtE;MAEApP,WAAW,CAACjH,UAAU,GAAGiH,WAAW,CAACjH,UAAU,IAAI,CAAC,CAAC;MACrDiH,WAAW,CAACjH,UAAU,CAAE,IAAI,CAACI,IAAI,CAAE,GAAG8T,YAAY;MAElD3X,cAAc,CAAE,IAAI,CAAC6D,IAAI,CAAE,GAAG,IAAI;IAEnC;EAAC;EAAA;AAAA;AAIF;AACA;AACA;AACA;AACA;AAJA,IAKM1L,kCAAkC;EAEvC,4CAAaJ,MAAM,EAAG;IAAA;IAErB,IAAI,CAACA,MAAM,GAAGA,MAAM;IACpB,IAAI,CAAC8L,IAAI,GAAG,4BAA4B;EAEzC;EAAC;IAAA;IAAA,OAED,uBAAe2G,QAAQ,EAAEE,WAAW,EAAG;MAEtC,IAAK,CAAEF,QAAQ,CAAC6N,sBAAsB,IAAI7N,QAAQ,CAACwP,YAAY,KAAK,CAAC,EAAG;MAExE,IAAMjiB,MAAM,GAAG,IAAI,CAACA,MAAM;MAC1B,IAAMiI,cAAc,GAAGjI,MAAM,CAACiI,cAAc;MAE5C,IAAM2X,YAAY,GAAG,CAAC,CAAC;MAEvBA,YAAY,CAACsC,kBAAkB,GAAGzP,QAAQ,CAACwP,YAAY;MAEvD,IAAKxP,QAAQ,CAAC0P,eAAe,EAAG;QAE/B,IAAMC,kBAAkB,GAAG;UAAE7d,KAAK,EAAEvE,MAAM,CAACwT,cAAc,CAAEf,QAAQ,CAAC0P,eAAe;QAAG,CAAC;QACvFniB,MAAM,CAACyT,qBAAqB,CAAE2O,kBAAkB,EAAE3P,QAAQ,CAAC0P,eAAe,CAAE;QAC5EvC,YAAY,CAACyC,mBAAmB,GAAGD,kBAAkB;MAEtD;MAEAzP,WAAW,CAACjH,UAAU,GAAGiH,WAAW,CAACjH,UAAU,IAAI,CAAC,CAAC;MACrDiH,WAAW,CAACjH,UAAU,CAAE,IAAI,CAACI,IAAI,CAAE,GAAG8T,YAAY;MAElD3X,cAAc,CAAE,IAAI,CAAC6D,IAAI,CAAE,GAAG,IAAI;IAEnC;EAAC;EAAA;AAAA;AAIF;AACA;AACA;AACA;AACA;AAJA,IAKMzL,4BAA4B;EAEjC,sCAAaL,MAAM,EAAG;IAAA;IAErB,IAAI,CAACA,MAAM,GAAGA,MAAM;IACpB,IAAI,CAAC8L,IAAI,GAAG,sBAAsB;EAEnC;EAAC;IAAA;IAAA,OAED,uBAAe2G,QAAQ,EAAEE,WAAW,EAAG;MAEtC,IAAK,CAAEF,QAAQ,CAAC6N,sBAAsB,IAAI7N,QAAQ,CAACwP,YAAY,KAAK,CAAC,EAAG;MAExE,IAAMjiB,MAAM,GAAG,IAAI,CAACA,MAAM;MAC1B,IAAMiI,cAAc,GAAGjI,MAAM,CAACiI,cAAc;MAE5C,IAAM2X,YAAY,GAAG,CAAC,CAAC;MAEvBA,YAAY,CAAC0C,eAAe,GAAG7P,QAAQ,CAAC8P,SAAS;MAEjD,IAAK9P,QAAQ,CAAC+P,YAAY,EAAG;QAE5B,IAAMC,eAAe,GAAG;UAAEle,KAAK,EAAEvE,MAAM,CAACwT,cAAc,CAAEf,QAAQ,CAAC+P,YAAY;QAAG,CAAC;QACjFxiB,MAAM,CAACyT,qBAAqB,CAAEgP,eAAe,EAAEhQ,QAAQ,CAAC+P,YAAY,CAAE;QACtE5C,YAAY,CAAC8C,gBAAgB,GAAGD,eAAe;MAEhD;MAEA7C,YAAY,CAAC+C,mBAAmB,GAAGlQ,QAAQ,CAACkQ,mBAAmB;MAC/D/C,YAAY,CAACgD,gBAAgB,GAAGnQ,QAAQ,CAACmQ,gBAAgB,CAACzV,OAAO,EAAE;MAEnEwF,WAAW,CAACjH,UAAU,GAAGiH,WAAW,CAACjH,UAAU,IAAI,CAAC,CAAC;MACrDiH,WAAW,CAACjH,UAAU,CAAE,IAAI,CAACI,IAAI,CAAE,GAAG8T,YAAY;MAElD3X,cAAc,CAAE,IAAI,CAAC6D,IAAI,CAAE,GAAG,IAAI;IAEnC;EAAC;EAAA;AAAA;AAIF;AACA;AACA;AACAjM,YAAY,CAAC2a,KAAK,GAAG;EAEpBqI,cAAc,EAAE,wBAAWjI,KAAK,EAAEkI,IAAI,EAAG;IAExC,IAAMC,SAAS,GAAG,KAAK,CAAC,CAAC;IACzB,IAAMC,SAAS,GAAGpI,KAAK,CAACqI,YAAY,EAAE;IAEtC,IAAMrH,KAAK,GAAG,IAAIhB,KAAK,CAACsI,cAAc,CAAEtI,KAAK,CAACgB,KAAK,CAACta,MAAM,GAAG,CAAC,CAAE;IAChE,IAAMqa,MAAM,GAAG,IAAIf,KAAK,CAACuI,eAAe,CAAEvI,KAAK,CAACe,MAAM,CAACra,MAAM,GAAG0hB,SAAS,CAAE;IAC3E,IAAMI,WAAW,GAAGxI,KAAK,CAACkB,iBAAiB,CAAE,IAAIlB,KAAK,CAACuI,eAAe,CAAEH,SAAS,CAAE,CAAE;IAErF,IAAIze,KAAK;IAET,IAAKqW,KAAK,CAACgB,KAAK,CAACta,MAAM,KAAK,CAAC,EAAG;MAE/Bsa,KAAK,CAAE,CAAC,CAAE,GAAGkH,IAAI;MAEjB,KAAM,IAAI1hB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4hB,SAAS,EAAE5hB,CAAC,EAAG,EAAG;QAEtCua,MAAM,CAAEva,CAAC,CAAE,GAAG,CAAC;MAEhB;MAEAmD,KAAK,GAAG,CAAC;IAEV,CAAC,MAAM,IAAKue,IAAI,GAAGlI,KAAK,CAACgB,KAAK,CAAE,CAAC,CAAE,EAAG;MAErC,IAAKxV,IAAI,CAACiG,GAAG,CAAEuO,KAAK,CAACgB,KAAK,CAAE,CAAC,CAAE,GAAGkH,IAAI,CAAE,GAAGC,SAAS,EAAG,OAAO,CAAC;MAE/DnH,KAAK,CAAE,CAAC,CAAE,GAAGkH,IAAI;MACjBlH,KAAK,CAAC9U,GAAG,CAAE8T,KAAK,CAACgB,KAAK,EAAE,CAAC,CAAE;MAE3BD,MAAM,CAAC7U,GAAG,CAAEsc,WAAW,CAACC,QAAQ,CAAEP,IAAI,CAAE,EAAE,CAAC,CAAE;MAC7CnH,MAAM,CAAC7U,GAAG,CAAE8T,KAAK,CAACe,MAAM,EAAEqH,SAAS,CAAE;MAErCze,KAAK,GAAG,CAAC;IAEV,CAAC,MAAM,IAAKue,IAAI,GAAGlI,KAAK,CAACgB,KAAK,CAAEhB,KAAK,CAACgB,KAAK,CAACta,MAAM,GAAG,CAAC,CAAE,EAAG;MAE1D,IAAK8E,IAAI,CAACiG,GAAG,CAAEuO,KAAK,CAACgB,KAAK,CAAEhB,KAAK,CAACgB,KAAK,CAACta,MAAM,GAAG,CAAC,CAAE,GAAGwhB,IAAI,CAAE,GAAGC,SAAS,EAAG;QAE3E,OAAOnI,KAAK,CAACgB,KAAK,CAACta,MAAM,GAAG,CAAC;MAE9B;MAEAsa,KAAK,CAAEA,KAAK,CAACta,MAAM,GAAG,CAAC,CAAE,GAAGwhB,IAAI;MAChClH,KAAK,CAAC9U,GAAG,CAAE8T,KAAK,CAACgB,KAAK,EAAE,CAAC,CAAE;MAE3BD,MAAM,CAAC7U,GAAG,CAAE8T,KAAK,CAACe,MAAM,EAAE,CAAC,CAAE;MAC7BA,MAAM,CAAC7U,GAAG,CAAEsc,WAAW,CAACC,QAAQ,CAAEP,IAAI,CAAE,EAAElI,KAAK,CAACe,MAAM,CAACra,MAAM,CAAE;MAE/DiD,KAAK,GAAGqX,KAAK,CAACta,MAAM,GAAG,CAAC;IAEzB,CAAC,MAAM;MAEN,KAAM,IAAIF,GAAC,GAAG,CAAC,EAAEA,GAAC,GAAGwZ,KAAK,CAACgB,KAAK,CAACta,MAAM,EAAEF,GAAC,EAAG,EAAG;QAE/C,IAAKgF,IAAI,CAACiG,GAAG,CAAEuO,KAAK,CAACgB,KAAK,CAAExa,GAAC,CAAE,GAAG0hB,IAAI,CAAE,GAAGC,SAAS,EAAG,OAAO3hB,GAAC;QAE/D,IAAKwZ,KAAK,CAACgB,KAAK,CAAExa,GAAC,CAAE,GAAG0hB,IAAI,IAAIlI,KAAK,CAACgB,KAAK,CAAExa,GAAC,GAAG,CAAC,CAAE,GAAG0hB,IAAI,EAAG;UAE7DlH,KAAK,CAAC9U,GAAG,CAAE8T,KAAK,CAACgB,KAAK,CAACrE,KAAK,CAAE,CAAC,EAAEnW,GAAC,GAAG,CAAC,CAAE,EAAE,CAAC,CAAE;UAC7Cwa,KAAK,CAAExa,GAAC,GAAG,CAAC,CAAE,GAAG0hB,IAAI;UACrBlH,KAAK,CAAC9U,GAAG,CAAE8T,KAAK,CAACgB,KAAK,CAACrE,KAAK,CAAEnW,GAAC,GAAG,CAAC,CAAE,EAAEA,GAAC,GAAG,CAAC,CAAE;UAE9Cua,MAAM,CAAC7U,GAAG,CAAE8T,KAAK,CAACe,MAAM,CAACpE,KAAK,CAAE,CAAC,EAAE,CAAEnW,GAAC,GAAG,CAAC,IAAK4hB,SAAS,CAAE,EAAE,CAAC,CAAE;UAC/DrH,MAAM,CAAC7U,GAAG,CAAEsc,WAAW,CAACC,QAAQ,CAAEP,IAAI,CAAE,EAAE,CAAE1hB,GAAC,GAAG,CAAC,IAAK4hB,SAAS,CAAE;UACjErH,MAAM,CAAC7U,GAAG,CAAE8T,KAAK,CAACe,MAAM,CAACpE,KAAK,CAAE,CAAEnW,GAAC,GAAG,CAAC,IAAK4hB,SAAS,CAAE,EAAE,CAAE5hB,GAAC,GAAG,CAAC,IAAK4hB,SAAS,CAAE;UAEhFze,KAAK,GAAGnD,GAAC,GAAG,CAAC;UAEb;QAED;MAED;IAED;IAEAwZ,KAAK,CAACgB,KAAK,GAAGA,KAAK;IACnBhB,KAAK,CAACe,MAAM,GAAGA,MAAM;IAErB,OAAOpX,KAAK;EAEb,CAAC;EAEDkW,sBAAsB,EAAE,gCAAWH,IAAI,EAAEC,IAAI,EAAG;IAE/C,IAAMG,MAAM,GAAG,EAAE;IACjB,IAAM4I,YAAY,GAAG,CAAC,CAAC;IACvB,IAAMC,YAAY,GAAGjJ,IAAI,CAACI,MAAM;IAEhC,KAAM,IAAItZ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmiB,YAAY,CAACjiB,MAAM,EAAE,EAAGF,CAAC,EAAG;MAEhD,IAAIoiB,WAAW,GAAGD,YAAY,CAAEniB,CAAC,CAAE;MACnC,IAAMqiB,kBAAkB,GAAGnkB,eAAe,CAACwb,cAAc,CAAE0I,WAAW,CAAC1X,IAAI,CAAE;MAC7E,IAAM4X,eAAe,GAAGpkB,eAAe,CAAC0b,QAAQ,CAAET,IAAI,EAAEkJ,kBAAkB,CAACxI,QAAQ,CAAE;MAErF,IAAKwI,kBAAkB,CAACtI,YAAY,KAAK,uBAAuB,IAAIsI,kBAAkB,CAACE,aAAa,KAAKpc,SAAS,EAAG;QAEpH;QACAmT,MAAM,CAACha,IAAI,CAAE8iB,WAAW,CAAE;QAC1B;MAED;MAEA,IAAKA,WAAW,CAAC1H,iBAAiB,KAAK0H,WAAW,CAACI,gCAAgC,IAC/EJ,WAAW,CAAC1H,iBAAiB,KAAK0H,WAAW,CAACK,8BAA8B,EAAG;QAElF,IAAKL,WAAW,CAAC1H,iBAAiB,CAACC,yCAAyC,EAAG;UAE9E;UACA;UACA,MAAM,IAAI7L,KAAK,CAAE,8EAA8E,CAAE;QAElG;QAEAlP,OAAO,CAACC,IAAI,CAAE,8FAA8F,CAAE;QAE9GuiB,WAAW,GAAGA,WAAW,CAACjX,KAAK,EAAE;QACjCiX,WAAW,CAACM,gBAAgB,CAAEnlB,iBAAiB,CAAE;MAElD;MAEA,IAAMolB,WAAW,GAAGL,eAAe,CAAC/f,qBAAqB,CAACrC,MAAM;MAChE,IAAM0iB,WAAW,GAAGN,eAAe,CAACzL,qBAAqB,CAAEwL,kBAAkB,CAACE,aAAa,CAAE;MAE7F,IAAKK,WAAW,KAAKzc,SAAS,EAAG;QAEhC,MAAM,IAAI2I,KAAK,CAAE,mDAAmD,GAAGuT,kBAAkB,CAACE,aAAa,CAAE;MAE1G;MAEA,IAAIM,WAAW;;MAEf;MACA;MACA,IAAKX,YAAY,CAAEI,eAAe,CAAC9N,IAAI,CAAE,KAAKrO,SAAS,EAAG;QAEzD0c,WAAW,GAAGT,WAAW,CAACjX,KAAK,EAAE;QAEjC,IAAMoP,MAAM,GAAG,IAAIsI,WAAW,CAACd,eAAe,CAAEY,WAAW,GAAGE,WAAW,CAACrI,KAAK,CAACta,MAAM,CAAE;QAExF,KAAM,IAAIkX,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyL,WAAW,CAACrI,KAAK,CAACta,MAAM,EAAEkX,CAAC,EAAG,EAAG;UAErDmD,MAAM,CAAEnD,CAAC,GAAGuL,WAAW,GAAGC,WAAW,CAAE,GAAGC,WAAW,CAACtI,MAAM,CAAEnD,CAAC,CAAE;QAElE;;QAEA;QACA;QACAyL,WAAW,CAACnY,IAAI,GAAG,CAAE2X,kBAAkB,CAACxI,QAAQ,IAAI,EAAE,IAAK,wBAAwB;QACnFgJ,WAAW,CAACtI,MAAM,GAAGA,MAAM;QAE3B2H,YAAY,CAAEI,eAAe,CAAC9N,IAAI,CAAE,GAAGqO,WAAW;QAClDvJ,MAAM,CAACha,IAAI,CAAEujB,WAAW,CAAE;QAE1B;MAED;MAEA,IAAMC,iBAAiB,GAAGV,WAAW,CAAC1H,iBAAiB,CAAE,IAAI0H,WAAW,CAACL,eAAe,CAAE,CAAC,CAAE,CAAE;MAE/Fc,WAAW,GAAGX,YAAY,CAAEI,eAAe,CAAC9N,IAAI,CAAE;;MAElD;MACA;MACA,KAAM,IAAI4C,EAAC,GAAG,CAAC,EAAEA,EAAC,GAAGyL,WAAW,CAACrI,KAAK,CAACta,MAAM,EAAEkX,EAAC,EAAG,EAAG;QAErDyL,WAAW,CAACtI,MAAM,CAAEnD,EAAC,GAAGuL,WAAW,GAAGC,WAAW,CAAE,GAAGE,iBAAiB,CAACb,QAAQ,CAAEY,WAAW,CAACrI,KAAK,CAAEpD,EAAC,CAAE,CAAE;MAE3G;;MAEA;MACA;MACA;MACA,KAAM,IAAIA,GAAC,GAAG,CAAC,EAAEA,GAAC,GAAGgL,WAAW,CAAC5H,KAAK,CAACta,MAAM,EAAEkX,GAAC,EAAG,EAAG;QAErD,IAAM2L,aAAa,GAAG,IAAI,CAACtB,cAAc,CAAEoB,WAAW,EAAET,WAAW,CAAC5H,KAAK,CAAEpD,GAAC,CAAE,CAAE;QAChFyL,WAAW,CAACtI,MAAM,CAAEwI,aAAa,GAAGJ,WAAW,GAAGC,WAAW,CAAE,GAAGR,WAAW,CAAC7H,MAAM,CAAEnD,GAAC,CAAE;MAE1F;IAED;IAEA8B,IAAI,CAACI,MAAM,GAAGA,MAAM;IAEpB,OAAOJ,IAAI;EAEZ;AAED,CAAC;AAED,SAASza,YAAY"},"metadata":{},"sourceType":"module","externalDependencies":[]}